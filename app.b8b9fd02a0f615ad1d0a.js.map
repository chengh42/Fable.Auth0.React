{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./output/.fable/fable-library.3.2.11/Util.js","webpack:///./output/.fable/fable-library.3.2.11/Types.js","webpack:///./output/.fable/fable-library.3.2.11/Reflection.js","webpack:///./output/.fable/fable-library.3.2.11/Int32.js","webpack:///./output/.fable/fable-library.3.2.11/Numeric.js","webpack:///./output/.fable/fable-library.3.2.11/lib/long.js","webpack:///./output/.fable/fable-library.3.2.11/Long.js","webpack:///./output/.fable/fable-library.3.2.11/Date.js","webpack:///./output/.fable/fable-library.3.2.11/RegExp.js","webpack:///./output/.fable/fable-library.3.2.11/String.js","webpack:///./output/.fable/fable-library.3.2.11/Option.js","webpack:///./output/.fable/fable-library.3.2.11/Array.js","webpack:///./output/.fable/fable-library.3.2.11/List.js","webpack:///./output/.fable/fable-library.3.2.11/AsyncBuilder.js","webpack:///./output/.fable/fable-library.3.2.11/Async.js","webpack:///./output/.fable/Fable.Elmish.3.1.0/prelude.fs","webpack:///./output/.fable/Fable.Elmish.3.1.0/cmd.fs","webpack:///./output/.fable/fable-library.3.2.11/Seq.js","webpack:///./output/.fable/fable-library.3.2.11/FSharp.Core.js","webpack:///./output/.fable/fable-library.3.2.11/BigInt/n.js","webpack:///./output/.fable/fable-library.3.2.11/lib/big.js","webpack:///./output/.fable/fable-library.3.2.11/Decimal.js","webpack:///./output/.fable/fable-library.3.2.11/BigInt/z.js","webpack:///./output/.fable/fable-library.3.2.11/BigInt.js","webpack:///./output/.fable/fable-library.3.2.11/Range.js","webpack:///./output/.fable/Fable.Elmish.3.1.0/ring.fs","webpack:///./output/.fable/Fable.Elmish.3.1.0/program.fs","webpack:///./output/.fable/Fable.Elmish.React.3.0.1/common.fs","webpack:///./output/.fable/Fable.Elmish.React.3.0.1/react.fs","webpack:///./output/.fable/fable-library.3.2.11/MapUtil.js","webpack:///./output/.fable/Feliz.DaisyUI.1.4.0/DaisyUI.fs","webpack:///./output/.fable/Feliz.DaisyUI.1.4.0/Operators.fs","webpack:///./Shared.fs","webpack:///./Pages/Usage.fs","webpack:///./Pages/CallApi.fs","webpack:///./Pages/Contribution.fs","webpack:///./output/.fable/Feliz.1.58.0/ReactInterop.js","webpack:///./output/.fable/Feliz.1.58.0/React.fs","webpack:///./output/.fable/Feliz.UseListener.0.6.3/Listener.fs","webpack:///./output/.fable/Feliz.Router.3.8.0/Router.fs","webpack:///./Pages/Acknowledgement.fs","webpack:///./Pages/Installation.fs","webpack:///../src/Fable.Auth0.React/Auth0.React.fs","webpack:///../src/Fable.Auth0.React/Auth0Provider.fs","webpack:///./Index.fs","webpack:///./App.fs"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","0","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","isArrayLike","x","Array","isArray","ArrayBuffer","isView","isHashable","GetHashCode","sameConstructor","y","getPrototypeOf","constructor","Enumerator","iter","this","current","cur","next","done","Error","getEnumerator","GetEnumerator","iterator","toIterator","en","hasNext","undefined","padWithZeros","str","toString","dateOffset","date","date1","offset","kind","getTimezoneOffset","int32ToString","radix","ObjectRef","idMap","has","set","count","stringHash","h","len","charCodeAt","numberHash","combineHashCodes","hashes","reduce","h1","h2","structuralHash","arrayHash","Date","getTime","dateHash","values","map","v","id","equalArraysWith","eq","equalArrays","equals","Equals","isEquatable","compareDates","xKeys","keys","yKeys","sort","equalObjects","xtime","ytime","comparePrimitives","compareArrays","comp","compareArraysWith","compare","CompareTo","isComparable","compareObjects","max","comparer","createObj","fields","obj","kv","WeakMap","uncurry","arity","f","uncurriedFn","a1","a2","a3","a4","a5","a6","a7","a8","curry","partialApply","args","concat","callStack","self","seqToString","cons","entries","k","join","String","cases","tag","fieldStr","withParens","indexOf","unionToString","other","recordToJSON","recordToString","recordGetHashCode","recordEquals","thisNames","recordCompareTo","Record","TypeInfo","fullname","generics","construct","parent","enumCases","fullName","gen","getHashCode","getGenerics","t1","t2","getRecordElements","k1","v1","k2","v2","endsWith","NumberStyles","op_UnaryNegation_Int32","symbol","isNumeric","multiply","toFixed","dp","toPrecision","sd","toExponential","toHex","Number","wasm","WebAssembly","Instance","Module","Uint8Array","e","Long","low","high","unsigned","isLong","toJSON","substr","fromBytes","toBytes","__isLong__","INT_CACHE","UINT_CACHE","fromInt","cachedObj","cache","fromBits","fromNumber","isNaN","UZERO","ZERO","TWO_PWR_64_DBL","MAX_UNSIGNED_VALUE","TWO_PWR_63_DBL","MIN_VALUE","MAX_VALUE","negate","TWO_PWR_32_DBL","lowBits","highBits","pow_dbl","Math","pow","fromString","RangeError","substring","radixToPower","size","min","parseInt","fromValue","val","TWO_PWR_16_DBL","TWO_PWR_24","ONE","UONE","NEG_ONE","toInt","$this","toNumber","isZero","radixLong","div","divide","rem1","subtract","rem","remDiv","digits","isOdd","lessThan","greaterThan","greaterThanOrEqual","thisNeg","otherNeg","not","addend","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","subtrahend","multiplier","mul","get_high","b00","divisor","approx","res","div_u","div_s","toUnsigned","shiftRightUnsigned","shiftLeft","shiftRight","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","numBits","le","hi","lo","toBytesLE","toBytesBE","bytes","fromBytesLE","fromBytesBE","op_Addition","op_Multiply","op_Division","op_Modulus","rem_u","rem_s","op_UnaryNegation","op_BitwiseAnd","fromInteger","xh","dateOffsetToString","isMinus","minutes","abs","dateToHalfUTCString","half","toISOString","dateToStringWithCustomFormat","format","utc","replace","match","rep","NaN","getUTCFullYear","getFullYear","getUTCMonth","getMonth","getUTCDate","getDate","getUTCHours","getHours","getUTCMinutes","getMinutes","getUTCSeconds","getSeconds","getUTCMilliseconds","getMilliseconds","dateToStringWithOffset","_a","_b","_c","dateWithOffset","dateToISOStringWithOffset","dateToStringWithKind","toUTCString","toLocaleString","toLocaleDateString","toLocaleTimeString","printOffset","dateToISOString","_provider","fsFormatRegExp","isLessThan","printf","input","cont","lastIndex","strParts","matches","strIdx","exec","matchIndex","index","createPrinter","_strParts","_matches","_result","padArg","arg","flags","_padLength","precision","padLength","formatReplacement","continuePrint","toText","sign","toLowerCase","toUpperCase","zeroFlag","minusFlag","ch","padLeft","isNullOrWhiteSpace","test","delimiter","xs","from","isRight","splitters","removeEmpty","split","arguments","splits","reg","RegExp","startIndex","some","toArray","opt","defaultArg","defaultValue","Helpers_allocateArrayFromCons","fill","target","targetIndex","start","initializer","equalsWith","array1","array2","length1","length2","compareWith","e1","e2","head","tail","super","xs_1_mut","ys_1_mut","loop","xs_1","ys_1","matchValue","xt","yt","i_mut","h_mut","_key","ListEnumerator$1","ListEnumerator$1_$ctor_3002E699","it","__","FSharpList_get_Empty","FSharpList_Cons_305B8EAC","FSharpList__get_IsEmpty","FSharpList__get_Length","FSharpList__get_Head","FSharpList__get_Tail","folder","state","acc","action","unitVar0","ofArrayWithTail","tail_1","ofArray","mapping","root","node","t_2","CancellationToken","cancelled","_id","_cancelled","_listeners","Map","listener","delete","$","addListener","removeListener","OperationCanceledError","setPrototypeOf","Trampoline","callCount","maxTrampolineCallCount","setTimeout","protectedCont","ctx","cancelToken","isCancelled","onCancel","trampoline","incrementAndCheck","hijack","err","onError","protectedBind","computation","binder","onSuccess","ex","protectedReturn","computation1","computation2","Bind","generator","sequence","body","While","Delay","compensation","catchHandler","ex2","resource","TryFinally","Dispose","guard","Return","emptyContinuation","_x","awaitPromise","conts","then","catch","defaultCancellationToken","startImmediate","cancellationToken","startWithContinuations","continuation","exceptionContinuation","cancellationContinuation","text","console","dispatch","cmd","cmds","lists","forEach","enumerator","xs_6","Enumerator_notStarted","Enumerator_alreadyFinished","Enumerator_FromFunctions$1","dispose","Enumerator_noReset","Enumerator_FromFunctions$1_$ctor_58C54629","Enumerator_enumerateThenFinally","Enumerator_generateWhileSome","openf","compute","closef","started","curr","x_1","finish","matchValue_1","checkNonNull","argName","Operators_NullArg","mkSeq","Enumerator_Seq_$ctor_673A07F2","delay","sources","outerOpt","innerOpt","finished","inner","outer","copyOfStruct","inner_1","outer_1","Enumerator_concat","st_1","Enumerator_unfold","ar","singleton","toList","xs_3","xs_5","ofSeq","generate","generateIndexed","ys","e_1","bound","BigNatModule_FFT_pow32","x_mut","n_mut","BigNatModule_FFT_maxTwoPower","Int32Array","BigNatModule_bound","BigNatModule_coeff","BigNatModule_coeff64","BigNatModule_setCoeff","BigNatModule_pow64","BigNatModule_pow32","BigNatModule_baseNi64","BigNatModule_baseMaski64","BigNatModule_createN","b","BigNatModule_normN","na_mut","na","findLeastBound","BigNatModule_embed","r_1","BigNatModule_eval32","BigNatModule_one","BigNatModule_zero","BigNatModule_degree","BigNatModule_isZero","BigNatModule_equal","q","pa_mut","qa_mut","pa","qa","check","BigNatModule_compare","BigNatModule_lt","BigNatModule_mulSchoolBookCarry","r_mut","c_mut","k_mut","rak","BigNatModule_mulSchoolBookOneSmall","bp","q_1","BigNatModule_mulSchoolBook","pSmall","qSmall","BigNatModule_mulSchoolBookBothSmall","ra","pai","qaj","BigNatModule_mulSchoolBookNeitherSmall","bigL","twoToBigL","bigK","bigN","BigNatModule_mkEncoding","BigNatModule_table","BigNatModule_mul","BigNatModule_scaleSubInPlace","a","patternInput","patternInput_1","ad","a_1","f_1","z","zLo","zHi","BigNatModule_scaleAddInPlace","BigNatModule_removeFactor","degx","dega","xa","aa","pn","qn","qai","BigNatModule_divmod","BigNatModule_copyN","Invariant","tupledArg","BigNatModule_ofInt32","BigNatModule_ofInt64","BigNatModule_embed64","BigNatModule_toString","degn","collect","isLeading_mut","digits_mut","n_1_mut","_arg1_mut","isLeading","n_1","_arg1","n_2","prior_1","nL","nH","digits_4","prior_mut","ten2k_mut","prior","ten2k","route","BigNatModule_isSmall","BigNatModule_getSmall","P","cmp","_this","NAME","INVALID","INVALID_DP","NUMERIC","nl","charAt","search","Big","DP","RM","rm","more","xc","findIndex","xci","idx","unshift","pop","stringify","doExponential","isNonzero","isneg","yc","bl","bt","ri","bz","ai","al","rl","qc","qi","gt","gte","lt","lte","minus","sub","xlty","plus","xe","ye","reverse","mod","ygtx","times","add","one","prec","round","sqrt","NE","PE","strict","valueOf","_Big_","normalize","TypeError","signInt","BigInteger__get_SignInt","BigInteger__get_V","BigInteger_op_Equality_56F059C0","BigNatModule_hash","BigInteger_op_LessThan_56F059C0","nn","BigInteger_$ctor_Z2BE94A1","BigInteger_nat_Z67CCE57D","smallLim","smallPosTab","pattern_matching_result","BigInteger_$ctor_Z524259A4","BigInteger_get_One","BigInteger_get_Two","two","BigInteger_get_Zero","zero","integralRangeStep","step","stop","stepFn","stepComparedWithZero","stepGreaterThanZero","comparedWithLast","makeRangeStepFunction","wix","rix","items","rix'","item","wix'","ix","setState","program","view","init","model","rb","reentered","syncDispatch","msg","nextMsg","update","model'","subscribe","props","nextProps","_nextState","equal","lazyView2With","placeholderId","document","getElementById","CaseRules","dashify","separator","keyValueList","caseRule","definedCaseRule","fail","kvPair","assign","changeCase","cn","classes","prop1","prop2","href","children","arg00","getDisposable","disposable","deps","renderElement","areEqual","withKey","memoElementType","effect","dependencies","_arg4","initialValue","createFunction","callback","lastRenderCallbackRef","callbackRef","callbackFunction","maybeOptions","options","passive","allowsPassiveEvents","capture","once","prefix","suffix","lastIndexOf","routeMode","activePatternResult21391","path","activePatternResult21392","activePatternResult21393","_arg2","activePatternResult21396","part","encodeURIComponent","zs","segment","chars","trimEnd","decodeURIComponent","query","onChange","ev","urlChanged","onUrlChanged","location","pathname","hash","hashMode","navigator","eventType","addOptions","removeOptions","fn","application","opts","Auth0Provider","url","page","ctxAuth0","useAuth0","isLoading","isAuthenticated","arg10","user","u","picture","getAccessTokenSilently","title","pages","CurrentPage","LoginButton","menuPages","Profile","rightSide","leftSide","UserAccessToken","pageLayout"],"mappings":"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","file":"app.b8b9fd02a0f615ad1d0a.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t0: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([6,1]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","// tslint:disable:ban-types\nexport function isIterable(x) {\n    return x != null && typeof x === \"object\" && Symbol.iterator in x;\n}\nexport function isArrayLike(x) {\n    return Array.isArray(x) || ArrayBuffer.isView(x);\n}\nfunction isComparer(x) {\n    return typeof x.Compare === \"function\";\n}\nfunction isComparable(x) {\n    return typeof x.CompareTo === \"function\";\n}\nfunction isEquatable(x) {\n    return typeof x.Equals === \"function\";\n}\nfunction isHashable(x) {\n    return typeof x.GetHashCode === \"function\";\n}\nexport function isDisposable(x) {\n    return x != null && typeof x.Dispose === \"function\";\n}\nexport function sameConstructor(x, y) {\n    return Object.getPrototypeOf(x).constructor === Object.getPrototypeOf(y).constructor;\n}\nexport class Enumerator {\n    constructor(iter) {\n        this.iter = iter;\n    }\n    [\"System.Collections.Generic.IEnumerator`1.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.MoveNext\"]() {\n        const cur = this.iter.next();\n        this.current = cur.value;\n        return !cur.done;\n    }\n    [\"System.Collections.IEnumerator.Reset\"]() {\n        throw new Error(\"JS iterators cannot be reset\");\n    }\n    Dispose() {\n        return;\n    }\n}\nexport function getEnumerator(o) {\n    return typeof o.GetEnumerator === \"function\"\n        ? o.GetEnumerator()\n        : new Enumerator(o[Symbol.iterator]());\n}\nexport function toIterator(en) {\n    return {\n        [Symbol.iterator]() { return this; },\n        next() {\n            const hasNext = en[\"System.Collections.IEnumerator.MoveNext\"]();\n            const current = hasNext ? en[\"System.Collections.IEnumerator.get_Current\"]() : undefined;\n            return { done: !hasNext, value: current };\n        },\n    };\n}\nexport class Comparer {\n    constructor(f) {\n        this.Compare = f || compare;\n    }\n}\nexport function comparerFromEqualityComparer(comparer) {\n    // Sometimes IEqualityComparer also implements IComparer\n    if (isComparer(comparer)) {\n        return new Comparer(comparer.Compare);\n    }\n    else {\n        return new Comparer((x, y) => {\n            const xhash = comparer.GetHashCode(x);\n            const yhash = comparer.GetHashCode(y);\n            if (xhash === yhash) {\n                return comparer.Equals(x, y) ? 0 : -1;\n            }\n            else {\n                return xhash < yhash ? -1 : 1;\n            }\n        });\n    }\n}\nexport function assertEqual(actual, expected, msg) {\n    if (!equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nexport function assertNotEqual(actual, expected, msg) {\n    if (equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nexport class Lazy {\n    constructor(factory) {\n        this.factory = factory;\n        this.isValueCreated = false;\n    }\n    get Value() {\n        if (!this.isValueCreated) {\n            this.createdValue = this.factory();\n            this.isValueCreated = true;\n        }\n        return this.createdValue;\n    }\n    get IsValueCreated() {\n        return this.isValueCreated;\n    }\n}\nexport function lazyFromValue(v) {\n    return new Lazy(() => v);\n}\nexport function padWithZeros(i, length) {\n    let str = i.toString(10);\n    while (str.length < length) {\n        str = \"0\" + str;\n    }\n    return str;\n}\nexport function padLeftAndRightWithZeros(i, lengthLeft, lengthRight) {\n    let str = i.toString(10);\n    while (str.length < lengthLeft) {\n        str = \"0\" + str;\n    }\n    while (str.length < lengthRight) {\n        str = str + \"0\";\n    }\n    return str;\n}\nexport function dateOffset(date) {\n    const date1 = date;\n    return typeof date1.offset === \"number\"\n        ? date1.offset\n        : (date.kind === 1 /* UTC */\n            ? 0 : date.getTimezoneOffset() * -60000);\n}\nexport function int16ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nexport function int32ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFFFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nexport class ObjectRef {\n    static id(o) {\n        if (!ObjectRef.idMap.has(o)) {\n            ObjectRef.idMap.set(o, ++ObjectRef.count);\n        }\n        return ObjectRef.idMap.get(o);\n    }\n}\nObjectRef.idMap = new WeakMap();\nObjectRef.count = 0;\nexport function stringHash(s) {\n    let i = 0;\n    let h = 5381;\n    const len = s.length;\n    while (i < len) {\n        h = (h * 33) ^ s.charCodeAt(i++);\n    }\n    return h;\n}\nexport function numberHash(x) {\n    return x * 2654435761 | 0;\n}\n// From https://stackoverflow.com/a/37449594\nexport function combineHashCodes(hashes) {\n    if (hashes.length === 0) {\n        return 0;\n    }\n    return hashes.reduce((h1, h2) => {\n        return ((h1 << 5) + h1) ^ h2;\n    });\n}\nexport function physicalHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"string\":\n            return stringHash(x);\n        default:\n            return numberHash(ObjectRef.id(x));\n    }\n}\nexport function identityHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    else if (isHashable(x)) {\n        return x.GetHashCode();\n    }\n    else {\n        return physicalHash(x);\n    }\n}\nexport function dateHash(x) {\n    return x.getTime();\n}\nexport function arrayHash(x) {\n    const len = x.length;\n    const hashes = new Array(len);\n    for (let i = 0; i < len; i++) {\n        hashes[i] = structuralHash(x[i]);\n    }\n    return combineHashCodes(hashes);\n}\nexport function structuralHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"string\":\n            return stringHash(x);\n        default: {\n            if (isHashable(x)) {\n                return x.GetHashCode();\n            }\n            else if (isArrayLike(x)) {\n                return arrayHash(x);\n            }\n            else if (x instanceof Date) {\n                return dateHash(x);\n            }\n            else if (Object.getPrototypeOf(x).constructor === Object) {\n                // TODO: check call-stack to prevent cyclic objects?\n                const hashes = Object.values(x).map((v) => structuralHash(v));\n                return combineHashCodes(hashes);\n            }\n            else {\n                // Classes don't implement GetHashCode by default, but must use identity hashing\n                return numberHash(ObjectRef.id(x));\n                // return stringHash(String(x));\n            }\n        }\n    }\n}\n// Intended for custom numeric types, like long or decimal\nexport function fastStructuralHash(x) {\n    return stringHash(String(x));\n}\n// Intended for declared types that may or may not implement GetHashCode\nexport function safeHash(x) {\n    return x == null ? 0 : isHashable(x) ? x.GetHashCode() : numberHash(ObjectRef.id(x));\n}\nexport function equalArraysWith(x, y, eq) {\n    if (x == null) {\n        return y == null;\n    }\n    if (y == null) {\n        return false;\n    }\n    if (x.length !== y.length) {\n        return false;\n    }\n    for (let i = 0; i < x.length; i++) {\n        if (!eq(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function equalArrays(x, y) {\n    return equalArraysWith(x, y, equals);\n}\nfunction equalObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return false;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0; i < xKeys.length; i++) {\n        if (xKeys[i] !== yKeys[i] || !equals(x[xKeys[i]], y[yKeys[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function equals(x, y) {\n    if (x === y) {\n        return true;\n    }\n    else if (x == null) {\n        return y == null;\n    }\n    else if (y == null) {\n        return false;\n    }\n    else if (typeof x !== \"object\") {\n        return false;\n    }\n    else if (isEquatable(x)) {\n        return x.Equals(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) && equalArrays(x, y);\n    }\n    else if (x instanceof Date) {\n        return (y instanceof Date) && compareDates(x, y) === 0;\n    }\n    else {\n        return Object.getPrototypeOf(x).constructor === Object && equalObjects(x, y);\n    }\n}\nexport function compareDates(x, y) {\n    let xtime;\n    let ytime;\n    // DateTimeOffset and DateTime deals with equality differently.\n    if (\"offset\" in x && \"offset\" in y) {\n        xtime = x.getTime();\n        ytime = y.getTime();\n    }\n    else {\n        xtime = x.getTime() + dateOffset(x);\n        ytime = y.getTime() + dateOffset(y);\n    }\n    return xtime === ytime ? 0 : (xtime < ytime ? -1 : 1);\n}\nexport function comparePrimitives(x, y) {\n    return x === y ? 0 : (x < y ? -1 : 1);\n}\nexport function compareArraysWith(x, y, comp) {\n    if (x == null) {\n        return y == null ? 0 : 1;\n    }\n    if (y == null) {\n        return -1;\n    }\n    if (x.length !== y.length) {\n        return x.length < y.length ? -1 : 1;\n    }\n    for (let i = 0, j = 0; i < x.length; i++) {\n        j = comp(x[i], y[i]);\n        if (j !== 0) {\n            return j;\n        }\n    }\n    return 0;\n}\nexport function compareArrays(x, y) {\n    return compareArraysWith(x, y, compare);\n}\nfunction compareObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return xKeys.length < yKeys.length ? -1 : 1;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0, j = 0; i < xKeys.length; i++) {\n        const key = xKeys[i];\n        if (key !== yKeys[i]) {\n            return key < yKeys[i] ? -1 : 1;\n        }\n        else {\n            j = compare(x[key], y[key]);\n            if (j !== 0) {\n                return j;\n            }\n        }\n    }\n    return 0;\n}\nexport function compare(x, y) {\n    if (x === y) {\n        return 0;\n    }\n    else if (x == null) {\n        return y == null ? 0 : -1;\n    }\n    else if (y == null) {\n        return 1;\n    }\n    else if (typeof x !== \"object\") {\n        return x < y ? -1 : 1;\n    }\n    else if (isComparable(x)) {\n        return x.CompareTo(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) ? compareArrays(x, y) : -1;\n    }\n    else if (x instanceof Date) {\n        return y instanceof Date ? compareDates(x, y) : -1;\n    }\n    else {\n        return Object.getPrototypeOf(x).constructor === Object ? compareObjects(x, y) : -1;\n    }\n}\nexport function min(comparer, x, y) {\n    return comparer(x, y) < 0 ? x : y;\n}\nexport function max(comparer, x, y) {\n    return comparer(x, y) > 0 ? x : y;\n}\nexport function clamp(comparer, value, min, max) {\n    return (comparer(value, min) < 0) ? min : (comparer(value, max) > 0) ? max : value;\n}\nexport function createAtom(value) {\n    let atom = value;\n    return (value, isSetter) => {\n        if (!isSetter) {\n            return atom;\n        }\n        else {\n            atom = value;\n            return void 0;\n        }\n    };\n}\nexport function createObj(fields) {\n    const obj = {};\n    for (const kv of fields) {\n        obj[kv[0]] = kv[1];\n    }\n    return obj;\n}\nexport function jsOptions(mutator) {\n    const opts = {};\n    mutator(opts);\n    return opts;\n}\nexport function round(value, digits = 0) {\n    const m = Math.pow(10, digits);\n    const n = +(digits ? value * m : value).toFixed(8);\n    const i = Math.floor(n);\n    const f = n - i;\n    const e = 1e-8;\n    const r = (f > 0.5 - e && f < 0.5 + e) ? ((i % 2 === 0) ? i : i + 1) : Math.round(n);\n    return digits ? r / m : r;\n}\nexport function sign(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n}\nexport function randomNext(min, max) {\n    return Math.floor(Math.random() * (max - min)) + min;\n}\nexport function randomBytes(buffer) {\n    if (buffer == null) {\n        throw new Error(\"Buffer cannot be null\");\n    }\n    for (let i = 0; i < buffer.length; i += 6) {\n        // Pick random 48-bit number. Fill buffer in 2 24-bit chunks to avoid bitwise truncation.\n        let r = Math.floor(Math.random() * 281474976710656); // Low 24 bits = chunk 1.\n        const rhi = Math.floor(r / 16777216); // High 24 bits shifted via division = chunk 2.\n        for (let j = 0; j < 6 && i + j < buffer.length; j++) {\n            if (j === 3) {\n                r = rhi;\n            }\n            buffer[i + j] = r & 255;\n            r >>>= 8;\n        }\n    }\n}\nexport function unescapeDataString(s) {\n    // https://stackoverflow.com/a/4458580/524236\n    return decodeURIComponent((s).replace(/\\+/g, \"%20\"));\n}\nexport function escapeDataString(s) {\n    return encodeURIComponent(s).replace(/!/g, \"%21\")\n        .replace(/'/g, \"%27\")\n        .replace(/\\(/g, \"%28\")\n        .replace(/\\)/g, \"%29\")\n        .replace(/\\*/g, \"%2A\");\n}\nexport function escapeUriString(s) {\n    return encodeURI(s);\n}\n// ICollection.Clear and Count members can be called on Arrays\n// or Dictionaries so we need a runtime check (see #1120)\nexport function count(col) {\n    if (isArrayLike(col)) {\n        return col.length;\n    }\n    else {\n        let count = 0;\n        for (const _ of col) {\n            count++;\n        }\n        return count;\n    }\n}\nexport function clear(col) {\n    if (isArrayLike(col)) {\n        col.splice(0);\n    }\n    else {\n        col.clear();\n    }\n}\nconst CURRIED_KEY = \"__CURRIED__\";\nexport function uncurry(arity, f) {\n    // f may be a function option with None value\n    if (f == null || f.length > 1) {\n        return f;\n    }\n    let uncurriedFn;\n    switch (arity) {\n        case 2:\n            uncurriedFn = (a1, a2) => f(a1)(a2);\n            break;\n        case 3:\n            uncurriedFn = (a1, a2, a3) => f(a1)(a2)(a3);\n            break;\n        case 4:\n            uncurriedFn = (a1, a2, a3, a4) => f(a1)(a2)(a3)(a4);\n            break;\n        case 5:\n            uncurriedFn = (a1, a2, a3, a4, a5) => f(a1)(a2)(a3)(a4)(a5);\n            break;\n        case 6:\n            uncurriedFn = (a1, a2, a3, a4, a5, a6) => f(a1)(a2)(a3)(a4)(a5)(a6);\n            break;\n        case 7:\n            uncurriedFn = (a1, a2, a3, a4, a5, a6, a7) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7);\n            break;\n        case 8:\n            uncurriedFn = (a1, a2, a3, a4, a5, a6, a7, a8) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8);\n            break;\n        default:\n            throw new Error(\"Uncurrying to more than 8-arity is not supported: \" + arity);\n    }\n    uncurriedFn[CURRIED_KEY] = f;\n    return uncurriedFn;\n}\nexport function curry(arity, f) {\n    if (f == null || f.length === 1) {\n        return f;\n    }\n    if (CURRIED_KEY in f) {\n        return f[CURRIED_KEY];\n    }\n    switch (arity) {\n        case 2:\n            return (a1) => (a2) => f(a1, a2);\n        case 3:\n            return (a1) => (a2) => (a3) => f(a1, a2, a3);\n        case 4:\n            return (a1) => (a2) => (a3) => (a4) => f(a1, a2, a3, a4);\n        case 5:\n            return (a1) => (a2) => (a3) => (a4) => (a5) => f(a1, a2, a3, a4, a5);\n        case 6:\n            return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => f(a1, a2, a3, a4, a5, a6);\n        case 7:\n            return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => f(a1, a2, a3, a4, a5, a6, a7);\n        case 8:\n            return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => f(a1, a2, a3, a4, a5, a6, a7, a8);\n        default:\n            throw new Error(\"Currying to more than 8-arity is not supported: \" + arity);\n    }\n}\nexport function checkArity(arity, f) {\n    return f.length > arity\n        ? (...args1) => (...args2) => f.apply(undefined, args1.concat(args2))\n        : f;\n}\nexport function partialApply(arity, f, args) {\n    if (f == null) {\n        return undefined;\n    }\n    else if (CURRIED_KEY in f) {\n        f = f[CURRIED_KEY];\n        for (let i = 0; i < args.length; i++) {\n            f = f(args[i]);\n        }\n        return f;\n    }\n    else {\n        switch (arity) {\n            case 1:\n                // Wrap arguments to make sure .concat doesn't destruct arrays. Example\n                // [1,2].concat([3,4],5)   --> [1,2,3,4,5]    // fails\n                // [1,2].concat([[3,4],5]) --> [1,2,[3,4],5]  // ok\n                return (a1) => f.apply(undefined, args.concat([a1]));\n            case 2:\n                return (a1) => (a2) => f.apply(undefined, args.concat([a1, a2]));\n            case 3:\n                return (a1) => (a2) => (a3) => f.apply(undefined, args.concat([a1, a2, a3]));\n            case 4:\n                return (a1) => (a2) => (a3) => (a4) => f.apply(undefined, args.concat([a1, a2, a3, a4]));\n            case 5:\n                return (a1) => (a2) => (a3) => (a4) => (a5) => f.apply(undefined, args.concat([a1, a2, a3, a4, a5]));\n            case 6:\n                return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => f.apply(undefined, args.concat([a1, a2, a3, a4, a5, a6]));\n            case 7:\n                return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => f.apply(undefined, args.concat([a1, a2, a3, a4, a5, a6, a7]));\n            case 8:\n                return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => f.apply(undefined, args.concat([a1, a2, a3, a4, a5, a6, a7, a8]));\n            default:\n                throw new Error(\"Partially applying to more than 8-arity is not supported: \" + arity);\n        }\n    }\n}\nexport function mapCurriedArgs(fn, mappings) {\n    function mapArg(fn, arg, mappings, idx) {\n        const mapping = mappings[idx];\n        if (mapping !== 0) {\n            const expectedArity = mapping[0];\n            const actualArity = mapping[1];\n            if (expectedArity > 1) {\n                arg = curry(expectedArity, arg);\n            }\n            if (actualArity > 1) {\n                arg = uncurry(actualArity, arg);\n            }\n        }\n        const res = fn(arg);\n        if (idx + 1 === mappings.length) {\n            return res;\n        }\n        else {\n            return (arg) => mapArg(res, arg, mappings, idx + 1);\n        }\n    }\n    return (arg) => mapArg(fn, arg, mappings, 0);\n}\n","import { combineHashCodes, compare, compareArrays, equalArrays, equals, sameConstructor, numberHash, structuralHash } from \"./Util.js\";\nexport function seqToString(self) {\n    let count = 0;\n    let str = \"[\";\n    for (const x of self) {\n        if (count === 0) {\n            str += toString(x);\n        }\n        else if (count === 100) {\n            str += \"; ...\";\n            break;\n        }\n        else {\n            str += \"; \" + toString(x);\n        }\n        count++;\n    }\n    return str + \"]\";\n}\nexport function toString(x, callStack = 0) {\n    if (x != null && typeof x === \"object\") {\n        if (typeof x.toString === \"function\") {\n            return x.toString();\n        }\n        else if (Symbol.iterator in x) {\n            return seqToString(x);\n        }\n        else { // TODO: Date?\n            const cons = Object.getPrototypeOf(x).constructor;\n            return cons === Object && callStack < 10\n                // Same format as recordToString\n                ? \"{ \" + Object.entries(x).map(([k, v]) => k + \" = \" + toString(v, callStack + 1)).join(\"\\n  \") + \" }\"\n                : cons.name;\n        }\n    }\n    return String(x);\n}\nexport function unionToString(name, fields) {\n    if (fields.length === 0) {\n        return name;\n    }\n    else {\n        let fieldStr = \"\";\n        let withParens = true;\n        if (fields.length === 1) {\n            fieldStr = toString(fields[0]);\n            withParens = fieldStr.indexOf(\" \") >= 0;\n        }\n        else {\n            fieldStr = fields.map((x) => toString(x)).join(\", \");\n        }\n        return name + (withParens ? \" (\" : \" \") + fieldStr + (withParens ? \")\" : \"\");\n    }\n}\nexport class Union {\n    get name() {\n        return this.cases()[this.tag];\n    }\n    toJSON() {\n        return this.fields.length === 0 ? this.name : [this.name].concat(this.fields);\n    }\n    toString() {\n        return unionToString(this.name, this.fields);\n    }\n    GetHashCode() {\n        const hashes = this.fields.map((x) => structuralHash(x));\n        hashes.splice(0, 0, numberHash(this.tag));\n        return combineHashCodes(hashes);\n    }\n    Equals(other) {\n        if (this === other) {\n            return true;\n        }\n        else if (!sameConstructor(this, other)) {\n            return false;\n        }\n        else if (this.tag === other.tag) {\n            return equalArrays(this.fields, other.fields);\n        }\n        else {\n            return false;\n        }\n    }\n    CompareTo(other) {\n        if (this === other) {\n            return 0;\n        }\n        else if (!sameConstructor(this, other)) {\n            return -1;\n        }\n        else if (this.tag === other.tag) {\n            return compareArrays(this.fields, other.fields);\n        }\n        else {\n            return this.tag < other.tag ? -1 : 1;\n        }\n    }\n}\nfunction recordToJSON(self) {\n    const o = {};\n    const keys = Object.keys(self);\n    for (let i = 0; i < keys.length; i++) {\n        o[keys[i]] = self[keys[i]];\n    }\n    return o;\n}\nfunction recordToString(self) {\n    return \"{ \" + Object.entries(self).map(([k, v]) => k + \" = \" + toString(v)).join(\"\\n  \") + \" }\";\n}\nfunction recordGetHashCode(self) {\n    const hashes = Object.values(self).map((v) => structuralHash(v));\n    return combineHashCodes(hashes);\n}\nfunction recordEquals(self, other) {\n    if (self === other) {\n        return true;\n    }\n    else if (!sameConstructor(self, other)) {\n        return false;\n    }\n    else {\n        const thisNames = Object.keys(self);\n        for (let i = 0; i < thisNames.length; i++) {\n            if (!equals(self[thisNames[i]], other[thisNames[i]])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nfunction recordCompareTo(self, other) {\n    if (self === other) {\n        return 0;\n    }\n    else if (!sameConstructor(self, other)) {\n        return -1;\n    }\n    else {\n        const thisNames = Object.keys(self);\n        for (let i = 0; i < thisNames.length; i++) {\n            const result = compare(self[thisNames[i]], other[thisNames[i]]);\n            if (result !== 0) {\n                return result;\n            }\n        }\n        return 0;\n    }\n}\nexport class Record {\n    toJSON() { return recordToJSON(this); }\n    toString() { return recordToString(this); }\n    GetHashCode() { return recordGetHashCode(this); }\n    Equals(other) { return recordEquals(this, other); }\n    CompareTo(other) { return recordCompareTo(this, other); }\n}\nexport class FSharpRef {\n    constructor(contentsOrGetter, setter) {\n        if (typeof setter === \"function\") {\n            this.getter = contentsOrGetter;\n            this.setter = setter;\n        }\n        else {\n            this.getter = () => contentsOrGetter;\n            this.setter = (v) => { contentsOrGetter = v; };\n        }\n    }\n    get contents() {\n        return this.getter();\n    }\n    set contents(v) {\n        this.setter(v);\n    }\n}\n// EXCEPTIONS\n// Exception is intentionally not derived from Error, for performance reasons (see #2160)\nexport class Exception {\n    constructor(message) {\n        this.message = message;\n    }\n}\nexport function isException(x) {\n    return x instanceof Exception || x instanceof Error;\n}\nexport class FSharpException extends Exception {\n    toJSON() { return recordToJSON(this); }\n    toString() { return recordToString(this); }\n    GetHashCode() { return recordGetHashCode(this); }\n    Equals(other) { return recordEquals(this, other); }\n    CompareTo(other) { return recordCompareTo(this, other); }\n}\nexport class MatchFailureException extends FSharpException {\n    constructor(arg1, arg2, arg3) {\n        super();\n        this.arg1 = arg1;\n        this.arg2 = arg2 | 0;\n        this.arg3 = arg3 | 0;\n        this.message = \"The match cases were incomplete\";\n    }\n}\nexport class Attribute {\n}\n","import { Record, Union } from \"./Types.js\";\nimport { combineHashCodes, equalArraysWith, stringHash } from \"./Util.js\";\nexport class CaseInfo {\n    constructor(declaringType, tag, name, fields) {\n        this.declaringType = declaringType;\n        this.tag = tag;\n        this.name = name;\n        this.fields = fields;\n    }\n}\nexport class TypeInfo {\n    constructor(fullname, generics, construct, parent, fields, cases, enumCases) {\n        this.fullname = fullname;\n        this.generics = generics;\n        this.construct = construct;\n        this.parent = parent;\n        this.fields = fields;\n        this.cases = cases;\n        this.enumCases = enumCases;\n    }\n    toString() {\n        return fullName(this);\n    }\n    GetHashCode() {\n        return getHashCode(this);\n    }\n    Equals(other) {\n        return equals(this, other);\n    }\n}\nexport function getGenerics(t) {\n    return t.generics != null ? t.generics : [];\n}\nexport function getHashCode(t) {\n    const fullnameHash = stringHash(t.fullname);\n    const genHashes = getGenerics(t).map(getHashCode);\n    return combineHashCodes([fullnameHash, ...genHashes]);\n}\nexport function equals(t1, t2) {\n    if (t1.fullname === \"\") { // Anonymous records\n        return t2.fullname === \"\"\n            && equalArraysWith(getRecordElements(t1), getRecordElements(t2), ([k1, v1], [k2, v2]) => k1 === k2 && equals(v1, v2));\n    }\n    else {\n        return t1.fullname === t2.fullname\n            && equalArraysWith(getGenerics(t1), getGenerics(t2), equals);\n    }\n}\nexport function class_type(fullname, generics, construct, parent) {\n    return new TypeInfo(fullname, generics, construct, parent);\n}\nexport function record_type(fullname, generics, construct, fields) {\n    return new TypeInfo(fullname, generics, construct, undefined, fields);\n}\nexport function anonRecord_type(...fields) {\n    return new TypeInfo(\"\", undefined, undefined, undefined, () => fields);\n}\nexport function union_type(fullname, generics, construct, cases) {\n    const t = new TypeInfo(fullname, generics, construct, undefined, undefined, () => {\n        const caseNames = construct.prototype.cases();\n        return cases().map((fields, i) => new CaseInfo(t, i, caseNames[i], fields));\n    });\n    return t;\n}\nexport function tuple_type(...generics) {\n    return new TypeInfo(\"System.Tuple`\" + generics.length, generics);\n}\nexport function delegate_type(...generics) {\n    return new TypeInfo(\"System.Func`\" + generics.length, generics);\n}\nexport function lambda_type(argType, returnType) {\n    return new TypeInfo(\"Microsoft.FSharp.Core.FSharpFunc`2\", [argType, returnType]);\n}\nexport function option_type(generic) {\n    return new TypeInfo(\"Microsoft.FSharp.Core.FSharpOption`1\", [generic]);\n}\nexport function list_type(generic) {\n    return new TypeInfo(\"Microsoft.FSharp.Collections.FSharpList`1\", [generic]);\n}\nexport function array_type(generic) {\n    return new TypeInfo(generic.fullname + \"[]\", [generic]);\n}\nexport function enum_type(fullname, underlyingType, enumCases) {\n    return new TypeInfo(fullname, [underlyingType], undefined, undefined, undefined, undefined, enumCases);\n}\nexport const obj_type = new TypeInfo(\"System.Object\");\nexport const unit_type = new TypeInfo(\"Microsoft.FSharp.Core.Unit\");\nexport const char_type = new TypeInfo(\"System.Char\");\nexport const string_type = new TypeInfo(\"System.String\");\nexport const bool_type = new TypeInfo(\"System.Boolean\");\nexport const int8_type = new TypeInfo(\"System.SByte\");\nexport const uint8_type = new TypeInfo(\"System.Byte\");\nexport const int16_type = new TypeInfo(\"System.Int16\");\nexport const uint16_type = new TypeInfo(\"System.UInt16\");\nexport const int32_type = new TypeInfo(\"System.Int32\");\nexport const uint32_type = new TypeInfo(\"System.UInt32\");\nexport const float32_type = new TypeInfo(\"System.Single\");\nexport const float64_type = new TypeInfo(\"System.Double\");\nexport const decimal_type = new TypeInfo(\"System.Decimal\");\nexport function name(info) {\n    if (Array.isArray(info)) {\n        return info[0];\n    }\n    else if (info instanceof CaseInfo) {\n        return info.name;\n    }\n    else {\n        const i = info.fullname.lastIndexOf(\".\");\n        return i === -1 ? info.fullname : info.fullname.substr(i + 1);\n    }\n}\nexport function fullName(t) {\n    const gen = t.generics != null && !isArray(t) ? t.generics : [];\n    if (gen.length > 0) {\n        return t.fullname + \"[\" + gen.map((x) => fullName(x)).join(\",\") + \"]\";\n    }\n    else {\n        return t.fullname;\n    }\n}\nexport function namespace(t) {\n    const i = t.fullname.lastIndexOf(\".\");\n    return i === -1 ? \"\" : t.fullname.substr(0, i);\n}\nexport function isArray(t) {\n    return t.fullname.endsWith(\"[]\");\n}\nexport function getElementType(t) {\n    var _a;\n    return isArray(t) ? (_a = t.generics) === null || _a === void 0 ? void 0 : _a[0] : undefined;\n}\nexport function isGenericType(t) {\n    return t.generics != null && t.generics.length > 0;\n}\nexport function isEnum(t) {\n    return t.enumCases != null && t.enumCases.length > 0;\n}\nexport function isSubclassOf(t1, t2) {\n    var _a, _b;\n    return (_b = (_a = t1.parent) === null || _a === void 0 ? void 0 : _a.Equals(t2)) !== null && _b !== void 0 ? _b : false;\n}\n/**\n * This doesn't replace types for fields (records) or cases (unions)\n * but it should be enough for type comparison purposes\n */\nexport function getGenericTypeDefinition(t) {\n    return t.generics == null ? t : new TypeInfo(t.fullname, t.generics.map(() => obj_type));\n}\nexport function getEnumUnderlyingType(t) {\n    var _a;\n    return (_a = t.generics) === null || _a === void 0 ? void 0 : _a[0];\n}\nexport function getEnumValues(t) {\n    if (isEnum(t) && t.enumCases != null) {\n        return t.enumCases.map((kv) => kv[1]);\n    }\n    else {\n        throw new Error(`${t.fullname} is not an enum type`);\n    }\n}\nexport function getEnumNames(t) {\n    if (isEnum(t) && t.enumCases != null) {\n        return t.enumCases.map((kv) => kv[0]);\n    }\n    else {\n        throw new Error(`${t.fullname} is not an enum type`);\n    }\n}\nfunction getEnumCase(t, v) {\n    if (t.enumCases != null) {\n        if (typeof v === \"string\") {\n            for (const kv of t.enumCases) {\n                if (kv[0] === v) {\n                    return kv;\n                }\n            }\n            throw new Error(`'${v}' was not found in ${t.fullname}`);\n        }\n        else {\n            for (const kv of t.enumCases) {\n                if (kv[1] === v) {\n                    return kv;\n                }\n            }\n            // .NET returns the number even if it doesn't match any of the cases\n            return [\"\", v];\n        }\n    }\n    else {\n        throw new Error(`${t.fullname} is not an enum type`);\n    }\n}\nexport function parseEnum(t, str) {\n    // TODO: better int parsing here, parseInt ceils floats: \"4.8\" -> 4\n    const value = parseInt(str, 10);\n    return getEnumCase(t, isNaN(value) ? str : value)[1];\n}\nexport function tryParseEnum(t, str, defValue) {\n    try {\n        defValue.contents = parseEnum(t, str);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexport function getEnumName(t, v) {\n    return getEnumCase(t, v)[0];\n}\nexport function isEnumDefined(t, v) {\n    try {\n        const kv = getEnumCase(t, v);\n        return kv[0] != null && kv[0] !== \"\";\n    }\n    catch (_a) {\n        // supress error\n    }\n    return false;\n}\n// FSharpType\nexport function getUnionCases(t) {\n    if (t.cases != null) {\n        return t.cases();\n    }\n    else {\n        throw new Error(`${t.fullname} is not an F# union type`);\n    }\n}\nexport function getRecordElements(t) {\n    if (t.fields != null) {\n        return t.fields();\n    }\n    else {\n        throw new Error(`${t.fullname} is not an F# record type`);\n    }\n}\nexport function getTupleElements(t) {\n    if (isTuple(t) && t.generics != null) {\n        return t.generics;\n    }\n    else {\n        throw new Error(`${t.fullname} is not a tuple type`);\n    }\n}\nexport function getFunctionElements(t) {\n    if (isFunction(t) && t.generics != null) {\n        const gen = t.generics;\n        return [gen[0], gen[1]];\n    }\n    else {\n        throw new Error(`${t.fullname} is not an F# function type`);\n    }\n}\nexport function isUnion(t) {\n    return t instanceof TypeInfo ? t.cases != null : t instanceof Union;\n}\nexport function isRecord(t) {\n    return t instanceof TypeInfo ? t.fields != null : t instanceof Record;\n}\nexport function isTuple(t) {\n    return t.fullname.startsWith(\"System.Tuple\") && !isArray(t);\n}\n// In .NET this is false for delegates\nexport function isFunction(t) {\n    return t.fullname === \"Microsoft.FSharp.Core.FSharpFunc`2\";\n}\n// FSharpValue\nexport function getUnionFields(v, t) {\n    const cases = getUnionCases(t);\n    const case_ = cases[v.tag];\n    if (case_ == null) {\n        throw new Error(`Cannot find case ${v.name} in union type`);\n    }\n    return [case_, v.fields];\n}\nexport function getUnionCaseFields(uci) {\n    return uci.fields == null ? [] : uci.fields;\n}\n// This is used as replacement of `FSharpValue.GetRecordFields`\n// For `FSharpTypes.GetRecordFields` see `getRecordElements`\n// Object.keys returns keys in the order they were added to the object\nexport function getRecordFields(v) {\n    return Object.keys(v).map((k) => v[k]);\n}\nexport function getRecordField(v, field) {\n    return v[field[0]];\n}\nexport function getTupleFields(v) {\n    return v;\n}\nexport function getTupleField(v, i) {\n    return v[i];\n}\nexport function makeUnion(uci, values) {\n    const expectedLength = (uci.fields || []).length;\n    if (values.length !== expectedLength) {\n        throw new Error(`Expected an array of length ${expectedLength} but got ${values.length}`);\n    }\n    return uci.declaringType.construct != null\n        ? new uci.declaringType.construct(uci.tag, ...values)\n        : {};\n}\nexport function makeRecord(t, values) {\n    const fields = getRecordElements(t);\n    if (fields.length !== values.length) {\n        throw new Error(`Expected an array of length ${fields.length} but got ${values.length}`);\n    }\n    return t.construct != null\n        ? new t.construct(...values)\n        : fields.reduce((obj, [key, _t], i) => {\n            obj[key] = values[i];\n            return obj;\n        }, {});\n}\nexport function makeTuple(values, _t) {\n    return values;\n}\nexport function makeGenericType(t, generics) {\n    return new TypeInfo(t.fullname, generics, t.construct, t.parent, t.fields, t.cases);\n}\nexport function createInstance(t, consArgs) {\n    // TODO: Check if consArgs length is same as t.construct?\n    // (Arg types can still be different)\n    if (typeof t.construct === \"function\") {\n        return new t.construct(...(consArgs !== null && consArgs !== void 0 ? consArgs : []));\n    }\n    else {\n        throw new Error(`Cannot access constructor of ${t.fullname}`);\n    }\n}\nexport function getValue(propertyInfo, v) {\n    return v[propertyInfo[0]];\n}\n// Fable.Core.Reflection\nfunction assertUnion(x) {\n    if (!(x instanceof Union)) {\n        throw new Error(`Value is not an F# union type`);\n    }\n}\nexport function getCaseTag(x) {\n    assertUnion(x);\n    return x.tag;\n}\nexport function getCaseName(x) {\n    assertUnion(x);\n    return x.cases()[x.tag];\n}\nexport function getCaseFields(x) {\n    assertUnion(x);\n    return x.fields;\n}\n","// export type decimal = Decimal;\nexport var NumberStyles;\n(function (NumberStyles) {\n    // None = 0x00000000,\n    // AllowLeadingWhite = 0x00000001,\n    // AllowTrailingWhite = 0x00000002,\n    // AllowLeadingSign = 0x00000004,\n    // AllowTrailingSign = 0x00000008,\n    // AllowParentheses = 0x00000010,\n    // AllowDecimalPoint = 0x00000020,\n    // AllowThousands = 0x00000040,\n    // AllowExponent = 0x00000080,\n    // AllowCurrencySymbol = 0x00000100,\n    NumberStyles[NumberStyles[\"AllowHexSpecifier\"] = 512] = \"AllowHexSpecifier\";\n    // Integer = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign,\n    // HexNumber = AllowLeadingWhite | AllowTrailingWhite | AllowHexSpecifier,\n    // Number = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign |\n    //          AllowTrailingSign | AllowDecimalPoint | AllowThousands,\n    // Float = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign |\n    //         AllowDecimalPoint | AllowExponent,\n    // Currency = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign | AllowTrailingSign |\n    //            AllowParentheses | AllowDecimalPoint | AllowThousands | AllowCurrencySymbol,\n    // Any = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign | AllowTrailingSign |\n    //       AllowParentheses | AllowDecimalPoint | AllowThousands | AllowCurrencySymbol | AllowExponent,\n})(NumberStyles || (NumberStyles = {}));\nfunction validResponse(regexMatch, radix) {\n    const [/*all*/ , sign, prefix, digits] = regexMatch;\n    return {\n        sign: sign || \"\",\n        prefix: prefix || \"\",\n        digits,\n        radix,\n    };\n}\nfunction getRange(unsigned, bitsize) {\n    switch (bitsize) {\n        case 8: return unsigned ? [0, 255] : [-128, 127];\n        case 16: return unsigned ? [0, 65535] : [-32768, 32767];\n        case 32: return unsigned ? [0, 4294967295] : [-2147483648, 2147483647];\n        default: throw new Error(\"Invalid bit size.\");\n    }\n}\nfunction getInvalidDigits(radix) {\n    switch (radix) {\n        case 2: return /[^0-1]/;\n        case 8: return /[^0-7]/;\n        case 10: return /[^0-9]/;\n        case 16: return /[^0-9a-fA-F]/;\n        default:\n            throw new Error(\"Invalid Base.\");\n    }\n}\nfunction getRadix(prefix, style) {\n    if (style & NumberStyles.AllowHexSpecifier) {\n        return 16;\n    }\n    else {\n        switch (prefix) {\n            case \"0b\":\n            case \"0B\": return 2;\n            case \"0o\":\n            case \"0O\": return 8;\n            case \"0x\":\n            case \"0X\": return 16;\n            default: return 10;\n        }\n    }\n}\nexport function isValid(str, style, radix) {\n    const integerRegex = /^\\s*([\\+\\-])?(0[xXoObB])?([0-9a-fA-F]+)\\s*$/;\n    const res = integerRegex.exec(str.replace(/_/g, \"\"));\n    if (res != null) {\n        const [/*all*/ , /*sign*/ , prefix, digits] = res;\n        radix = radix || getRadix(prefix, style);\n        const invalidDigits = getInvalidDigits(radix);\n        if (!invalidDigits.test(digits)) {\n            return validResponse(res, radix);\n        }\n    }\n    return null;\n}\nexport function parse(str, style, unsigned, bitsize, radix) {\n    const res = isValid(str, style, radix);\n    if (res != null) {\n        let v = Number.parseInt(res.sign + res.digits, res.radix);\n        if (!Number.isNaN(v)) {\n            const [umin, umax] = getRange(true, bitsize);\n            if (!unsigned && res.radix !== 10 && v >= umin && v <= umax) {\n                v = v << (32 - bitsize) >> (32 - bitsize);\n            }\n            const [min, max] = getRange(unsigned, bitsize);\n            if (v >= min && v <= max) {\n                return v;\n            }\n        }\n    }\n    throw new Error(\"Input string was not in a correct format.\");\n}\nexport function tryParse(str, style, unsigned, bitsize, defValue) {\n    try {\n        defValue.contents = parse(str, style, unsigned, bitsize);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexport function op_UnaryNegation_Int8(x) {\n    return x === -128 ? x : -x;\n}\nexport function op_UnaryNegation_Int16(x) {\n    return x === -32768 ? x : -x;\n}\nexport function op_UnaryNegation_Int32(x) {\n    return x === -2147483648 ? x : -x;\n}\n","export const symbol = Symbol(\"numeric\");\nexport function isNumeric(x) {\n    return typeof x === \"number\" || (x === null || x === void 0 ? void 0 : x[symbol]);\n}\nexport function compare(x, y) {\n    if (typeof x === \"number\") {\n        return x < y ? -1 : (x > y ? 1 : 0);\n    }\n    else {\n        return x.CompareTo(y);\n    }\n}\nexport function multiply(x, y) {\n    if (typeof x === \"number\") {\n        return x * y;\n    }\n    else {\n        return x[symbol]().multiply(y);\n    }\n}\nexport function toFixed(x, dp) {\n    if (typeof x === \"number\") {\n        return x.toFixed(dp);\n    }\n    else {\n        return x[symbol]().toFixed(dp);\n    }\n}\nexport function toPrecision(x, sd) {\n    if (typeof x === \"number\") {\n        return x.toPrecision(sd);\n    }\n    else {\n        return x[symbol]().toPrecision(sd);\n    }\n}\nexport function toExponential(x, dp) {\n    if (typeof x === \"number\") {\n        return x.toExponential(dp);\n    }\n    else {\n        return x[symbol]().toExponential(dp);\n    }\n}\nexport function toHex(x) {\n    if (typeof x === \"number\") {\n        return (Number(x) >>> 0).toString(16);\n    }\n    else {\n        return x[symbol]().toHex();\n    }\n}\n","// Adapted from: https://github.com/dcodeIO/long.js/blob/master/src/long.js\n// Apache License 2.0: https://github.com/dcodeIO/long.js/blob/master/LICENSE\n/* tslint:disable */\nimport { symbol } from \"../Numeric.js\";\n/**\n * wasm optimizations, to do native i64 multiplication and divide\n */\nvar wasm = null;\ntry {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\n    ])), {}).exports;\n}\ncatch (e) {\n    // no wasm support :(\n}\n/**\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n *  See the from* functions below for more convenient ways of constructing Longs.\n * @exports Long\n * @class A Long class for representing a 64 bit two's-complement integer value.\n * @param {number} low The low (signed) 32 bits of the long\n * @param {number} high The high (signed) 32 bits of the long\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @constructor\n */\nexport function Long(low, high, unsigned) {\n    /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     */\n    this.low = low | 0;\n    /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     */\n    this.high = high | 0;\n    /**\n     * Whether unsigned or not.\n     * @type {boolean}\n     */\n    this.unsigned = !!unsigned;\n}\nLong.prototype.GetHashCode = function () {\n    let h1 = this.unsigned ? 1 : 0;\n    h1 = ((h1 << 5) + h1) ^ this.high;\n    h1 = ((h1 << 5) + h1) ^ this.low;\n    return h1;\n};\nLong.prototype.Equals = function (x) { return equals(this, x); };\nLong.prototype.CompareTo = function (x) { return compare(this, x); };\nLong.prototype.toString = function (radix) { return toString(this, radix); };\nLong.prototype.toJSON = function () { return toString(this); };\nLong.prototype[symbol] = function () {\n    const x = this;\n    return {\n        multiply: y => multiply(x, y),\n        toPrecision: sd => String(x) + (0).toPrecision(sd).substr(1),\n        toExponential: dp => String(x) + (0).toExponential(dp).substr(1),\n        toFixed: dp => String(x) + (0).toFixed(dp).substr(1),\n        toHex: () => toString(x.unsigned ? x : fromBytes(toBytes(x), true), 16),\n    };\n};\n// The internal representation of a long is the two given signed, 32-bit values.\n// We use 32-bit pieces because these are the size of integers on which\n// Javascript performs bit-operations.  For operations like addition and\n// multiplication, we split each number into 16 bit pieces, which can easily be\n// multiplied within Javascript's floating-point representation without overflow\n// or change in sign.\n//\n// In the algorithms below, we frequently reduce the negative case to the\n// positive case by negating the input(s) and then post-processing the result.\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n// a positive number, it overflows back into a negative).  Not handling this\n// case would often result in infinite recursion.\n//\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n// methods on which they depend.\n/**\n * An indicator used to reliably determine if an object is a Long or not.\n * @type {boolean}\n * @const\n * @private\n */\nLong.prototype.__isLong__;\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\n/**\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n * @inner\n */\nexport function isLong(obj) {\n    return (obj && obj[\"__isLong__\"]) === true;\n}\n/**\n * Tests if the specified object is a Long.\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n */\n// Long.isLong = isLong;\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @inner\n */\nvar INT_CACHE = {};\n/**\n * A cache of the Long representations of small unsigned integer values.\n * @type {!Object}\n * @inner\n */\nvar UINT_CACHE = {};\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nexport function fromInt(value, unsigned) {\n    var obj, cachedObj, cache;\n    if (unsigned) {\n        value >>>= 0;\n        if (cache = (0 <= value && value < 256)) {\n            cachedObj = UINT_CACHE[value];\n            if (cachedObj)\n                return cachedObj;\n        }\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n        if (cache)\n            UINT_CACHE[value] = obj;\n        return obj;\n    }\n    else {\n        value |= 0;\n        if (cache = (-128 <= value && value < 128)) {\n            cachedObj = INT_CACHE[value];\n            if (cachedObj)\n                return cachedObj;\n        }\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\n        if (cache)\n            INT_CACHE[value] = obj;\n        return obj;\n    }\n}\n/**\n * Returns a Long representing the given 32 bit integer value.\n * @function\n * @param {number} value The 32 bit integer in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\n// Long.fromInt = fromInt;\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nexport function fromNumber(value, unsigned) {\n    if (isNaN(value))\n        return unsigned ? UZERO : ZERO;\n    if (unsigned) {\n        if (value < 0)\n            return UZERO;\n        if (value >= TWO_PWR_64_DBL)\n            return MAX_UNSIGNED_VALUE;\n    }\n    else {\n        if (value <= -TWO_PWR_63_DBL)\n            return MIN_VALUE;\n        if (value + 1 >= TWO_PWR_63_DBL)\n            return MAX_VALUE;\n    }\n    if (value < 0)\n        return negate(fromNumber(-value, unsigned));\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\n}\n/**\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n * @function\n * @param {number} value The number in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\n// Long.fromNumber = fromNumber;\n/**\n * @param {number} lowBits\n * @param {number} highBits\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nexport function fromBits(lowBits, highBits, unsigned) {\n    return new Long(lowBits, highBits, unsigned);\n}\n/**\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n *  assumed to use 32 bits.\n * @function\n * @param {number} lowBits The low 32 bits\n * @param {number} highBits The high 32 bits\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\n// Long.fromBits = fromBits;\n/**\n * @function\n * @param {number} base\n * @param {number} exponent\n * @returns {number}\n * @inner\n */\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n/**\n * @param {string} str\n * @param {(boolean|number)=} unsigned\n * @param {number=} radix\n * @returns {!Long}\n * @inner\n */\nexport function fromString(str, unsigned, radix) {\n    if (str.length === 0)\n        throw Error('empty string');\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n        return ZERO;\n    if (typeof unsigned === 'number') {\n        // For goog.math.long compatibility\n        radix = unsigned,\n            unsigned = false;\n    }\n    else {\n        unsigned = !!unsigned;\n    }\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix)\n        throw RangeError('radix');\n    var p = str.indexOf('-');\n    if (p > 0)\n        throw Error('interior hyphen');\n    else if (p === 0) {\n        return negate(fromString(str.substring(1), unsigned, radix));\n    }\n    // Do several (8) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\n    var result = ZERO;\n    for (var i = 0; i < str.length; i += 8) {\n        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n        if (size < 8) {\n            var power = fromNumber(pow_dbl(radix, size));\n            result = add(multiply(result, power), fromNumber(value));\n        }\n        else {\n            result = multiply(result, radixToPower);\n            result = add(result, fromNumber(value));\n        }\n    }\n    result.unsigned = unsigned;\n    return result;\n}\n/**\n * Returns a Long representation of the given string, written using the specified radix.\n * @function\n * @param {string} str The textual representation of the Long\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n * @returns {!Long} The corresponding Long value\n */\n// Long.fromString = fromString;\n/**\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nexport function fromValue(val, unsigned) {\n    if (typeof val === 'number')\n        return fromNumber(val, unsigned);\n    if (typeof val === 'string')\n        return fromString(val, unsigned);\n    // Throws for non-objects, converts non-instanceof Long:\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n}\n/**\n * Converts the specified value to a Long using the appropriate from* function for its type.\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long}\n */\n// Long.fromValue = fromValue;\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n// no runtime penalty for these.\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_16_DBL = 1 << 16;\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_24_DBL = 1 << 24;\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n/**\n * @type {!Long}\n * @const\n * @inner\n */\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n/**\n * @type {!Long}\n * @inner\n */\nexport var ZERO = fromInt(0);\n/**\n * Signed zero.\n * @type {!Long}\n */\n// Long.ZERO = ZERO;\n/**\n * @type {!Long}\n * @inner\n */\nexport var UZERO = fromInt(0, true);\n/**\n * Unsigned zero.\n * @type {!Long}\n */\n// Long.UZERO = UZERO;\n/**\n * @type {!Long}\n * @inner\n */\nexport var ONE = fromInt(1);\n/**\n * Signed one.\n * @type {!Long}\n */\n// Long.ONE = ONE;\n/**\n * @type {!Long}\n * @inner\n */\nexport var UONE = fromInt(1, true);\n/**\n * Unsigned one.\n * @type {!Long}\n */\n// Long.UONE = UONE;\n/**\n * @type {!Long}\n * @inner\n */\nexport var NEG_ONE = fromInt(-1);\n/**\n * Signed negative one.\n * @type {!Long}\n */\n// Long.NEG_ONE = NEG_ONE;\n/**\n * @type {!Long}\n * @inner\n */\nexport var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\n/**\n * Maximum signed value.\n * @type {!Long}\n */\n// Long.MAX_VALUE = MAX_VALUE;\n/**\n * @type {!Long}\n * @inner\n */\nexport var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\n/**\n * Maximum unsigned value.\n * @type {!Long}\n */\n// Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n/**\n * @type {!Long}\n * @inner\n */\nexport var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n/**\n * Minimum signed value.\n * @type {!Long}\n */\n// Long.MIN_VALUE = MIN_VALUE;\n/**\n * @alias Long.prototype\n * @inner\n */\n// var LongPrototype = Long.prototype;\n/**\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n * @this {!Long}\n * @returns {number}\n */\nexport function toInt($this) {\n    return $this.unsigned ? $this.low >>> 0 : $this.low;\n}\n;\n/**\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n * @this {!Long}\n * @returns {number}\n */\nexport function toNumber($this) {\n    if ($this.unsigned)\n        return (($this.high >>> 0) * TWO_PWR_32_DBL) + ($this.low >>> 0);\n    return $this.high * TWO_PWR_32_DBL + ($this.low >>> 0);\n}\n;\n/**\n * Converts the Long to a string written in the specified radix.\n * @this {!Long}\n * @param {number=} radix Radix (2-36), defaults to 10\n * @returns {string}\n * @override\n * @throws {RangeError} If `radix` is out of range\n */\nexport function toString($this, radix) {\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix)\n        throw RangeError('radix');\n    if (isZero($this))\n        return '0';\n    if (isNegative($this)) { // Unsigned Longs are never negative\n        if (equals($this, MIN_VALUE)) {\n            // We need to change the Long value before it can be negated, so we remove\n            // the bottom-most digit in this base and then recurse to do the rest.\n            var radixLong = fromNumber(radix), div = divide($this, radixLong), rem1 = subtract(multiply(div, radixLong), $this);\n            return toString(div, radix) + toInt(rem1).toString(radix);\n        }\n        else\n            return '-' + toString(negate($this), radix);\n    }\n    // Do several (6) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = fromNumber(pow_dbl(radix, 6), $this.unsigned), rem = $this;\n    var result = '';\n    while (true) {\n        var remDiv = divide(rem, radixToPower), intval = toInt(subtract(rem, multiply(remDiv, radixToPower))) >>> 0, digits = intval.toString(radix);\n        rem = remDiv;\n        if (isZero(rem))\n            return digits + result;\n        else {\n            while (digits.length < 6)\n                digits = '0' + digits;\n            result = '' + digits + result;\n        }\n    }\n}\n;\n/**\n * Gets the high 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed high bits\n */\nexport function getHighBits($this) {\n    return $this.high;\n}\n;\n/**\n * Gets the high 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned high bits\n */\nexport function getHighBitsUnsigned($this) {\n    return $this.high >>> 0;\n}\n;\n/**\n * Gets the low 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed low bits\n */\nexport function getLowBits($this) {\n    return $this.low;\n}\n;\n/**\n * Gets the low 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned low bits\n */\nexport function getLowBitsUnsigned($this) {\n    return $this.low >>> 0;\n}\n;\n/**\n * Gets the number of bits needed to represent the absolute value of this Long.\n * @this {!Long}\n * @returns {number}\n */\nexport function getNumBitsAbs($this) {\n    if (isNegative($this)) // Unsigned Longs are never negative\n        return equals($this, MIN_VALUE) ? 64 : getNumBitsAbs(negate($this));\n    var val = $this.high != 0 ? $this.high : $this.low;\n    for (var bit = 31; bit > 0; bit--)\n        if ((val & (1 << bit)) != 0)\n            break;\n    return $this.high != 0 ? bit + 33 : bit + 1;\n}\n;\n/**\n * Tests if this Long's value equals zero.\n * @this {!Long}\n * @returns {boolean}\n */\nexport function isZero($this) {\n    return $this.high === 0 && $this.low === 0;\n}\n;\n/**\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n * @returns {boolean}\n */\n// LongPrototype.eqz = LongPrototype.isZero;\n/**\n * Tests if this Long's value is negative.\n * @this {!Long}\n * @returns {boolean}\n */\nexport function isNegative($this) {\n    return !$this.unsigned && $this.high < 0;\n}\n;\n/**\n * Tests if this Long's value is positive.\n * @this {!Long}\n * @returns {boolean}\n */\nexport function isPositive($this) {\n    return $this.unsigned || $this.high >= 0;\n}\n;\n/**\n * Tests if this Long's value is odd.\n * @this {!Long}\n * @returns {boolean}\n */\nexport function isOdd($this) {\n    return ($this.low & 1) === 1;\n}\n;\n/**\n * Tests if this Long's value is even.\n * @this {!Long}\n * @returns {boolean}\n */\nexport function isEven($this) {\n    return ($this.low & 1) === 0;\n}\n;\n/**\n * Tests if this Long's value equals the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function equals($this, other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    if ($this.unsigned !== other.unsigned && ($this.high >>> 31) === 1 && (other.high >>> 31) === 1)\n        return false;\n    return $this.high === other.high && $this.low === other.low;\n}\n;\n/**\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.eq = LongPrototype.equals;\n/**\n * Tests if this Long's value differs from the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function notEquals($this, other) {\n    return !equals($this, /* validates */ other);\n}\n;\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.neq = LongPrototype.notEquals;\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.ne = LongPrototype.notEquals;\n/**\n * Tests if this Long's value is less than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function lessThan($this, other) {\n    return compare($this, /* validates */ other) < 0;\n}\n;\n/**\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.lt = LongPrototype.lessThan;\n/**\n * Tests if this Long's value is less than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function lessThanOrEqual($this, other) {\n    return compare($this, /* validates */ other) <= 0;\n}\n;\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.lte = LongPrototype.lessThanOrEqual;\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.le = LongPrototype.lessThanOrEqual;\n/**\n * Tests if this Long's value is greater than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function greaterThan($this, other) {\n    return compare($this, /* validates */ other) > 0;\n}\n;\n/**\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.gt = LongPrototype.greaterThan;\n/**\n * Tests if this Long's value is greater than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function greaterThanOrEqual($this, other) {\n    return compare($this, /* validates */ other) >= 0;\n}\n;\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n/**\n * Compares this Long's value with the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nexport function compare($this, other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    if (equals($this, other))\n        return 0;\n    var thisNeg = isNegative($this), otherNeg = isNegative(other);\n    if (thisNeg && !otherNeg)\n        return -1;\n    if (!thisNeg && otherNeg)\n        return 1;\n    // At this point the sign bits are the same\n    if (!$this.unsigned)\n        return isNegative(subtract($this, other)) ? -1 : 1;\n    // Both are positive if at least one is unsigned\n    return (other.high >>> 0) > ($this.high >>> 0) || (other.high === $this.high && (other.low >>> 0) > ($this.low >>> 0)) ? -1 : 1;\n}\n;\n/**\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\n// LongPrototype.comp = LongPrototype.compare;\n/**\n * Negates this Long's value.\n * @this {!Long}\n * @returns {!Long} Negated Long\n */\nexport function negate($this) {\n    if (!$this.unsigned && equals($this, MIN_VALUE))\n        return MIN_VALUE;\n    return add(not($this), ONE);\n}\n;\n/**\n * Negates this Long's value. This is an alias of {@link Long#negate}.\n * @function\n * @returns {!Long} Negated Long\n */\n// LongPrototype.neg = LongPrototype.negate;\n/**\n * Returns the sum of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} addend Addend\n * @returns {!Long} Sum\n */\nexport function add($this, addend) {\n    if (!isLong(addend))\n        addend = fromValue(addend);\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n    var a48 = $this.high >>> 16;\n    var a32 = $this.high & 0xFFFF;\n    var a16 = $this.low >>> 16;\n    var a00 = $this.low & 0xFFFF;\n    var b48 = addend.high >>> 16;\n    var b32 = addend.high & 0xFFFF;\n    var b16 = addend.low >>> 16;\n    var b00 = addend.low & 0xFFFF;\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 + b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 + b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 + b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 + b48;\n    c48 &= 0xFFFF;\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, $this.unsigned);\n}\n;\n/**\n * Returns the difference of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nexport function subtract($this, subtrahend) {\n    if (!isLong(subtrahend))\n        subtrahend = fromValue(subtrahend);\n    return add($this, negate(subtrahend));\n}\n;\n/**\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n * @function\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\n// LongPrototype.sub = LongPrototype.subtract;\n/**\n * Returns the product of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nexport function multiply($this, multiplier) {\n    if (isZero($this))\n        return $this.unsigned ? UZERO : ZERO;\n    if (!isLong(multiplier))\n        multiplier = fromValue(multiplier);\n    // use wasm support if present\n    if (wasm) {\n        var low = wasm.mul($this.low, $this.high, multiplier.low, multiplier.high);\n        return fromBits(low, wasm.get_high(), $this.unsigned);\n    }\n    if (isZero(multiplier))\n        return $this.unsigned ? UZERO : ZERO;\n    if (equals($this, MIN_VALUE))\n        return isOdd(multiplier) ? MIN_VALUE : ZERO;\n    if (equals(multiplier, MIN_VALUE))\n        return isOdd($this) ? MIN_VALUE : ZERO;\n    if (isNegative($this)) {\n        if (isNegative(multiplier))\n            return multiply(negate($this), negate(multiplier));\n        else\n            return negate(multiply(negate($this), multiplier));\n    }\n    else if (isNegative(multiplier))\n        return negate(multiply($this, negate(multiplier)));\n    // If both longs are small, use float multiplication\n    if (lessThan($this, TWO_PWR_24) && lessThan(multiplier, TWO_PWR_24))\n        return fromNumber(toNumber($this) * toNumber(multiplier), $this.unsigned);\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n    // We can skip products that would overflow.\n    var a48 = $this.high >>> 16;\n    var a32 = $this.high & 0xFFFF;\n    var a16 = $this.low >>> 16;\n    var a00 = $this.low & 0xFFFF;\n    var b48 = multiplier.high >>> 16;\n    var b32 = multiplier.high & 0xFFFF;\n    var b16 = multiplier.low >>> 16;\n    var b00 = multiplier.low & 0xFFFF;\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 * b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 * b00;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c16 += a00 * b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 * b00;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a16 * b16;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a00 * b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n    c48 &= 0xFFFF;\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, $this.unsigned);\n}\n;\n/**\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n * @function\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\n// LongPrototype.mul = LongPrototype.multiply;\n/**\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\n *  unsigned if this Long is unsigned.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nexport function divide($this, divisor) {\n    if (!isLong(divisor))\n        divisor = fromValue(divisor);\n    if (isZero(divisor))\n        throw Error('division by zero');\n    // use wasm support if present\n    if (wasm) {\n        // guard against signed division overflow: the largest\n        // negative number / -1 would be 1 larger than the largest\n        // positive number, due to two's complement.\n        if (!$this.unsigned &&\n            $this.high === -0x80000000 &&\n            divisor.low === -1 && divisor.high === -1) {\n            // be consistent with non-wasm code path\n            return $this;\n        }\n        var low = ($this.unsigned ? wasm.div_u : wasm.div_s)($this.low, $this.high, divisor.low, divisor.high);\n        return fromBits(low, wasm.get_high(), $this.unsigned);\n    }\n    if (isZero($this))\n        return $this.unsigned ? UZERO : ZERO;\n    var approx, rem, res;\n    if (!$this.unsigned) {\n        // This section is only relevant for signed longs and is derived from the\n        // closure library as a whole.\n        if (equals($this, MIN_VALUE)) {\n            if (equals(divisor, ONE) || equals(divisor, NEG_ONE))\n                return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE\n            else if (equals(divisor, MIN_VALUE))\n                return ONE;\n            else {\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n                var halfThis = shiftRight($this, 1);\n                approx = shiftLeft(divide(halfThis, divisor), 1);\n                if (equals(approx, ZERO)) {\n                    return isNegative(divisor) ? ONE : NEG_ONE;\n                }\n                else {\n                    rem = subtract($this, multiply(divisor, approx));\n                    res = add(approx, divide(rem, divisor));\n                    return res;\n                }\n            }\n        }\n        else if (equals(divisor, MIN_VALUE))\n            return $this.unsigned ? UZERO : ZERO;\n        if (isNegative($this)) {\n            if (isNegative(divisor))\n                return divide(negate($this), negate(divisor));\n            return negate(divide(negate($this), divisor));\n        }\n        else if (isNegative(divisor))\n            return negate(divide($this, negate(divisor)));\n        res = ZERO;\n    }\n    else {\n        // The algorithm below has not been made for unsigned longs. It's therefore\n        // required to take special care of the MSB prior to running it.\n        if (!divisor.unsigned)\n            divisor = toUnsigned(divisor);\n        if (greaterThan(divisor, $this))\n            return UZERO;\n        if (greaterThan(divisor, shiftRightUnsigned($this, 1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\n            return UONE;\n        res = UZERO;\n    }\n    // Repeat the following until the remainder is less than other:  find a\n    // floating-point that approximates remainder / other *from below*, add this\n    // into the result, and subtract it from the remainder.  It is critical that\n    // the approximate value is less than or equal to the real value so that the\n    // remainder never becomes negative.\n    rem = $this;\n    while (greaterThanOrEqual(rem, divisor)) {\n        // Approximate the result of division. This may be a little greater or\n        // smaller than the actual value.\n        approx = Math.max(1, Math.floor(toNumber(rem) / toNumber(divisor)));\n        // We will tweak the approximate result by changing it in the 48-th digit or\n        // the smallest non-fractional digit, whichever is larger.\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48), \n        // Decrease the approximation until it is smaller than the remainder.  Note\n        // that if it is too large, the product overflows and is negative.\n        approxRes = fromNumber(approx), approxRem = multiply(approxRes, divisor);\n        while (isNegative(approxRem) || greaterThan(approxRem, rem)) {\n            approx -= delta;\n            approxRes = fromNumber(approx, $this.unsigned);\n            approxRem = multiply(approxRes, divisor);\n        }\n        // We know the answer can't be zero... and actually, zero would cause\n        // infinite recursion since we would make no progress.\n        if (isZero(approxRes))\n            approxRes = ONE;\n        res = add(res, approxRes);\n        rem = subtract(rem, approxRem);\n    }\n    return res;\n}\n;\n/**\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\n// LongPrototype.div = LongPrototype.divide;\n/**\n * Returns this Long modulo the specified.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nexport function modulo($this, divisor) {\n    if (!isLong(divisor))\n        divisor = fromValue(divisor);\n    // use wasm support if present\n    if (wasm) {\n        var low = ($this.unsigned ? wasm.rem_u : wasm.rem_s)($this.low, $this.high, divisor.low, divisor.high);\n        return fromBits(low, wasm.get_high(), $this.unsigned);\n    }\n    return subtract($this, multiply(divide($this, divisor), divisor));\n}\n;\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\n// LongPrototype.mod = LongPrototype.modulo;\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\n// LongPrototype.rem = LongPrototype.modulo;\n/**\n * Returns the bitwise NOT of this Long.\n * @this {!Long}\n * @returns {!Long}\n */\nexport function not($this) {\n    return fromBits(~$this.low, ~$this.high, $this.unsigned);\n}\n;\n/**\n * Returns the bitwise AND of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nexport function and($this, other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits($this.low & other.low, $this.high & other.high, $this.unsigned);\n}\n;\n/**\n * Returns the bitwise OR of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nexport function or($this, other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits($this.low | other.low, $this.high | other.high, $this.unsigned);\n}\n;\n/**\n * Returns the bitwise XOR of this Long and the given one.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nexport function xor($this, other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits($this.low ^ other.low, $this.high ^ other.high, $this.unsigned);\n}\n;\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nexport function shiftLeft($this, numBits) {\n    if (isLong(numBits))\n        numBits = toInt(numBits);\n    if ((numBits &= 63) === 0)\n        return $this;\n    else if (numBits < 32)\n        return fromBits($this.low << numBits, ($this.high << numBits) | ($this.low >>> (32 - numBits)), $this.unsigned);\n    else\n        return fromBits(0, $this.low << (numBits - 32), $this.unsigned);\n}\n;\n/**\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n// LongPrototype.shl = LongPrototype.shiftLeft;\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nexport function shiftRight($this, numBits) {\n    if (isLong(numBits))\n        numBits = toInt(numBits);\n    if ((numBits &= 63) === 0)\n        return $this;\n    else if (numBits < 32)\n        return fromBits(($this.low >>> numBits) | ($this.high << (32 - numBits)), $this.high >> numBits, $this.unsigned);\n    else\n        return fromBits($this.high >> (numBits - 32), $this.high >= 0 ? 0 : -1, $this.unsigned);\n}\n;\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n// LongPrototype.shr = LongPrototype.shiftRight;\n/**\n * Returns this Long with bits logically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nexport function shiftRightUnsigned($this, numBits) {\n    if (isLong(numBits))\n        numBits = toInt(numBits);\n    numBits &= 63;\n    if (numBits === 0)\n        return $this;\n    else {\n        var high = $this.high;\n        if (numBits < 32) {\n            var low = $this.low;\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, $this.unsigned);\n        }\n        else if (numBits === 32)\n            return fromBits(high, 0, $this.unsigned);\n        else\n            return fromBits(high >>> (numBits - 32), 0, $this.unsigned);\n    }\n}\n;\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n// LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n// LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n/**\n * Returns this Long with bits rotated to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nexport const rotateLeft = function rotateLeft(numBits) {\n    var b;\n    if (isLong(numBits))\n        numBits = numBits.toInt();\n    if ((numBits &= 63) === 0)\n        return this;\n    if (numBits === 32)\n        return fromBits(this.high, this.low, this.unsigned);\n    if (numBits < 32) {\n        b = (32 - numBits);\n        return fromBits(((this.low << numBits) | (this.high >>> b)), ((this.high << numBits) | (this.low >>> b)), this.unsigned);\n    }\n    numBits -= 32;\n    b = (32 - numBits);\n    return fromBits(((this.high << numBits) | (this.low >>> b)), ((this.low << numBits) | (this.high >>> b)), this.unsigned);\n};\n/**\n * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\n// LongPrototype.rotl = LongPrototype.rotateLeft;\n/**\n * Returns this Long with bits rotated to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nexport const rotateRight = function rotateRight(numBits) {\n    var b;\n    if (isLong(numBits))\n        numBits = numBits.toInt();\n    if ((numBits &= 63) === 0)\n        return this;\n    if (numBits === 32)\n        return fromBits(this.high, this.low, this.unsigned);\n    if (numBits < 32) {\n        b = (32 - numBits);\n        return fromBits(((this.high << b) | (this.low >>> numBits)), ((this.low << b) | (this.high >>> numBits)), this.unsigned);\n    }\n    numBits -= 32;\n    b = (32 - numBits);\n    return fromBits(((this.low << b) | (this.high >>> numBits)), ((this.high << b) | (this.low >>> numBits)), this.unsigned);\n};\n/**\n * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\n// LongPrototype.rotr = LongPrototype.rotateRight;\n/**\n * Converts this Long to signed.\n * @this {!Long}\n * @returns {!Long} Signed long\n */\nexport function toSigned($this) {\n    if (!$this.unsigned)\n        return $this;\n    return fromBits($this.low, $this.high, false);\n}\n;\n/**\n * Converts this Long to unsigned.\n * @this {!Long}\n * @returns {!Long} Unsigned long\n */\nexport function toUnsigned($this) {\n    if ($this.unsigned)\n        return $this;\n    return fromBits($this.low, $this.high, true);\n}\n;\n/**\n * Converts this Long to its byte representation.\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @this {!Long}\n * @returns {!Array.<number>} Byte representation\n */\nexport function toBytes($this, le) {\n    return le ? toBytesLE($this) : toBytesBE($this);\n}\n;\n/**\n * Converts this Long to its little endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Little endian byte representation\n */\nexport function toBytesLE($this) {\n    var hi = $this.high, lo = $this.low;\n    return [\n        lo & 0xff,\n        lo >>> 8 & 0xff,\n        lo >>> 16 & 0xff,\n        lo >>> 24,\n        hi & 0xff,\n        hi >>> 8 & 0xff,\n        hi >>> 16 & 0xff,\n        hi >>> 24\n    ];\n}\n;\n/**\n * Converts this Long to its big endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Big endian byte representation\n */\nexport function toBytesBE($this) {\n    var hi = $this.high, lo = $this.low;\n    return [\n        hi >>> 24,\n        hi >>> 16 & 0xff,\n        hi >>> 8 & 0xff,\n        hi & 0xff,\n        lo >>> 24,\n        lo >>> 16 & 0xff,\n        lo >>> 8 & 0xff,\n        lo & 0xff\n    ];\n}\n;\n/**\n * Creates a Long from its byte representation.\n * @param {!Array.<number>} bytes Byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @returns {Long} The corresponding Long value\n */\nexport function fromBytes(bytes, unsigned, le) {\n    return le ? fromBytesLE(bytes, unsigned) : fromBytesBE(bytes, unsigned);\n}\n;\n/**\n * Creates a Long from its little endian byte representation.\n * @param {!Array.<number>} bytes Little endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nexport function fromBytesLE(bytes, unsigned) {\n    return new Long(bytes[0] |\n        bytes[1] << 8 |\n        bytes[2] << 16 |\n        bytes[3] << 24, bytes[4] |\n        bytes[5] << 8 |\n        bytes[6] << 16 |\n        bytes[7] << 24, unsigned);\n}\n;\n/**\n * Creates a Long from its big endian byte representation.\n * @param {!Array.<number>} bytes Big endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nexport function fromBytesBE(bytes, unsigned) {\n    return new Long(bytes[4] << 24 |\n        bytes[5] << 16 |\n        bytes[6] << 8 |\n        bytes[7], bytes[0] << 24 |\n        bytes[1] << 16 |\n        bytes[2] << 8 |\n        bytes[3], unsigned);\n}\n;\n","import { isValid } from \"./Int32.js\";\nimport * as LongLib from \"./lib/long.js\";\nexport default LongLib.Long;\nexport const get_Zero = LongLib.ZERO;\nexport const get_One = LongLib.ONE;\nexport const op_Addition = LongLib.add;\nexport const op_Subtraction = LongLib.subtract;\nexport const op_Multiply = LongLib.multiply;\nexport const op_Division = LongLib.divide;\nexport const op_Modulus = LongLib.modulo;\nexport const op_UnaryNegation = LongLib.negate;\nexport const op_LeftShift = LongLib.shiftLeft;\nexport const op_RightShift = LongLib.shiftRight;\nexport const op_RightShiftUnsigned = LongLib.shiftRightUnsigned;\nexport const op_BitwiseAnd = LongLib.and;\nexport const op_BitwiseOr = LongLib.or;\nexport const op_ExclusiveOr = LongLib.xor;\nexport const op_LogicalNot = LongLib.not;\nexport const op_LessThan = LongLib.lessThan;\nexport const op_LessThanOrEqual = LongLib.lessThanOrEqual;\nexport const op_GreaterThan = LongLib.greaterThan;\nexport const op_GreaterThanOrEqual = LongLib.greaterThanOrEqual;\nexport const op_Equality = LongLib.equals;\nexport const op_Inequality = LongLib.notEquals;\nexport const equals = LongLib.equals;\nexport const compare = LongLib.compare;\nexport const fromInt = LongLib.fromInt;\nexport const fromBits = LongLib.fromBits;\nexport const fromBytes = LongLib.fromBytes;\nexport const fromNumber = LongLib.fromNumber;\nexport const fromString = LongLib.fromString;\nexport const fromValue = LongLib.fromValue;\nexport const toInt = LongLib.toInt;\nexport const toBytes = LongLib.toBytes;\nexport const toNumber = LongLib.toNumber;\nexport const toString = LongLib.toString;\nexport const getLowBits = LongLib.getLowBits;\nexport const getHighBits = LongLib.getHighBits;\nexport const getLowBitsUnsigned = LongLib.getLowBitsUnsigned;\nexport const getHighBitsUnsigned = LongLib.getHighBitsUnsigned;\nfunction getMaxValue(unsigned, radix, isNegative) {\n    switch (radix) {\n        case 2: return unsigned ?\n            \"1111111111111111111111111111111111111111111111111111111111111111\" :\n            (isNegative ? \"1000000000000000000000000000000000000000000000000000000000000000\"\n                : \"111111111111111111111111111111111111111111111111111111111111111\");\n        case 8: return unsigned ?\n            \"1777777777777777777777\" :\n            (isNegative ? \"1000000000000000000000\" : \"777777777777777777777\");\n        case 10: return unsigned ?\n            \"18446744073709551615\" :\n            (isNegative ? \"9223372036854775808\" : \"9223372036854775807\");\n        case 16: return unsigned ?\n            \"FFFFFFFFFFFFFFFF\" :\n            (isNegative ? \"8000000000000000\" : \"7FFFFFFFFFFFFFFF\");\n        default: throw new Error(\"Invalid radix.\");\n    }\n}\nexport function abs(x) {\n    if (!x.unsigned && LongLib.isNegative(x)) {\n        return op_UnaryNegation(x);\n    }\n    else {\n        return x;\n    }\n}\nexport function fromInteger(value, unsigned, kind) {\n    let x = value;\n    let xh = 0;\n    switch (kind) {\n        case 0:\n            x = value << 24 >> 24;\n            xh = x;\n            break;\n        case 4:\n            x = value << 24 >>> 24;\n            break;\n        case 1:\n            x = value << 16 >> 16;\n            xh = x;\n            break;\n        case 5:\n            x = value << 16 >>> 16;\n            break;\n        case 2:\n            x = value >> 0;\n            xh = x;\n            break;\n        case 6:\n            x = value >>> 0;\n            break;\n    }\n    return LongLib.fromBits(x, xh >> 31, unsigned);\n}\nexport function parse(str, style, unsigned, _bitsize, radix) {\n    const res = isValid(str, style, radix);\n    if (res != null) {\n        const lessOrEqual = (x, y) => {\n            const len = Math.max(x.length, y.length);\n            return x.padStart(len, \"0\") <= y.padStart(len, \"0\");\n        };\n        const isNegative = res.sign === \"-\";\n        const maxValue = getMaxValue(unsigned || res.radix !== 10, res.radix, isNegative);\n        if (lessOrEqual(res.digits.toUpperCase(), maxValue)) {\n            str = isNegative ? res.sign + res.digits : res.digits;\n            return LongLib.fromString(str, unsigned, res.radix);\n        }\n    }\n    throw new Error(\"Input string was not in a correct format.\");\n}\nexport function tryParse(str, style, unsigned, bitsize, defValue) {\n    try {\n        defValue.contents = parse(str, style, unsigned, bitsize);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexport function unixEpochMillisecondsToTicks(ms, offset) {\n    return op_Multiply(op_Addition(op_Addition(LongLib.fromNumber(ms), 62135596800000), offset), 10000);\n}\nexport function ticksToUnixEpochMilliseconds(ticks) {\n    return LongLib.toNumber(op_Subtraction(op_Division(ticks, 10000), 62135596800000));\n}\n// export function makeRangeStepFunction(step: Long, last: Long, unsigned: boolean) {\n//   const stepComparedWithZero = LongLib.compare(step, unsigned ? LongLib.UZERO : LongLib.ZERO);\n//   if (stepComparedWithZero === 0) {\n//     throw new Error(\"The step of a range cannot be zero\");\n//   }\n//   const stepGreaterThanZero = stepComparedWithZero > 0;\n//   return (x: Long) => {\n//     const comparedWithLast = LongLib.compare(x, last);\n//     if ((stepGreaterThanZero && comparedWithLast <= 0)\n//       || (!stepGreaterThanZero && comparedWithLast >= 0)) {\n//       return [x, op_Addition(x, step)];\n//     } else {\n//       return undefined;\n//     }\n//   };\n// }\n","/**\n * DateTimeOffset functions.\n *\n * Note: Date instances are always DateObjects in local\n * timezone (because JS dates are all kinds of messed up).\n * A local date returns UTC epoc when `.getTime()` is called.\n *\n * Basically; invariant: date.getTime() always return UTC time.\n */\nimport { fromValue, ticksToUnixEpochMilliseconds, unixEpochMillisecondsToTicks } from \"./Long.js\";\nimport { compareDates, dateOffset, padWithZeros } from \"./Util.js\";\nexport const offsetRegex = /(?:Z|[+-](\\d+):?([0-5]?\\d)?)\\s*$/;\nexport function dateOffsetToString(offset) {\n    const isMinus = offset < 0;\n    offset = Math.abs(offset);\n    const hours = ~~(offset / 3600000);\n    const minutes = (offset % 3600000) / 60000;\n    return (isMinus ? \"-\" : \"+\") +\n        padWithZeros(hours, 2) + \":\" +\n        padWithZeros(minutes, 2);\n}\nexport function dateToHalfUTCString(date, half) {\n    const str = date.toISOString();\n    return half === \"first\"\n        ? str.substring(0, str.indexOf(\"T\"))\n        : str.substring(str.indexOf(\"T\") + 1, str.length - 1);\n}\nfunction dateToISOString(d, utc) {\n    if (utc) {\n        return d.toISOString();\n    }\n    else {\n        // JS Date is always local\n        const printOffset = d.kind == null ? true : d.kind === 2 /* Local */;\n        return padWithZeros(d.getFullYear(), 4) + \"-\" +\n            padWithZeros(d.getMonth() + 1, 2) + \"-\" +\n            padWithZeros(d.getDate(), 2) + \"T\" +\n            padWithZeros(d.getHours(), 2) + \":\" +\n            padWithZeros(d.getMinutes(), 2) + \":\" +\n            padWithZeros(d.getSeconds(), 2) + \".\" +\n            padWithZeros(d.getMilliseconds(), 3) +\n            (printOffset ? dateOffsetToString(d.getTimezoneOffset() * -60000) : \"\");\n    }\n}\nfunction dateToISOStringWithOffset(dateWithOffset, offset) {\n    const str = dateWithOffset.toISOString();\n    return str.substring(0, str.length - 1) + dateOffsetToString(offset);\n}\nfunction dateToStringWithCustomFormat(date, format, utc) {\n    return format.replace(/(\\w)\\1*/g, (match) => {\n        let rep = Number.NaN;\n        switch (match.substring(0, 1)) {\n            case \"y\":\n                const y = utc ? date.getUTCFullYear() : date.getFullYear();\n                rep = match.length < 4 ? y % 100 : y;\n                break;\n            case \"M\":\n                rep = (utc ? date.getUTCMonth() : date.getMonth()) + 1;\n                break;\n            case \"d\":\n                rep = utc ? date.getUTCDate() : date.getDate();\n                break;\n            case \"H\":\n                rep = utc ? date.getUTCHours() : date.getHours();\n                break;\n            case \"h\":\n                const h = utc ? date.getUTCHours() : date.getHours();\n                rep = h > 12 ? h % 12 : h;\n                break;\n            case \"m\":\n                rep = utc ? date.getUTCMinutes() : date.getMinutes();\n                break;\n            case \"s\":\n                rep = utc ? date.getUTCSeconds() : date.getSeconds();\n                break;\n            case \"f\":\n                rep = utc ? date.getUTCMilliseconds() : date.getMilliseconds();\n                break;\n        }\n        if (Number.isNaN(rep)) {\n            return match;\n        }\n        else {\n            return (rep < 10 && match.length > 1) ? \"0\" + rep : \"\" + rep;\n        }\n    });\n}\nfunction dateToStringWithOffset(date, format) {\n    var _a, _b, _c;\n    const d = new Date(date.getTime() + ((_a = date.offset) !== null && _a !== void 0 ? _a : 0));\n    if (typeof format !== \"string\") {\n        return d.toISOString().replace(/\\.\\d+/, \"\").replace(/[A-Z]|\\.\\d+/g, \" \") + dateOffsetToString(((_b = date.offset) !== null && _b !== void 0 ? _b : 0));\n    }\n    else if (format.length === 1) {\n        switch (format) {\n            case \"D\":\n            case \"d\": return dateToHalfUTCString(d, \"first\");\n            case \"T\":\n            case \"t\": return dateToHalfUTCString(d, \"second\");\n            case \"O\":\n            case \"o\": return dateToISOStringWithOffset(d, ((_c = date.offset) !== null && _c !== void 0 ? _c : 0));\n            default: throw new Error(\"Unrecognized Date print format\");\n        }\n    }\n    else {\n        return dateToStringWithCustomFormat(d, format, true);\n    }\n}\nfunction dateToStringWithKind(date, format) {\n    const utc = date.kind === 1 /* UTC */;\n    if (typeof format !== \"string\") {\n        return utc ? date.toUTCString() : date.toLocaleString();\n    }\n    else if (format.length === 1) {\n        switch (format) {\n            case \"D\":\n            case \"d\":\n                return utc ? dateToHalfUTCString(date, \"first\") : date.toLocaleDateString();\n            case \"T\":\n            case \"t\":\n                return utc ? dateToHalfUTCString(date, \"second\") : date.toLocaleTimeString();\n            case \"O\":\n            case \"o\":\n                return dateToISOString(date, utc);\n            default:\n                throw new Error(\"Unrecognized Date print format\");\n        }\n    }\n    else {\n        return dateToStringWithCustomFormat(date, format, utc);\n    }\n}\nexport function toString(date, format, _provider) {\n    return date.offset != null\n        ? dateToStringWithOffset(date, format)\n        : dateToStringWithKind(date, format);\n}\nexport function DateTime(value, kind) {\n    const d = new Date(value);\n    d.kind = (kind == null ? 0 /* Unspecified */ : kind) | 0;\n    return d;\n}\nexport function fromTicks(ticks, kind) {\n    ticks = fromValue(ticks);\n    kind = kind != null ? kind : 0 /* Unspecified */;\n    let date = DateTime(ticksToUnixEpochMilliseconds(ticks), kind);\n    // Ticks are local to offset (in this case, either UTC or Local/Unknown).\n    // If kind is anything but UTC, that means that the tick number was not\n    // in utc, thus getTime() cannot return UTC, and needs to be shifted.\n    if (kind !== 1 /* UTC */) {\n        date = DateTime(date.getTime() - dateOffset(date), kind);\n    }\n    return date;\n}\nexport function fromDateTimeOffset(date, kind) {\n    var _a;\n    switch (kind) {\n        case 1 /* UTC */: return DateTime(date.getTime(), 1 /* UTC */);\n        case 2 /* Local */: return DateTime(date.getTime(), 2 /* Local */);\n        default:\n            const d = DateTime(date.getTime() + ((_a = date.offset) !== null && _a !== void 0 ? _a : 0), kind);\n            return DateTime(d.getTime() - dateOffset(d), kind);\n    }\n}\nexport function getTicks(date) {\n    return unixEpochMillisecondsToTicks(date.getTime(), dateOffset(date));\n}\nexport function minValue() {\n    // This is \"0001-01-01T00:00:00.000Z\", actual JS min value is -8640000000000000\n    return DateTime(-62135596800000, 0 /* Unspecified */);\n}\nexport function maxValue() {\n    // This is \"9999-12-31T23:59:59.999Z\", actual JS max value is 8640000000000000\n    return DateTime(253402300799999, 0 /* Unspecified */);\n}\nexport function parseRaw(input) {\n    if (input === null) {\n        throw new Error(\"Value cannot be null when parsing DateTime\");\n    }\n    if (input.trim() === \"\") {\n        throw new Error(\"An empty string is not recognized as a valid DateTime\");\n    }\n    let date = new Date(input);\n    if (isNaN(date.getTime())) {\n        // Try to check strings JS Date cannot parse (see #1045, #1422)\n        // tslint:disable-next-line:max-line-length\n        const m = /^\\s*(\\d+[^\\w\\s:]\\d+[^\\w\\s:]\\d+)?\\s*(\\d+:\\d+(?::\\d+(?:\\.\\d+)?)?)?\\s*([AaPp][Mm])?\\s*([+-]\\d+(?::\\d+)?)?\\s*$/.exec(input);\n        if (m != null) {\n            let baseDate;\n            let timeInSeconds = 0;\n            if (m[2] != null) {\n                const timeParts = m[2].split(\":\");\n                timeInSeconds =\n                    parseInt(timeParts[0], 10) * 3600 +\n                        parseInt(timeParts[1] || \"0\", 10) * 60 +\n                        parseFloat(timeParts[2] || \"0\");\n                if (m[3] != null && m[3].toUpperCase() === \"PM\") {\n                    timeInSeconds += 720;\n                }\n            }\n            if (m[4] != null) { // There's an offset, parse as UTC\n                if (m[1] != null) {\n                    baseDate = new Date(m[1] + \" UTC\");\n                }\n                else {\n                    const d = new Date();\n                    baseDate = new Date(d.getUTCFullYear() + \"/\" + (d.getUTCMonth() + 1) + \"/\" + d.getUTCDate());\n                }\n                const offsetParts = m[4].substr(1).split(\":\");\n                let offsetInMinutes = parseInt(offsetParts[0], 10) * 60 + parseInt(offsetParts[1] || \"0\", 10);\n                if (m[4][0] === \"+\") {\n                    offsetInMinutes *= -1;\n                }\n                timeInSeconds += offsetInMinutes * 60;\n            }\n            else {\n                if (m[1] != null) {\n                    baseDate = new Date(m[1]);\n                }\n                else {\n                    const d = new Date();\n                    baseDate = new Date(d.getFullYear() + \"/\" + (d.getMonth() + 1) + \"/\" + d.getDate());\n                }\n            }\n            date = new Date(baseDate.getTime() + timeInSeconds * 1000);\n            // correct for daylight savings time\n            date = new Date(date.getTime() + (date.getTimezoneOffset() - baseDate.getTimezoneOffset()) * 60000);\n        }\n        else {\n            throw new Error(\"The string is not a valid Date.\");\n        }\n    }\n    return date;\n}\nexport function parse(str, detectUTC = false) {\n    const date = parseRaw(str);\n    const offset = offsetRegex.exec(str);\n    // .NET always parses DateTime as Local if there's offset info (even \"Z\")\n    // Newtonsoft.Json uses UTC if the offset is \"Z\"\n    const kind = offset != null\n        ? (detectUTC && offset[0] === \"Z\" ? 1 /* UTC */ : 2 /* Local */)\n        : 0 /* Unspecified */;\n    return DateTime(date.getTime(), kind);\n}\nexport function tryParse(v, defValue) {\n    try {\n        defValue.contents = parse(v);\n        return true;\n    }\n    catch (_err) {\n        return false;\n    }\n}\nexport function create(year, month, day, h = 0, m = 0, s = 0, ms = 0, kind) {\n    const dateValue = kind === 1 /* UTC */\n        ? Date.UTC(year, month - 1, day, h, m, s, ms)\n        : new Date(year, month - 1, day, h, m, s, ms).getTime();\n    if (isNaN(dateValue)) {\n        throw new Error(\"The parameters describe an unrepresentable Date.\");\n    }\n    const date = DateTime(dateValue, kind);\n    if (year <= 99) {\n        date.setFullYear(year, month - 1, day);\n    }\n    return date;\n}\nexport function now() {\n    return DateTime(Date.now(), 2 /* Local */);\n}\nexport function utcNow() {\n    return DateTime(Date.now(), 1 /* UTC */);\n}\nexport function today() {\n    return date(now());\n}\nexport function isLeapYear(year) {\n    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n}\nexport function daysInMonth(year, month) {\n    return month === 2\n        ? (isLeapYear(year) ? 29 : 28)\n        : (month >= 8 ? (month % 2 === 0 ? 31 : 30) : (month % 2 === 0 ? 30 : 31));\n}\nexport function toUniversalTime(date) {\n    return date.kind === 1 /* UTC */ ? date : DateTime(date.getTime(), 1 /* UTC */);\n}\nexport function toLocalTime(date) {\n    return date.kind === 2 /* Local */ ? date : DateTime(date.getTime(), 2 /* Local */);\n}\nexport function specifyKind(d, kind) {\n    return create(year(d), month(d), day(d), hour(d), minute(d), second(d), millisecond(d), kind);\n}\nexport function timeOfDay(d) {\n    return hour(d) * 3600000\n        + minute(d) * 60000\n        + second(d) * 1000\n        + millisecond(d);\n}\nexport function date(d) {\n    return create(year(d), month(d), day(d), 0, 0, 0, 0, d.kind);\n}\nexport function day(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCDate() : d.getDate();\n}\nexport function hour(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCHours() : d.getHours();\n}\nexport function millisecond(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCMilliseconds() : d.getMilliseconds();\n}\nexport function minute(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCMinutes() : d.getMinutes();\n}\nexport function month(d) {\n    return (d.kind === 1 /* UTC */ ? d.getUTCMonth() : d.getMonth()) + 1;\n}\nexport function second(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCSeconds() : d.getSeconds();\n}\nexport function year(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCFullYear() : d.getFullYear();\n}\nexport function dayOfWeek(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCDay() : d.getDay();\n}\nexport function dayOfYear(d) {\n    const _year = year(d);\n    const _month = month(d);\n    let _day = day(d);\n    for (let i = 1; i < _month; i++) {\n        _day += daysInMonth(_year, i);\n    }\n    return _day;\n}\nexport function add(d, ts) {\n    const newDate = DateTime(d.getTime() + ts, d.kind);\n    if (d.kind === 2 /* Local */) {\n        const oldTzOffset = d.getTimezoneOffset();\n        const newTzOffset = newDate.getTimezoneOffset();\n        return oldTzOffset !== newTzOffset\n            ? DateTime(newDate.getTime() + (newTzOffset - oldTzOffset) * 60000, d.kind)\n            : newDate;\n    }\n    else {\n        return newDate;\n    }\n}\nexport function addDays(d, v) {\n    return add(d, v * 86400000);\n}\nexport function addHours(d, v) {\n    return add(d, v * 3600000);\n}\nexport function addMinutes(d, v) {\n    return add(d, v * 60000);\n}\nexport function addSeconds(d, v) {\n    return add(d, v * 1000);\n}\nexport function addMilliseconds(d, v) {\n    return add(d, v);\n}\nexport function addYears(d, v) {\n    const newMonth = month(d);\n    const newYear = year(d) + v;\n    const _daysInMonth = daysInMonth(newYear, newMonth);\n    const newDay = Math.min(_daysInMonth, day(d));\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind);\n}\nexport function addMonths(d, v) {\n    let newMonth = month(d) + v;\n    let newMonth_ = 0;\n    let yearOffset = 0;\n    if (newMonth > 12) {\n        newMonth_ = newMonth % 12;\n        yearOffset = Math.floor(newMonth / 12);\n        newMonth = newMonth_;\n    }\n    else if (newMonth < 1) {\n        newMonth_ = 12 + newMonth % 12;\n        yearOffset = Math.floor(newMonth / 12) + (newMonth_ === 12 ? -1 : 0);\n        newMonth = newMonth_;\n    }\n    const newYear = year(d) + yearOffset;\n    const _daysInMonth = daysInMonth(newYear, newMonth);\n    const newDay = Math.min(_daysInMonth, day(d));\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind);\n}\nexport function subtract(d, that) {\n    return typeof that === \"number\"\n        ? add(d, -that)\n        : d.getTime() - that.getTime();\n}\nexport function toLongDateString(d) {\n    return d.toDateString();\n}\nexport function toShortDateString(d) {\n    return d.toLocaleDateString();\n}\nexport function toLongTimeString(d) {\n    return d.toLocaleTimeString();\n}\nexport function toShortTimeString(d) {\n    return d.toLocaleTimeString().replace(/:\\d\\d(?!:)/, \"\");\n}\nexport function equals(d1, d2) {\n    return d1.getTime() === d2.getTime();\n}\nexport const compare = compareDates;\nexport const compareTo = compareDates;\nexport function op_Addition(x, y) {\n    return add(x, y);\n}\nexport function op_Subtraction(x, y) {\n    return subtract(x, y);\n}\nexport function isDaylightSavingTime(x) {\n    const jan = new Date(x.getFullYear(), 0, 1);\n    const jul = new Date(x.getFullYear(), 6, 1);\n    return isDST(jan.getTimezoneOffset(), jul.getTimezoneOffset(), x.getTimezoneOffset());\n}\nfunction isDST(janOffset, julOffset, tOffset) {\n    return Math.min(janOffset, julOffset) === tOffset;\n}\nexport default DateTime;\n","export function create(pattern, options = 0) {\n    // Supported RegexOptions\n    // * IgnoreCase:  0x0001\n    // * Multiline:   0x0002\n    // * Singleline:  0x0010\n    // * ECMAScript:  0x0100 (ignored)\n    if ((options & ~(1 ^ 2 ^ 16 ^ 256)) !== 0) {\n        throw new Error(\"RegexOptions only supports: IgnoreCase, Multiline, Singleline and ECMAScript\");\n    }\n    let flags = \"g\";\n    flags += options & 1 ? \"i\" : \"\"; // 0x0001 RegexOptions.IgnoreCase\n    flags += options & 2 ? \"m\" : \"\";\n    flags += options & 16 ? \"s\" : \"\";\n    return new RegExp(pattern, flags);\n}\n// From http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex\nexport function escape(str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n}\nexport function unescape(str) {\n    return str.replace(/\\\\([\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|])/g, \"$1\");\n}\nexport function isMatch(str, pattern, options = 0) {\n    let reg;\n    reg = str instanceof RegExp\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\n        : reg = create(pattern, options);\n    return reg.test(str);\n}\nexport function match(str, pattern, options = 0) {\n    let reg;\n    reg = str instanceof RegExp\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\n        : reg = create(pattern, options);\n    return reg.exec(str);\n}\nexport function matches(str, pattern, options = 0) {\n    let reg;\n    reg = str instanceof RegExp\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\n        : reg = create(pattern, options);\n    if (!reg.global) {\n        throw new Error(\"Non-global RegExp\"); // Prevent infinite loop\n    }\n    let m = reg.exec(str);\n    const matches = [];\n    while (m !== null) {\n        matches.push(m);\n        m = reg.exec(str);\n    }\n    return matches;\n}\nexport function options(reg) {\n    let options = 256; // ECMAScript\n    options |= reg.ignoreCase ? 1 : 0;\n    options |= reg.multiline ? 2 : 0;\n    return options;\n}\nexport function replace(reg, input, replacement, limit, offset = 0) {\n    function replacer() {\n        let res = arguments[0];\n        if (limit) {\n            limit--;\n            const match = [];\n            const len = arguments.length;\n            // arguments: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_a_parameter\n            // * match: matched substring\n            // * p1, p2, ...: nth capture group string\n            // * offset: offset of matched substring\n            // * string: whole string examined\n            // * groups: named capturing groups\n            //           ONLY if regex contains a named capture group AND browser supports named groups\n            // -> last element can be groups OR input string\n            // -> check if last element is string\n            const withGroups = typeof arguments[len - 1] !== \"string\";\n            let pLast = withGroups ? len - 3 : len - 2;\n            for (let i = 0; i < pLast; i++) {\n                match.push(arguments[i]);\n            }\n            match.index = arguments[pLast++];\n            match.input = arguments[pLast++];\n            if (withGroups) {\n                match.groups = arguments[pLast];\n            }\n            res = replacement(match);\n        }\n        return res;\n    }\n    if (typeof reg === \"string\") {\n        const tmp = reg;\n        reg = create(input, limit !== null && limit !== void 0 ? limit : 0);\n        input = tmp;\n        limit = undefined;\n    }\n    if (typeof replacement === \"function\") {\n        limit = limit == null ? -1 : limit;\n        return input.substring(0, offset) + input.substring(offset).replace(reg, replacer);\n    }\n    else {\n        replacement =\n            replacement\n                // $0 doesn't work with JS regex, see #1155\n                .replace(/\\$0/g, (_s) => \"$&\")\n                // named groups in replacement are `${name}` in .Net, but `$<name>` in JS (in regex: groups are `(?<name>...)` in both)\n                .replace(/\\${([^}]+)}/g, \"\\$<$1>\");\n        if (limit != null) {\n            let m;\n            const sub1 = input.substring(offset);\n            const _matches = matches(reg, sub1);\n            const sub2 = matches.length > limit ? (m = _matches[limit - 1], sub1.substring(0, m.index + m[0].length)) : sub1;\n            return input.substring(0, offset) + sub2.replace(reg, replacement)\n                + input.substring(offset + sub2.length);\n        }\n        else {\n            return input.replace(reg, replacement);\n        }\n    }\n}\nexport function split(reg, input, limit, offset = 0) {\n    if (typeof reg === \"string\") {\n        const tmp = reg;\n        reg = create(input, limit !== null && limit !== void 0 ? limit : 0);\n        input = tmp;\n        limit = undefined;\n    }\n    input = input.substring(offset);\n    return input.split(reg, limit);\n}\n","import { toString as dateToString } from \"./Date.js\";\nimport { compare as numericCompare, isNumeric, multiply, toExponential, toFixed, toHex, toPrecision } from \"./Numeric.js\";\nimport { escape } from \"./RegExp.js\";\nimport { toString } from \"./Types.js\";\nconst fsFormatRegExp = /(^|[^%])%([0+\\- ]*)(\\*|\\d+)?(?:\\.(\\d+))?(\\w)/g;\nconst interpolateRegExp = /(?:(^|[^%])%([0+\\- ]*)(\\d+)?(?:\\.(\\d+))?(\\w))?%P\\(\\)/g;\nconst formatRegExp = /\\{(\\d+)(,-?\\d+)?(?:\\:([a-zA-Z])(\\d{0,2})|\\:(.+?))?\\}/g;\nfunction isLessThan(x, y) {\n    return numericCompare(x, y) < 0;\n}\nfunction cmp(x, y, ic) {\n    function isIgnoreCase(i) {\n        return i === true ||\n            i === 1 /* CurrentCultureIgnoreCase */ ||\n            i === 3 /* InvariantCultureIgnoreCase */ ||\n            i === 5 /* OrdinalIgnoreCase */;\n    }\n    function isOrdinal(i) {\n        return i === 4 /* Ordinal */ ||\n            i === 5 /* OrdinalIgnoreCase */;\n    }\n    if (x == null) {\n        return y == null ? 0 : -1;\n    }\n    if (y == null) {\n        return 1;\n    } // everything is bigger than null\n    if (isOrdinal(ic)) {\n        if (isIgnoreCase(ic)) {\n            x = x.toLowerCase();\n            y = y.toLowerCase();\n        }\n        return (x === y) ? 0 : (x < y ? -1 : 1);\n    }\n    else {\n        if (isIgnoreCase(ic)) {\n            x = x.toLocaleLowerCase();\n            y = y.toLocaleLowerCase();\n        }\n        return x.localeCompare(y);\n    }\n}\nexport function compare(...args) {\n    switch (args.length) {\n        case 2: return cmp(args[0], args[1], false);\n        case 3: return cmp(args[0], args[1], args[2]);\n        case 4: return cmp(args[0], args[1], args[2] === true);\n        case 5: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), false);\n        case 6: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5]);\n        case 7: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5] === true);\n        default: throw new Error(\"String.compare: Unsupported number of parameters\");\n    }\n}\nexport function compareOrdinal(x, y) {\n    return cmp(x, y, 4 /* Ordinal */);\n}\nexport function compareTo(x, y) {\n    return cmp(x, y, 0 /* CurrentCulture */);\n}\nexport function startsWith(str, pattern, ic) {\n    if (str.length >= pattern.length) {\n        return cmp(str.substr(0, pattern.length), pattern, ic) === 0;\n    }\n    return false;\n}\nexport function indexOfAny(str, anyOf, ...args) {\n    if (str == null || str === \"\") {\n        return -1;\n    }\n    const startIndex = (args.length > 0) ? args[0] : 0;\n    if (startIndex < 0) {\n        throw new Error(\"Start index cannot be negative\");\n    }\n    const length = (args.length > 1) ? args[1] : str.length - startIndex;\n    if (length < 0) {\n        throw new Error(\"Length cannot be negative\");\n    }\n    if (length > str.length - startIndex) {\n        throw new Error(\"Invalid startIndex and length\");\n    }\n    str = str.substr(startIndex, length);\n    for (const c of anyOf) {\n        const index = str.indexOf(c);\n        if (index > -1) {\n            return index + startIndex;\n        }\n    }\n    return -1;\n}\nexport function printf(input) {\n    return {\n        input,\n        cont: fsFormat(input),\n    };\n}\nexport function interpolate(str, values) {\n    let valIdx = 0;\n    let strIdx = 0;\n    let result = \"\";\n    interpolateRegExp.lastIndex = 0;\n    let match = interpolateRegExp.exec(str);\n    while (match) {\n        // The first group corresponds to the no-escape char (^|[^%]), the actual pattern starts in the next char\n        // Note: we don't use negative lookbehind because some browsers don't support it yet\n        const matchIndex = match.index + (match[1] || \"\").length;\n        result += str.substring(strIdx, matchIndex).replace(/%%/g, \"%\");\n        const [, , flags, padLength, precision, format] = match;\n        result += formatReplacement(values[valIdx++], flags, padLength, precision, format);\n        strIdx = interpolateRegExp.lastIndex;\n        // Likewise we need to move interpolateRegExp.lastIndex one char behind to make sure we match the no-escape char next time\n        interpolateRegExp.lastIndex -= 1;\n        match = interpolateRegExp.exec(str);\n    }\n    result += str.substring(strIdx).replace(/%%/g, \"%\");\n    return result;\n}\nfunction continuePrint(cont, arg) {\n    return typeof arg === \"string\" ? cont(arg) : arg.cont(cont);\n}\nexport function toConsole(arg) {\n    // Don't remove the lambda here, see #1357\n    return continuePrint((x) => console.log(x), arg);\n}\nexport function toConsoleError(arg) {\n    return continuePrint((x) => console.error(x), arg);\n}\nexport function toText(arg) {\n    return continuePrint((x) => x, arg);\n}\nexport function toFail(arg) {\n    return continuePrint((x) => {\n        throw new Error(x);\n    }, arg);\n}\nfunction formatReplacement(rep, flags, padLength, precision, format) {\n    let sign = \"\";\n    flags = flags || \"\";\n    format = format || \"\";\n    if (isNumeric(rep)) {\n        if (format.toLowerCase() !== \"x\") {\n            if (isLessThan(rep, 0)) {\n                rep = multiply(rep, -1);\n                sign = \"-\";\n            }\n            else {\n                if (flags.indexOf(\" \") >= 0) {\n                    sign = \" \";\n                }\n                else if (flags.indexOf(\"+\") >= 0) {\n                    sign = \"+\";\n                }\n            }\n        }\n        precision = precision == null ? null : parseInt(precision, 10);\n        switch (format) {\n            case \"f\":\n            case \"F\":\n                precision = precision != null ? precision : 6;\n                rep = toFixed(rep, precision);\n                break;\n            case \"g\":\n            case \"G\":\n                rep = precision != null ? toPrecision(rep, precision) : toPrecision(rep);\n                break;\n            case \"e\":\n            case \"E\":\n                rep = precision != null ? toExponential(rep, precision) : toExponential(rep);\n                break;\n            case \"x\":\n                rep = toHex(rep);\n                break;\n            case \"X\":\n                rep = toHex(rep).toUpperCase();\n                break;\n            default: // AOid\n                rep = String(rep);\n                break;\n        }\n    }\n    else if (rep instanceof Date) {\n        rep = dateToString(rep);\n    }\n    else {\n        rep = toString(rep);\n    }\n    padLength = typeof padLength === \"number\" ? padLength : parseInt(padLength, 10);\n    if (!isNaN(padLength)) {\n        const zeroFlag = flags.indexOf(\"0\") >= 0; // Use '0' for left padding\n        const minusFlag = flags.indexOf(\"-\") >= 0; // Right padding\n        const ch = minusFlag || !zeroFlag ? \" \" : \"0\";\n        if (ch === \"0\") {\n            rep = padLeft(rep, padLength - sign.length, ch, minusFlag);\n            rep = sign + rep;\n        }\n        else {\n            rep = padLeft(sign + rep, padLength, ch, minusFlag);\n        }\n    }\n    else {\n        rep = sign + rep;\n    }\n    return rep;\n}\nfunction createPrinter(cont, _strParts, _matches, _result = \"\", padArg = -1) {\n    return (...args) => {\n        // Make copies of the values passed by reference because the function can be used multiple times\n        let result = _result;\n        const strParts = _strParts.slice();\n        const matches = _matches.slice();\n        for (const arg of args) {\n            const [, , flags, _padLength, precision, format] = matches[0];\n            let padLength = _padLength;\n            if (padArg >= 0) {\n                padLength = padArg;\n                padArg = -1;\n            }\n            else if (padLength === \"*\") {\n                if (arg < 0) {\n                    throw new Error(\"Non-negative number required\");\n                }\n                padArg = arg;\n                continue;\n            }\n            result += strParts[0];\n            result += formatReplacement(arg, flags, padLength, precision, format);\n            strParts.splice(0, 1);\n            matches.splice(0, 1);\n        }\n        if (matches.length === 0) {\n            result += strParts[0];\n            return cont(result);\n        }\n        else {\n            return createPrinter(cont, strParts, matches, result, padArg);\n        }\n    };\n}\nexport function fsFormat(str) {\n    return (cont) => {\n        fsFormatRegExp.lastIndex = 0;\n        const strParts = [];\n        const matches = [];\n        let strIdx = 0;\n        let match = fsFormatRegExp.exec(str);\n        while (match) {\n            // The first group corresponds to the no-escape char (^|[^%]), the actual pattern starts in the next char\n            // Note: we don't use negative lookbehind because some browsers don't support it yet\n            const matchIndex = match.index + (match[1] || \"\").length;\n            strParts.push(str.substring(strIdx, matchIndex).replace(/%%/g, \"%\"));\n            matches.push(match);\n            strIdx = fsFormatRegExp.lastIndex;\n            // Likewise we need to move fsFormatRegExp.lastIndex one char behind to make sure we match the no-escape char next time\n            fsFormatRegExp.lastIndex -= 1;\n            match = fsFormatRegExp.exec(str);\n        }\n        if (strParts.length === 0) {\n            return cont(str.replace(/%%/g, \"%\"));\n        }\n        else {\n            strParts.push(str.substring(strIdx).replace(/%%/g, \"%\"));\n            return createPrinter(cont, strParts, matches);\n        }\n    };\n}\nexport function format(str, ...args) {\n    if (typeof str === \"object\" && args.length > 0) {\n        // Called with culture info\n        str = args[0];\n        args.shift();\n    }\n    return str.replace(formatRegExp, (_, idx, padLength, format, precision, pattern) => {\n        let rep = args[idx];\n        if (isNumeric(rep)) {\n            precision = precision == null ? null : parseInt(precision, 10);\n            switch (format) {\n                case \"f\":\n                case \"F\":\n                    precision = precision != null ? precision : 2;\n                    rep = toFixed(rep, precision);\n                    break;\n                case \"g\":\n                case \"G\":\n                    rep = precision != null ? toPrecision(rep, precision) : toPrecision(rep);\n                    break;\n                case \"e\":\n                case \"E\":\n                    rep = precision != null ? toExponential(rep, precision) : toExponential(rep);\n                    break;\n                case \"p\":\n                case \"P\":\n                    precision = precision != null ? precision : 2;\n                    rep = toFixed(multiply(rep, 100), precision) + \" %\";\n                    break;\n                case \"d\":\n                case \"D\":\n                    rep = precision != null ? padLeft(String(rep), precision, \"0\") : String(rep);\n                    break;\n                case \"x\":\n                case \"X\":\n                    rep = precision != null ? padLeft(toHex(rep), precision, \"0\") : toHex(rep);\n                    if (format === \"X\") {\n                        rep = rep.toUpperCase();\n                    }\n                    break;\n                default:\n                    if (pattern) {\n                        let sign = \"\";\n                        rep = pattern.replace(/(0+)(\\.0+)?/, (_, intPart, decimalPart) => {\n                            if (isLessThan(rep, 0)) {\n                                rep = multiply(rep, -1);\n                                sign = \"-\";\n                            }\n                            rep = toFixed(rep, decimalPart != null ? decimalPart.length - 1 : 0);\n                            return padLeft(rep, (intPart || \"\").length - sign.length + (decimalPart != null ? decimalPart.length : 0), \"0\");\n                        });\n                        rep = sign + rep;\n                    }\n            }\n        }\n        else if (rep instanceof Date) {\n            rep = dateToString(rep, pattern || format);\n        }\n        else {\n            rep = toString(rep);\n        }\n        padLength = parseInt((padLength || \" \").substring(1), 10);\n        if (!isNaN(padLength)) {\n            rep = padLeft(String(rep), Math.abs(padLength), \" \", padLength < 0);\n        }\n        return rep;\n    });\n}\nexport function endsWith(str, search) {\n    const idx = str.lastIndexOf(search);\n    return idx >= 0 && idx === str.length - search.length;\n}\nexport function initialize(n, f) {\n    if (n < 0) {\n        throw new Error(\"String length must be non-negative\");\n    }\n    const xs = new Array(n);\n    for (let i = 0; i < n; i++) {\n        xs[i] = f(i);\n    }\n    return xs.join(\"\");\n}\nexport function insert(str, startIndex, value) {\n    if (startIndex < 0 || startIndex > str.length) {\n        throw new Error(\"startIndex is negative or greater than the length of this instance.\");\n    }\n    return str.substring(0, startIndex) + value + str.substring(startIndex);\n}\nexport function isNullOrEmpty(str) {\n    return typeof str !== \"string\" || str.length === 0;\n}\nexport function isNullOrWhiteSpace(str) {\n    return typeof str !== \"string\" || /^\\s*$/.test(str);\n}\nexport function concat(...xs) {\n    return xs.map((x) => String(x)).join(\"\");\n}\nexport function join(delimiter, xs) {\n    if (Array.isArray(xs)) {\n        return xs.join(delimiter);\n    }\n    else {\n        return Array.from(xs).join(delimiter);\n    }\n}\nexport function joinWithIndices(delimiter, xs, startIndex, count) {\n    const endIndexPlusOne = startIndex + count;\n    if (endIndexPlusOne > xs.length) {\n        throw new Error(\"Index and count must refer to a location within the buffer.\");\n    }\n    return xs.slice(startIndex, endIndexPlusOne).join(delimiter);\n}\nfunction notSupported(name) {\n    throw new Error(\"The environment doesn't support '\" + name + \"', please use a polyfill.\");\n}\nexport function toBase64String(inArray) {\n    let str = \"\";\n    for (let i = 0; i < inArray.length; i++) {\n        str += String.fromCharCode(inArray[i]);\n    }\n    return typeof btoa === \"function\" ? btoa(str) : notSupported(\"btoa\");\n}\nexport function fromBase64String(b64Encoded) {\n    const binary = typeof atob === \"function\" ? atob(b64Encoded) : notSupported(\"atob\");\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\nexport function padLeft(str, len, ch, isRight) {\n    ch = ch || \" \";\n    len = len - str.length;\n    for (let i = 0; i < len; i++) {\n        str = isRight ? str + ch : ch + str;\n    }\n    return str;\n}\nexport function padRight(str, len, ch) {\n    return padLeft(str, len, ch, true);\n}\nexport function remove(str, startIndex, count) {\n    if (startIndex >= str.length) {\n        throw new Error(\"startIndex must be less than length of string\");\n    }\n    if (typeof count === \"number\" && (startIndex + count) > str.length) {\n        throw new Error(\"Index and count must refer to a location within the string.\");\n    }\n    return str.slice(0, startIndex) + (typeof count === \"number\" ? str.substr(startIndex + count) : \"\");\n}\nexport function replace(str, search, replace) {\n    return str.replace(new RegExp(escape(search), \"g\"), replace);\n}\nexport function replicate(n, x) {\n    return initialize(n, () => x);\n}\nexport function getCharAtIndex(input, index) {\n    if (index < 0 || index >= input.length) {\n        throw new Error(\"Index was outside the bounds of the array.\");\n    }\n    return input[index];\n}\nexport function split(str, splitters, count, removeEmpty) {\n    count = typeof count === \"number\" ? count : undefined;\n    removeEmpty = typeof removeEmpty === \"number\" ? removeEmpty : undefined;\n    if (count && count < 0) {\n        throw new Error(\"Count cannot be less than zero\");\n    }\n    if (count === 0) {\n        return [];\n    }\n    if (!Array.isArray(splitters)) {\n        if (removeEmpty === 0) {\n            return str.split(splitters, count);\n        }\n        const len = arguments.length;\n        splitters = Array(len - 1);\n        for (let key = 1; key < len; key++) {\n            splitters[key - 1] = arguments[key];\n        }\n    }\n    splitters = splitters.map((x) => escape(x));\n    splitters = splitters.length > 0 ? splitters : [\" \"];\n    let i = 0;\n    const splits = [];\n    const reg = new RegExp(splitters.join(\"|\"), \"g\");\n    while (count == null || count > 1) {\n        const m = reg.exec(str);\n        if (m === null) {\n            break;\n        }\n        if (!removeEmpty || (m.index - i) > 0) {\n            count = count != null ? count - 1 : count;\n            splits.push(str.substring(i, m.index));\n        }\n        i = reg.lastIndex;\n    }\n    if (!removeEmpty || (str.length - i) > 0) {\n        splits.push(str.substring(i));\n    }\n    return splits;\n}\nexport function trim(str, ...chars) {\n    if (chars.length === 0) {\n        return str.trim();\n    }\n    const pattern = \"[\" + escape(chars.join(\"\")) + \"]+\";\n    return str.replace(new RegExp(\"^\" + pattern), \"\").replace(new RegExp(pattern + \"$\"), \"\");\n}\nexport function trimStart(str, ...chars) {\n    return chars.length === 0\n        ? str.trimStart()\n        : str.replace(new RegExp(\"^[\" + escape(chars.join(\"\")) + \"]+\"), \"\");\n}\nexport function trimEnd(str, ...chars) {\n    return chars.length === 0\n        ? str.trimEnd()\n        : str.replace(new RegExp(\"[\" + escape(chars.join(\"\")) + \"]+$\"), \"\");\n}\nexport function filter(pred, x) {\n    return x.split(\"\").filter((c) => pred(c)).join(\"\");\n}\nexport function substring(str, startIndex, length) {\n    if ((startIndex + (length || 0) > str.length)) {\n        throw new Error(\"Invalid startIndex and/or length\");\n    }\n    return length != null ? str.substr(startIndex, length) : str.substr(startIndex);\n}\n","import { compare, equals, structuralHash } from \"./Util.js\";\n// Using a class here for better compatibility with TS files importing Some\nexport class Some {\n    constructor(value) {\n        this.value = value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    // Don't add \"Some\" for consistency with erased options\n    toString() {\n        return String(this.value);\n    }\n    GetHashCode() {\n        return structuralHash(this.value);\n    }\n    Equals(other) {\n        if (other == null) {\n            return false;\n        }\n        else {\n            return equals(this.value, other instanceof Some ? other.value : other);\n        }\n    }\n    CompareTo(other) {\n        if (other == null) {\n            return 1;\n        }\n        else {\n            return compare(this.value, other instanceof Some ? other.value : other);\n        }\n    }\n}\nexport function some(x) {\n    return x == null || x instanceof Some ? new Some(x) : x;\n}\nexport function value(x) {\n    if (x == null) {\n        throw new Error(\"Option has no value\");\n    }\n    else {\n        return x instanceof Some ? x.value : x;\n    }\n}\nexport function ofNullable(x) {\n    // This will fail with unit probably, an alternative would be:\n    // return x === null ? undefined : (x === undefined ? new Some(x) : x);\n    return x == null ? undefined : x;\n}\nexport function toNullable(x) {\n    return x == null ? null : value(x);\n}\nexport function flatten(x) {\n    return x == null ? undefined : value(x);\n}\nexport function toArray(opt) {\n    return (opt == null) ? [] : [value(opt)];\n}\nexport function defaultArg(opt, defaultValue) {\n    return (opt != null) ? value(opt) : defaultValue;\n}\nexport function defaultArgWith(opt, defThunk) {\n    return (opt != null) ? value(opt) : defThunk();\n}\nexport function filter(predicate, opt) {\n    return (opt != null) ? (predicate(value(opt)) ? opt : undefined) : opt;\n}\nexport function map(mapping, opt) {\n    return (opt != null) ? some(mapping(value(opt))) : undefined;\n}\nexport function map2(mapping, opt1, opt2) {\n    return (opt1 != null && opt2 != null) ? mapping(value(opt1), value(opt2)) : undefined;\n}\nexport function map3(mapping, opt1, opt2, opt3) {\n    return (opt1 != null && opt2 != null && opt3 != null) ? mapping(value(opt1), value(opt2), value(opt3)) : undefined;\n}\nexport function bind(binder, opt) {\n    return opt != null ? binder(value(opt)) : undefined;\n}\nexport function tryOp(op, arg) {\n    try {\n        return some(op(arg));\n    }\n    catch (_a) {\n        return undefined;\n    }\n}\n","import { value as value_2, defaultArg, some } from \"./Option.js\";\r\nimport { min as min_1, compare, getEnumerator, comparePrimitives, max as max_1 } from \"./Util.js\";\r\n\r\nexport function Helpers_allocateArrayFromCons(cons, len) {\r\n    if ((typeof cons) === \"function\") {\r\n        return new cons(len);\r\n    }\r\n    else {\r\n        return new Array(len);\r\n    }\r\n}\r\n\r\nfunction indexNotFound() {\r\n    throw (new Error(\"An index satisfying the predicate was not found in the collection.\"));\r\n}\r\n\r\nfunction differentLengths() {\r\n    throw (new Error(\"Arrays had different lengths\"));\r\n}\r\n\r\nexport function append(array1, array2, cons) {\r\n    const len1 = array1.length | 0;\r\n    const len2 = array2.length | 0;\r\n    const newArray = Helpers_allocateArrayFromCons(cons, len1 + len2);\r\n    for (let i = 0; i <= (len1 - 1); i++) {\r\n        newArray[i] = array1[i];\r\n    }\r\n    for (let i_1 = 0; i_1 <= (len2 - 1); i_1++) {\r\n        newArray[i_1 + len1] = array2[i_1];\r\n    }\r\n    return newArray;\r\n}\r\n\r\nexport function filter(predicate, array) {\r\n    return array.filter(predicate);\r\n}\r\n\r\nexport function fill(target, targetIndex, count, value) {\r\n    const start = targetIndex | 0;\r\n    return target.fill(value, start, (start + count));\r\n}\r\n\r\nexport function getSubArray(array, start, count) {\r\n    const start_1 = start | 0;\r\n    return array.slice(start_1, (start_1 + count));\r\n}\r\n\r\nexport function last(array) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\\\\nParameter name: array\"));\r\n    }\r\n    return array[array.length - 1];\r\n}\r\n\r\nexport function tryLast(array) {\r\n    if (array.length === 0) {\r\n        return void 0;\r\n    }\r\n    else {\r\n        return some(array[array.length - 1]);\r\n    }\r\n}\r\n\r\nexport function mapIndexed(f, source, cons) {\r\n    const len = source.length | 0;\r\n    const target = Helpers_allocateArrayFromCons(cons, len);\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        target[i] = f(i, source[i]);\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function map(f, source, cons) {\r\n    const len = source.length | 0;\r\n    const target = Helpers_allocateArrayFromCons(cons, len);\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        target[i] = f(source[i]);\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function mapIndexed2(f, source1, source2, cons) {\r\n    if (source1.length !== source2.length) {\r\n        throw (new Error(\"Arrays had different lengths\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\r\n    for (let i = 0; i <= (source1.length - 1); i++) {\r\n        result[i] = f(i, source1[i], source2[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function map2(f, source1, source2, cons) {\r\n    if (source1.length !== source2.length) {\r\n        throw (new Error(\"Arrays had different lengths\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\r\n    for (let i = 0; i <= (source1.length - 1); i++) {\r\n        result[i] = f(source1[i], source2[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function mapIndexed3(f, source1, source2, source3, cons) {\r\n    if ((source1.length !== source2.length) ? true : (source2.length !== source3.length)) {\r\n        throw (new Error(\"Arrays had different lengths\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\r\n    for (let i = 0; i <= (source1.length - 1); i++) {\r\n        result[i] = f(i, source1[i], source2[i], source3[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function map3(f, source1, source2, source3, cons) {\r\n    if ((source1.length !== source2.length) ? true : (source2.length !== source3.length)) {\r\n        throw (new Error(\"Arrays had different lengths\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\r\n    for (let i = 0; i <= (source1.length - 1); i++) {\r\n        result[i] = f(source1[i], source2[i], source3[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function mapFold(mapping, state, array, cons) {\r\n    const matchValue = array.length | 0;\r\n    if (matchValue === 0) {\r\n        return [[], state];\r\n    }\r\n    else {\r\n        let acc = state;\r\n        const res = Helpers_allocateArrayFromCons(cons, matchValue);\r\n        for (let i = 0; i <= (array.length - 1); i++) {\r\n            const patternInput = mapping(acc, array[i]);\r\n            res[i] = patternInput[0];\r\n            acc = patternInput[1];\r\n        }\r\n        return [res, acc];\r\n    }\r\n}\r\n\r\nexport function mapFoldBack(mapping, array, state, cons) {\r\n    const matchValue = array.length | 0;\r\n    if (matchValue === 0) {\r\n        return [[], state];\r\n    }\r\n    else {\r\n        let acc = state;\r\n        const res = Helpers_allocateArrayFromCons(cons, matchValue);\r\n        for (let i = array.length - 1; i >= 0; i--) {\r\n            const patternInput = mapping(array[i], acc);\r\n            res[i] = patternInput[0];\r\n            acc = patternInput[1];\r\n        }\r\n        return [res, acc];\r\n    }\r\n}\r\n\r\nexport function indexed(source) {\r\n    const len = source.length | 0;\r\n    const target = new Array(len);\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        target[i] = [i, source[i]];\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function truncate(count, array) {\r\n    const count_1 = max_1((x, y) => comparePrimitives(x, y), 0, count) | 0;\r\n    const start = 0;\r\n    return array.slice(start, (start + count_1));\r\n}\r\n\r\nexport function concat(arrays, cons) {\r\n    const arrays_1 = Array.isArray(arrays) ? arrays : (Array.from(arrays));\r\n    const matchValue = arrays_1.length | 0;\r\n    switch (matchValue) {\r\n        case 0: {\r\n            return Helpers_allocateArrayFromCons(cons, 0);\r\n        }\r\n        case 1: {\r\n            return arrays_1[0];\r\n        }\r\n        default: {\r\n            let totalIdx = 0;\r\n            let totalLength = 0;\r\n            for (let idx = 0; idx <= (arrays_1.length - 1); idx++) {\r\n                const arr_1 = arrays_1[idx];\r\n                totalLength = ((totalLength + arr_1.length) | 0);\r\n            }\r\n            const result = Helpers_allocateArrayFromCons(cons, totalLength);\r\n            for (let idx_1 = 0; idx_1 <= (arrays_1.length - 1); idx_1++) {\r\n                const arr_2 = arrays_1[idx_1];\r\n                for (let j = 0; j <= (arr_2.length - 1); j++) {\r\n                    result[totalIdx] = arr_2[j];\r\n                    totalIdx = ((totalIdx + 1) | 0);\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nexport function collect(mapping, array, cons) {\r\n    return concat(map(mapping, array, null), cons);\r\n}\r\n\r\nexport function where(predicate, array) {\r\n    return array.filter(predicate);\r\n}\r\n\r\nexport function contains(value, array, eq) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i >= array.length) {\r\n                return false;\r\n            }\r\n            else if (eq.Equals(value, array[i])) {\r\n                return true;\r\n            }\r\n            else {\r\n                i_mut = (i + 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0);\r\n}\r\n\r\nexport function empty(cons) {\r\n    return Helpers_allocateArrayFromCons(cons, 0);\r\n}\r\n\r\nexport function singleton(value, cons) {\r\n    const ar = Helpers_allocateArrayFromCons(cons, 1);\r\n    ar[0] = value;\r\n    return ar;\r\n}\r\n\r\nexport function initialize(count, initializer, cons) {\r\n    if (count < 0) {\r\n        throw (new Error(\"The input must be non-negative\\\\nParameter name: count\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, count);\r\n    for (let i = 0; i <= (count - 1); i++) {\r\n        result[i] = initializer(i);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function pairwise(array) {\r\n    if (array.length < 2) {\r\n        return [];\r\n    }\r\n    else {\r\n        const count = (array.length - 1) | 0;\r\n        const result = new Array(count);\r\n        for (let i = 0; i <= (count - 1); i++) {\r\n            result[i] = [array[i], array[i + 1]];\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function replicate(count, initial, cons) {\r\n    if (count < 0) {\r\n        throw (new Error(\"The input must be non-negative\\\\nParameter name: count\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, count);\r\n    for (let i = 0; i <= (result.length - 1); i++) {\r\n        result[i] = initial;\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function copy(array) {\r\n    return array.slice();\r\n}\r\n\r\nexport function reverse(array) {\r\n    const array_2 = array.slice();\r\n    return array_2.reverse();\r\n}\r\n\r\nexport function scan(folder, state, array, cons) {\r\n    const res = Helpers_allocateArrayFromCons(cons, array.length + 1);\r\n    res[0] = state;\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        res[i + 1] = folder(res[i], array[i]);\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function scanBack(folder, array, state, cons) {\r\n    const res = Helpers_allocateArrayFromCons(cons, array.length + 1);\r\n    res[array.length] = state;\r\n    for (let i = array.length - 1; i >= 0; i--) {\r\n        res[i] = folder(array[i], res[i + 1]);\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function skip(count, array, cons) {\r\n    if (count > array.length) {\r\n        throw (new Error(\"count is greater than array length\\\\nParameter name: count\"));\r\n    }\r\n    if (count === array.length) {\r\n        return Helpers_allocateArrayFromCons(cons, 0);\r\n    }\r\n    else {\r\n        const count_1 = ((count < 0) ? 0 : count) | 0;\r\n        return array.slice(count_1);\r\n    }\r\n}\r\n\r\nexport function skipWhile(predicate, array, cons) {\r\n    let count = 0;\r\n    while ((count < array.length) ? predicate(array[count]) : false) {\r\n        count = ((count + 1) | 0);\r\n    }\r\n    if (count === array.length) {\r\n        return Helpers_allocateArrayFromCons(cons, 0);\r\n    }\r\n    else {\r\n        const count_1 = count | 0;\r\n        return array.slice(count_1);\r\n    }\r\n}\r\n\r\nexport function take(count, array, cons) {\r\n    if (count < 0) {\r\n        throw (new Error(\"The input must be non-negative\\\\nParameter name: count\"));\r\n    }\r\n    if (count > array.length) {\r\n        throw (new Error(\"count is greater than array length\\\\nParameter name: count\"));\r\n    }\r\n    if (count === 0) {\r\n        return Helpers_allocateArrayFromCons(cons, 0);\r\n    }\r\n    else {\r\n        const start = 0;\r\n        return array.slice(start, (start + count));\r\n    }\r\n}\r\n\r\nexport function takeWhile(predicate, array, cons) {\r\n    let count = 0;\r\n    while ((count < array.length) ? predicate(array[count]) : false) {\r\n        count = ((count + 1) | 0);\r\n    }\r\n    if (count === 0) {\r\n        return Helpers_allocateArrayFromCons(cons, 0);\r\n    }\r\n    else {\r\n        const start = 0;\r\n        const count_1 = count | 0;\r\n        return array.slice(start, (start + count_1));\r\n    }\r\n}\r\n\r\nexport function addInPlace(x, array) {\r\n    void (array.push(x));\r\n}\r\n\r\nexport function addRangeInPlace(range, array) {\r\n    const enumerator = getEnumerator(range);\r\n    try {\r\n        while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            addInPlace(enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), array);\r\n        }\r\n    }\r\n    finally {\r\n        enumerator.Dispose();\r\n    }\r\n}\r\n\r\nexport function insertRangeInPlace(index, range, array) {\r\n    let index_1;\r\n    let i = index;\r\n    const enumerator = getEnumerator(range);\r\n    try {\r\n        while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            const x = enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n            void ((index_1 = (i | 0), array.splice(index_1, 0, x)));\r\n            i = ((i + 1) | 0);\r\n        }\r\n    }\r\n    finally {\r\n        enumerator.Dispose();\r\n    }\r\n}\r\n\r\nexport function removeInPlace(item_1, array) {\r\n    const i = array.indexOf(item_1, 0);\r\n    if (i > -1) {\r\n        void (array.splice(i, 1));\r\n        return true;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function removeAllInPlace(predicate, array) {\r\n    const countRemoveAll = (count) => {\r\n        const i = array.findIndex(predicate);\r\n        if (i > -1) {\r\n            void (array.splice(i, 1));\r\n            return (countRemoveAll(count) + 1) | 0;\r\n        }\r\n        else {\r\n            return count | 0;\r\n        }\r\n    };\r\n    return countRemoveAll(0) | 0;\r\n}\r\n\r\nexport function copyTo(source, sourceIndex, target, targetIndex, count) {\r\n    const diff = (targetIndex - sourceIndex) | 0;\r\n    for (let i = sourceIndex; i <= ((sourceIndex + count) - 1); i++) {\r\n        target[i + diff] = source[i];\r\n    }\r\n}\r\n\r\nexport function copyToTypedArray(source, sourceIndex, target, targetIndex, count) {\r\n    try {\r\n        target.set(source.subarray(sourceIndex, sourceIndex + count), targetIndex);\r\n    }\r\n    catch (matchValue) {\r\n        copyTo(source, sourceIndex, target, targetIndex, count);\r\n    }\r\n}\r\n\r\nexport function indexOf(array, item_1, start, count) {\r\n    const start_1 = defaultArg(start, 0) | 0;\r\n    const i = array.indexOf(item_1, start_1);\r\n    if ((count != null) ? (i >= (start_1 + value_2(count))) : false) {\r\n        return -1;\r\n    }\r\n    else {\r\n        return i | 0;\r\n    }\r\n}\r\n\r\nexport function partition(f, source, cons) {\r\n    const len = source.length | 0;\r\n    const res1 = Helpers_allocateArrayFromCons(cons, len);\r\n    const res2 = Helpers_allocateArrayFromCons(cons, len);\r\n    let iTrue = 0;\r\n    let iFalse = 0;\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        if (f(source[i])) {\r\n            res1[iTrue] = source[i];\r\n            iTrue = ((iTrue + 1) | 0);\r\n        }\r\n        else {\r\n            res2[iFalse] = source[i];\r\n            iFalse = ((iFalse + 1) | 0);\r\n        }\r\n    }\r\n    return [truncate(iTrue, res1), truncate(iFalse, res2)];\r\n}\r\n\r\nexport function find(predicate, array) {\r\n    const matchValue = array.find(predicate);\r\n    if (matchValue == null) {\r\n        return indexNotFound();\r\n    }\r\n    else {\r\n        return value_2(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFind(predicate, array) {\r\n    return array.find(predicate);\r\n}\r\n\r\nexport function findIndex(predicate, array) {\r\n    const matchValue = array.findIndex(predicate);\r\n    if (matchValue > -1) {\r\n        return matchValue | 0;\r\n    }\r\n    else {\r\n        return indexNotFound() | 0;\r\n    }\r\n}\r\n\r\nexport function tryFindIndex(predicate, array) {\r\n    const matchValue = array.findIndex(predicate);\r\n    if (matchValue > -1) {\r\n        return matchValue;\r\n    }\r\n    else {\r\n        return void 0;\r\n    }\r\n}\r\n\r\nexport function pick(chooser, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i >= array.length) {\r\n                return indexNotFound();\r\n            }\r\n            else {\r\n                const matchValue = chooser(array[i]);\r\n                if (matchValue != null) {\r\n                    return value_2(matchValue);\r\n                }\r\n                else {\r\n                    i_mut = (i + 1);\r\n                    continue loop;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0);\r\n}\r\n\r\nexport function tryPick(chooser, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i >= array.length) {\r\n                return void 0;\r\n            }\r\n            else {\r\n                const matchValue = chooser(array[i]);\r\n                if (matchValue == null) {\r\n                    i_mut = (i + 1);\r\n                    continue loop;\r\n                }\r\n                else {\r\n                    return matchValue;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0);\r\n}\r\n\r\nexport function findBack(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return indexNotFound();\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return array[i];\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1);\r\n}\r\n\r\nexport function tryFindBack(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return void 0;\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return some(array[i]);\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1);\r\n}\r\n\r\nexport function findLastIndex(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return -1;\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return i | 0;\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1) | 0;\r\n}\r\n\r\nexport function findIndexBack(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return indexNotFound() | 0;\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return i | 0;\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1) | 0;\r\n}\r\n\r\nexport function tryFindIndexBack(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return void 0;\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return i;\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1);\r\n}\r\n\r\nexport function choose(chooser, array, cons) {\r\n    const res = [];\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        const matchValue = chooser(array[i]);\r\n        if (matchValue != null) {\r\n            const y = value_2(matchValue);\r\n            void (res.push(y));\r\n        }\r\n    }\r\n    if ((typeof cons) === \"function\") {\r\n        return map((x) => x, res, cons);\r\n    }\r\n    else {\r\n        return res;\r\n    }\r\n}\r\n\r\nexport function foldIndexed(folder, state, array) {\r\n    return array.reduce(((delegateArg0, delegateArg1, delegateArg2) => folder(delegateArg2, delegateArg0, delegateArg1)), state);\r\n}\r\n\r\nexport function fold(folder, state, array) {\r\n    return array.reduce(((delegateArg0, delegateArg1) => folder(delegateArg0, delegateArg1)), state);\r\n}\r\n\r\nexport function iterate(action, array) {\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        action(array[i]);\r\n    }\r\n}\r\n\r\nexport function iterateIndexed(action, array) {\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        action(i, array[i]);\r\n    }\r\n}\r\n\r\nexport function iterate2(action, array1, array2) {\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        action(array1[i], array2[i]);\r\n    }\r\n}\r\n\r\nexport function iterateIndexed2(action, array1, array2) {\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        action(i, array1[i], array2[i]);\r\n    }\r\n}\r\n\r\nexport function isEmpty(array) {\r\n    return array.length === 0;\r\n}\r\n\r\nexport function forAll(predicate, array) {\r\n    return array.every(predicate);\r\n}\r\n\r\nexport function permute(f, array) {\r\n    const size = array.length | 0;\r\n    const res = array.slice();\r\n    const checkFlags = new Array(size);\r\n    iterateIndexed((i, x) => {\r\n        const j = f(i) | 0;\r\n        if ((j < 0) ? true : (j >= size)) {\r\n            throw (new Error(\"Not a valid permutation\"));\r\n        }\r\n        res[j] = x;\r\n        checkFlags[j] = 1;\r\n    }, array);\r\n    if (!(checkFlags.every(((y) => (1 === y))))) {\r\n        throw (new Error(\"Not a valid permutation\"));\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function setSlice(target, lower, upper, source) {\r\n    const lower_1 = defaultArg(lower, 0) | 0;\r\n    const upper_1 = defaultArg(upper, 0) | 0;\r\n    const length = (((upper_1 > 0) ? upper_1 : (target.length - 1)) - lower_1) | 0;\r\n    for (let i = 0; i <= length; i++) {\r\n        target[i + lower_1] = source[i];\r\n    }\r\n}\r\n\r\nexport function sortInPlaceBy(projection, xs, comparer) {\r\n    xs.sort(((x, y) => comparer.Compare(projection(x), projection(y))));\r\n}\r\n\r\nexport function sortInPlace(xs, comparer) {\r\n    xs.sort(((x, y) => comparer.Compare(x, y)));\r\n}\r\n\r\nexport function sort(xs, comparer) {\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort(((x, y) => comparer.Compare(x, y)));\r\n    return xs_1;\r\n}\r\n\r\nexport function sortBy(projection, xs, comparer) {\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort(((x, y) => comparer.Compare(projection(x), projection(y))));\r\n    return xs_1;\r\n}\r\n\r\nexport function sortDescending(xs, comparer) {\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort(((x, y) => (comparer.Compare(x, y) * -1)));\r\n    return xs_1;\r\n}\r\n\r\nexport function sortByDescending(projection, xs, comparer) {\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort(((x, y) => (comparer.Compare(projection(x), projection(y)) * -1)));\r\n    return xs_1;\r\n}\r\n\r\nexport function sortWith(comparer, xs) {\r\n    const comparer_1 = comparer;\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort(comparer_1);\r\n    return xs_1;\r\n}\r\n\r\nexport function allPairs(xs, ys) {\r\n    const len1 = xs.length | 0;\r\n    const len2 = ys.length | 0;\r\n    const res = new Array((len1 * len2));\r\n    for (let i = 0; i <= (xs.length - 1); i++) {\r\n        for (let j = 0; j <= (ys.length - 1); j++) {\r\n            res[(i * len2) + j] = [xs[i], ys[j]];\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function unfold(generator, state) {\r\n    const res = [];\r\n    const loop = (state_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const state_1 = state_1_mut;\r\n            const matchValue = generator(state_1);\r\n            if (matchValue != null) {\r\n                const x = matchValue[0];\r\n                const s = matchValue[1];\r\n                void (res.push(x));\r\n                state_1_mut = s;\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    loop(state);\r\n    return res;\r\n}\r\n\r\nexport function unzip(array) {\r\n    const len = array.length | 0;\r\n    const res1 = new Array(len);\r\n    const res2 = new Array(len);\r\n    iterateIndexed((i, tupledArg) => {\r\n        res1[i] = tupledArg[0];\r\n        res2[i] = tupledArg[1];\r\n    }, array);\r\n    return [res1, res2];\r\n}\r\n\r\nexport function unzip3(array) {\r\n    const len = array.length | 0;\r\n    const res1 = new Array(len);\r\n    const res2 = new Array(len);\r\n    const res3 = new Array(len);\r\n    iterateIndexed((i, tupledArg) => {\r\n        res1[i] = tupledArg[0];\r\n        res2[i] = tupledArg[1];\r\n        res3[i] = tupledArg[2];\r\n    }, array);\r\n    return [res1, res2, res3];\r\n}\r\n\r\nexport function zip(array1, array2) {\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    const result = new Array(array1.length);\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        result[i] = [array1[i], array2[i]];\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function zip3(array1, array2, array3) {\r\n    if ((array1.length !== array2.length) ? true : (array2.length !== array3.length)) {\r\n        differentLengths();\r\n    }\r\n    const result = new Array(array1.length);\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        result[i] = [array1[i], array2[i], array3[i]];\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function chunkBySize(chunkSize, array) {\r\n    if (chunkSize < 1) {\r\n        throw (new Error(\"The input must be positive.\\\\nParameter name: size\"));\r\n    }\r\n    if (array.length === 0) {\r\n        return [[]];\r\n    }\r\n    else {\r\n        const result = [];\r\n        for (let x = 0; x <= ((~(~Math.ceil(array.length / chunkSize))) - 1); x++) {\r\n            let slice;\r\n            const start_1 = (x * chunkSize) | 0;\r\n            slice = (array.slice(start_1, (start_1 + chunkSize)));\r\n            void (result.push(slice));\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function splitAt(index, array) {\r\n    let start;\r\n    if (index < 0) {\r\n        throw (new Error(\"The input must be non-negative\\\\nParameter name: index\"));\r\n    }\r\n    if (index > array.length) {\r\n        throw (new Error(\"The input sequence has an insufficient number of elements.\\\\nParameter name: index\"));\r\n    }\r\n    return [(start = 0, array.slice(start, (start + index))), array.slice(index)];\r\n}\r\n\r\nexport function compareWith(comparer, array1, array2) {\r\n    if (array1 == null) {\r\n        if (array2 == null) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n    else if (array2 == null) {\r\n        return 1;\r\n    }\r\n    else {\r\n        let i = 0;\r\n        let result = 0;\r\n        const length1 = array1.length | 0;\r\n        const length2 = array2.length | 0;\r\n        if (length1 > length2) {\r\n            return 1;\r\n        }\r\n        else if (length1 < length2) {\r\n            return -1;\r\n        }\r\n        else {\r\n            while ((i < length1) ? (result === 0) : false) {\r\n                result = (comparer(array1[i], array2[i]) | 0);\r\n                i = ((i + 1) | 0);\r\n            }\r\n            return result | 0;\r\n        }\r\n    }\r\n}\r\n\r\nexport function equalsWith(comparer, array1, array2) {\r\n    return compareWith((e1, e2) => compare(e1, e2), array1, array2) === 0;\r\n}\r\n\r\nexport function exactlyOne(array) {\r\n    if (array.length === 1) {\r\n        return array[0];\r\n    }\r\n    else if (array.length === 0) {\r\n        throw (new Error(\"The input sequence was empty\\\\nParameter name: array\"));\r\n    }\r\n    else {\r\n        throw (new Error(\"Input array too long\\\\nParameter name: array\"));\r\n    }\r\n}\r\n\r\nexport function tryExactlyOne(array) {\r\n    if (array.length === 1) {\r\n        return some(array[0]);\r\n    }\r\n    else {\r\n        return void 0;\r\n    }\r\n}\r\n\r\nexport function head(array) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\\\\nParameter name: array\"));\r\n    }\r\n    else {\r\n        return array[0];\r\n    }\r\n}\r\n\r\nexport function tryHead(array) {\r\n    if (array.length === 0) {\r\n        return void 0;\r\n    }\r\n    else {\r\n        return some(array[0]);\r\n    }\r\n}\r\n\r\nexport function tail(array) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"Not enough elements\\\\nParameter name: array\"));\r\n    }\r\n    return array.slice(1);\r\n}\r\n\r\nexport function item(index, array) {\r\n    return array[index];\r\n}\r\n\r\nexport function tryItem(index, array) {\r\n    if ((index < 0) ? true : (index >= array.length)) {\r\n        return void 0;\r\n    }\r\n    else {\r\n        return some(array[index]);\r\n    }\r\n}\r\n\r\nexport function foldBackIndexed(folder, array, state) {\r\n    return array.reduceRight(((delegateArg0, delegateArg1, delegateArg2) => folder(delegateArg2, delegateArg1, delegateArg0)), state);\r\n}\r\n\r\nexport function foldBack(folder, array, state) {\r\n    return array.reduceRight(((delegateArg0, delegateArg1) => folder(delegateArg1, delegateArg0)), state);\r\n}\r\n\r\nexport function foldIndexed2(folder, state, array1, array2) {\r\n    let acc = state;\r\n    if (array1.length !== array2.length) {\r\n        throw (new Error(\"Arrays have different lengths\"));\r\n    }\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        acc = folder(i, acc, array1[i], array2[i]);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function fold2(folder, state, array1, array2) {\r\n    return foldIndexed2((_arg1, acc, x, y) => folder(acc, x, y), state, array1, array2);\r\n}\r\n\r\nexport function foldBackIndexed2(folder, array1, array2, state) {\r\n    let acc = state;\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    const size = array1.length | 0;\r\n    for (let i = 1; i <= size; i++) {\r\n        acc = folder(i - 1, array1[size - i], array2[size - i], acc);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function foldBack2(f, array1, array2, state) {\r\n    return foldBackIndexed2((_arg1, x, y, acc) => f(x, y, acc), array1, array2, state);\r\n}\r\n\r\nexport function reduce(reduction, array) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\"));\r\n    }\r\n    const reduction_1 = reduction;\r\n    return array.reduce(reduction_1);\r\n}\r\n\r\nexport function reduceBack(reduction, array) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\"));\r\n    }\r\n    const reduction_1 = reduction;\r\n    return array.reduceRight(reduction_1);\r\n}\r\n\r\nexport function forAll2(predicate, array1, array2) {\r\n    return fold2((acc, x, y) => (acc ? predicate(x, y) : false), true, array1, array2);\r\n}\r\n\r\nexport function existsOffset(predicate_mut, array_mut, index_mut) {\r\n    existsOffset:\r\n    while (true) {\r\n        const predicate = predicate_mut, array = array_mut, index = index_mut;\r\n        if (index === array.length) {\r\n            return false;\r\n        }\r\n        else if (predicate(array[index])) {\r\n            return true;\r\n        }\r\n        else {\r\n            predicate_mut = predicate;\r\n            array_mut = array;\r\n            index_mut = (index + 1);\r\n            continue existsOffset;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function exists(predicate, array) {\r\n    return existsOffset(predicate, array, 0);\r\n}\r\n\r\nexport function existsOffset2(predicate_mut, array1_mut, array2_mut, index_mut) {\r\n    existsOffset2:\r\n    while (true) {\r\n        const predicate = predicate_mut, array1 = array1_mut, array2 = array2_mut, index = index_mut;\r\n        if (index === array1.length) {\r\n            return false;\r\n        }\r\n        else if (predicate(array1[index], array2[index])) {\r\n            return true;\r\n        }\r\n        else {\r\n            predicate_mut = predicate;\r\n            array1_mut = array1;\r\n            array2_mut = array2;\r\n            index_mut = (index + 1);\r\n            continue existsOffset2;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function exists2(predicate, array1, array2) {\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    return existsOffset2(predicate, array1, array2, 0);\r\n}\r\n\r\nexport function sum(array, adder) {\r\n    let acc = adder.GetZero();\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        acc = adder.Add(acc, array[i]);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function sumBy(projection, array, adder) {\r\n    let acc = adder.GetZero();\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        acc = adder.Add(acc, projection(array[i]));\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function maxBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function max(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function minBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function min(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function average(array, averager) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\\\\nParameter name: array\"));\r\n    }\r\n    let total = averager.GetZero();\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        total = averager.Add(total, array[i]);\r\n    }\r\n    return averager.DivideByInt(total, array.length);\r\n}\r\n\r\nexport function averageBy(projection, array, averager) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\\\\nParameter name: array\"));\r\n    }\r\n    let total = averager.GetZero();\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        total = averager.Add(total, projection(array[i]));\r\n    }\r\n    return averager.DivideByInt(total, array.length);\r\n}\r\n\r\nexport function windowed(windowSize, source) {\r\n    if (windowSize <= 0) {\r\n        throw (new Error(\"windowSize must be positive\"));\r\n    }\r\n    let res;\r\n    const len = max_1((x, y) => comparePrimitives(x, y), 0, source.length - windowSize) | 0;\r\n    res = (new Array(len));\r\n    for (let i = windowSize; i <= source.length; i++) {\r\n        res[i - windowSize] = source.slice(i - windowSize, (i - 1) + 1);\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function splitInto(chunks, array) {\r\n    if (chunks < 1) {\r\n        throw (new Error(\"The input must be positive.\\\\nParameter name: chunks\"));\r\n    }\r\n    if (array.length === 0) {\r\n        return [[]];\r\n    }\r\n    else {\r\n        const result = [];\r\n        const chunks_1 = min_1((x, y) => comparePrimitives(x, y), chunks, array.length) | 0;\r\n        const minChunkSize = (~(~(array.length / chunks_1))) | 0;\r\n        const chunksWithExtraItem = (array.length % chunks_1) | 0;\r\n        for (let i = 0; i <= (chunks_1 - 1); i++) {\r\n            const chunkSize = ((i < chunksWithExtraItem) ? (minChunkSize + 1) : minChunkSize) | 0;\r\n            let slice;\r\n            const start_1 = ((i * minChunkSize) + min_1((x_1, y_1) => comparePrimitives(x_1, y_1), chunksWithExtraItem, i)) | 0;\r\n            slice = (array.slice(start_1, (start_1 + chunkSize)));\r\n            void (result.push(slice));\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function transpose(arrays, cons) {\r\n    const arrays_1 = Array.isArray(arrays) ? arrays : (Array.from(arrays));\r\n    const len = arrays_1.length | 0;\r\n    if (len === 0) {\r\n        return new Array(0);\r\n    }\r\n    else {\r\n        const lenInner = arrays_1[0].length | 0;\r\n        if (!forAll((a) => (a.length === lenInner), arrays_1)) {\r\n            differentLengths();\r\n        }\r\n        const result = new Array(lenInner);\r\n        for (let i = 0; i <= (lenInner - 1); i++) {\r\n            result[i] = Helpers_allocateArrayFromCons(cons, len);\r\n            for (let j = 0; j <= (len - 1); j++) {\r\n                result[i][j] = arrays_1[j][i];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n","import { join } from \"./String.js\";\r\nimport { uncurry, isArrayLike, getEnumerator, toIterator, compare, structuralHash, equals } from \"./Util.js\";\r\nimport { Record } from \"./Types.js\";\r\nimport { class_type, record_type, option_type } from \"./Reflection.js\";\r\nimport { defaultArg, value as value_1, some } from \"./Option.js\";\r\nimport { transpose as transpose_1, splitInto as splitInto_1, windowed as windowed_1, pairwise as pairwise_1, chunkBySize as chunkBySize_1, map as map_1, permute as permute_1, tryFindIndexBack as tryFindIndexBack_1, tryFindBack as tryFindBack_1, scanBack as scanBack_1, foldBack2 as foldBack2_1, foldBack as foldBack_1, fill } from \"./Array.js\";\r\n\r\nexport const SR_indexOutOfBounds = \"The index was outside the range of elements in the list.\";\r\n\r\nexport const SR_inputListWasEmpty = \"List was empty\";\r\n\r\nexport const SR_inputMustBeNonNegative = \"The input must be non-negative.\";\r\n\r\nexport const SR_inputSequenceEmpty = \"The input sequence was empty.\";\r\n\r\nexport const SR_inputSequenceTooLong = \"The input sequence contains more than one element.\";\r\n\r\nexport const SR_keyNotFoundAlt = \"An index satisfying the predicate was not found in the collection.\";\r\n\r\nexport const SR_listsHadDifferentLengths = \"The lists had different lengths.\";\r\n\r\nexport const SR_notEnoughElements = \"The input sequence has an insufficient number of elements.\";\r\n\r\nexport class FSharpList extends Record {\r\n    constructor(head, tail) {\r\n        super();\r\n        this.head = head;\r\n        this.tail = tail;\r\n    }\r\n    toString() {\r\n        const xs = this;\r\n        return (\"[\" + join(\"; \", xs)) + \"]\";\r\n    }\r\n    Equals(other) {\r\n        const xs = this;\r\n        if (xs === other) {\r\n            return true;\r\n        }\r\n        else {\r\n            const loop = (xs_1_mut, ys_1_mut) => {\r\n                loop:\r\n                while (true) {\r\n                    const xs_1 = xs_1_mut, ys_1 = ys_1_mut;\r\n                    const matchValue = [xs_1.tail, ys_1.tail];\r\n                    if (matchValue[0] != null) {\r\n                        if (matchValue[1] != null) {\r\n                            const xt = matchValue[0];\r\n                            const yt = matchValue[1];\r\n                            if (equals(xs_1.head, ys_1.head)) {\r\n                                xs_1_mut = xt;\r\n                                ys_1_mut = yt;\r\n                                continue loop;\r\n                            }\r\n                            else {\r\n                                return false;\r\n                            }\r\n                        }\r\n                        else {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    else if (matchValue[1] != null) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        return true;\r\n                    }\r\n                    break;\r\n                }\r\n            };\r\n            return loop(xs, other);\r\n        }\r\n    }\r\n    GetHashCode() {\r\n        const xs = this;\r\n        const loop = (i_mut, h_mut, xs_1_mut) => {\r\n            loop:\r\n            while (true) {\r\n                const i = i_mut, h = h_mut, xs_1 = xs_1_mut;\r\n                const matchValue = xs_1.tail;\r\n                if (matchValue != null) {\r\n                    const t = matchValue;\r\n                    if (i > 18) {\r\n                        return h | 0;\r\n                    }\r\n                    else {\r\n                        i_mut = (i + 1);\r\n                        h_mut = (((h << 1) + structuralHash(xs_1.head)) + (631 * i));\r\n                        xs_1_mut = t;\r\n                        continue loop;\r\n                    }\r\n                }\r\n                else {\r\n                    return h | 0;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return loop(0, 0, xs) | 0;\r\n    }\r\n    toJSON(_key) {\r\n        const this$ = this;\r\n        return Array.from(this$);\r\n    }\r\n    CompareTo(other) {\r\n        const xs = this;\r\n        const loop = (xs_1_mut, ys_1_mut) => {\r\n            loop:\r\n            while (true) {\r\n                const xs_1 = xs_1_mut, ys_1 = ys_1_mut;\r\n                const matchValue = [xs_1.tail, ys_1.tail];\r\n                if (matchValue[0] != null) {\r\n                    if (matchValue[1] != null) {\r\n                        const xt = matchValue[0];\r\n                        const yt = matchValue[1];\r\n                        const c = compare(xs_1.head, ys_1.head) | 0;\r\n                        if (c === 0) {\r\n                            xs_1_mut = xt;\r\n                            ys_1_mut = yt;\r\n                            continue loop;\r\n                        }\r\n                        else {\r\n                            return c | 0;\r\n                        }\r\n                    }\r\n                    else {\r\n                        return 1;\r\n                    }\r\n                }\r\n                else if (matchValue[1] != null) {\r\n                    return -1;\r\n                }\r\n                else {\r\n                    return 0;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return loop(xs, other) | 0;\r\n    }\r\n    GetEnumerator() {\r\n        const xs = this;\r\n        return ListEnumerator$1_$ctor_3002E699(xs);\r\n    }\r\n    [Symbol.iterator]() {\r\n        return toIterator(this.GetEnumerator());\r\n    }\r\n    [\"System.Collections.IEnumerable.GetEnumerator\"]() {\r\n        const xs = this;\r\n        return getEnumerator(xs);\r\n    }\r\n}\r\n\r\nexport function FSharpList$reflection(gen0) {\r\n    return record_type(\"ListModule.FSharpList\", [gen0], FSharpList, () => [[\"head\", gen0], [\"tail\", option_type(FSharpList$reflection(gen0))]]);\r\n}\r\n\r\nexport class ListEnumerator$1 {\r\n    constructor(xs) {\r\n        this.xs = xs;\r\n        this.it = this.xs;\r\n        this.current = null;\r\n    }\r\n    [\"System.Collections.Generic.IEnumerator`1.get_Current\"]() {\r\n        const __ = this;\r\n        return __.current;\r\n    }\r\n    [\"System.Collections.IEnumerator.get_Current\"]() {\r\n        const __ = this;\r\n        return __.current;\r\n    }\r\n    [\"System.Collections.IEnumerator.MoveNext\"]() {\r\n        const __ = this;\r\n        const matchValue = __.it.tail;\r\n        if (matchValue != null) {\r\n            const t = matchValue;\r\n            __.current = __.it.head;\r\n            __.it = t;\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    [\"System.Collections.IEnumerator.Reset\"]() {\r\n        const __ = this;\r\n        __.it = __.xs;\r\n        __.current = null;\r\n    }\r\n    Dispose() {\r\n    }\r\n}\r\n\r\nexport function ListEnumerator$1$reflection(gen0) {\r\n    return class_type(\"ListModule.ListEnumerator`1\", [gen0], ListEnumerator$1);\r\n}\r\n\r\nexport function ListEnumerator$1_$ctor_3002E699(xs) {\r\n    return new ListEnumerator$1(xs);\r\n}\r\n\r\nexport function FSharpList_get_Empty() {\r\n    return new FSharpList(null, void 0);\r\n}\r\n\r\nexport function FSharpList_Cons_305B8EAC(x, xs) {\r\n    return new FSharpList(x, xs);\r\n}\r\n\r\nexport function FSharpList__get_IsEmpty(xs) {\r\n    return xs.tail == null;\r\n}\r\n\r\nexport function FSharpList__get_Length(xs) {\r\n    const loop = (i_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, xs_1 = xs_1_mut;\r\n            const matchValue = xs_1.tail;\r\n            if (matchValue != null) {\r\n                i_mut = (i + 1);\r\n                xs_1_mut = matchValue;\r\n                continue loop;\r\n            }\r\n            else {\r\n                return i | 0;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0, xs) | 0;\r\n}\r\n\r\nexport function FSharpList__get_Head(xs) {\r\n    const matchValue = xs.tail;\r\n    if (matchValue != null) {\r\n        return xs.head;\r\n    }\r\n    else {\r\n        throw (new Error((SR_inputListWasEmpty + \"\\\\nParameter name: \") + \"list\"));\r\n    }\r\n}\r\n\r\nexport function FSharpList__get_Tail(xs) {\r\n    const matchValue = xs.tail;\r\n    if (matchValue != null) {\r\n        return matchValue;\r\n    }\r\n    else {\r\n        throw (new Error((SR_inputListWasEmpty + \"\\\\nParameter name: \") + \"list\"));\r\n    }\r\n}\r\n\r\nexport function FSharpList__get_Item_Z524259A4(xs, index) {\r\n    const loop = (i_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, xs_1 = xs_1_mut;\r\n            const matchValue = xs_1.tail;\r\n            if (matchValue != null) {\r\n                if (i === index) {\r\n                    return xs_1.head;\r\n                }\r\n                else {\r\n                    i_mut = (i + 1);\r\n                    xs_1_mut = matchValue;\r\n                    continue loop;\r\n                }\r\n            }\r\n            else {\r\n                throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0, xs);\r\n}\r\n\r\nexport function empty() {\r\n    return FSharpList_get_Empty();\r\n}\r\n\r\nexport function cons(x, xs) {\r\n    return FSharpList_Cons_305B8EAC(x, xs);\r\n}\r\n\r\nexport function singleton(x) {\r\n    return FSharpList_Cons_305B8EAC(x, FSharpList_get_Empty());\r\n}\r\n\r\nexport function isEmpty(xs) {\r\n    return FSharpList__get_IsEmpty(xs);\r\n}\r\n\r\nexport function length(xs) {\r\n    return FSharpList__get_Length(xs);\r\n}\r\n\r\nexport function head(xs) {\r\n    return FSharpList__get_Head(xs);\r\n}\r\n\r\nexport function tryHead(xs) {\r\n    if (FSharpList__get_IsEmpty(xs)) {\r\n        return void 0;\r\n    }\r\n    else {\r\n        return some(FSharpList__get_Head(xs));\r\n    }\r\n}\r\n\r\nexport function tail(xs) {\r\n    return FSharpList__get_Tail(xs);\r\n}\r\n\r\nexport function tryLast(xs_mut) {\r\n    tryLast:\r\n    while (true) {\r\n        const xs = xs_mut;\r\n        if (FSharpList__get_IsEmpty(xs)) {\r\n            return void 0;\r\n        }\r\n        else {\r\n            const t = FSharpList__get_Tail(xs);\r\n            if (FSharpList__get_IsEmpty(t)) {\r\n                return some(FSharpList__get_Head(xs));\r\n            }\r\n            else {\r\n                xs_mut = t;\r\n                continue tryLast;\r\n            }\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function last(xs) {\r\n    const matchValue = tryLast(xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_inputListWasEmpty));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function compareWith(comparer, xs, ys) {\r\n    const loop = (xs_1_mut, ys_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const xs_1 = xs_1_mut, ys_1 = ys_1_mut;\r\n            const matchValue = [FSharpList__get_IsEmpty(xs_1), FSharpList__get_IsEmpty(ys_1)];\r\n            if (matchValue[0]) {\r\n                if (matchValue[1]) {\r\n                    return 0;\r\n                }\r\n                else {\r\n                    return -1;\r\n                }\r\n            }\r\n            else if (matchValue[1]) {\r\n                return 1;\r\n            }\r\n            else {\r\n                const c = comparer(FSharpList__get_Head(xs_1), FSharpList__get_Head(ys_1)) | 0;\r\n                if (c === 0) {\r\n                    xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                    ys_1_mut = FSharpList__get_Tail(ys_1);\r\n                    continue loop;\r\n                }\r\n                else {\r\n                    return c | 0;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(xs, ys) | 0;\r\n}\r\n\r\nexport function toArray(xs) {\r\n    const len = FSharpList__get_Length(xs) | 0;\r\n    const res = fill(new Array(len), 0, len, null);\r\n    const loop = (i_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, xs_1 = xs_1_mut;\r\n            if (!FSharpList__get_IsEmpty(xs_1)) {\r\n                res[i] = FSharpList__get_Head(xs_1);\r\n                i_mut = (i + 1);\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    loop(0, xs);\r\n    return res;\r\n}\r\n\r\nexport function fold(folder, state, xs) {\r\n    let acc = state;\r\n    let xs_1 = xs;\r\n    while (!FSharpList__get_IsEmpty(xs_1)) {\r\n        acc = folder(acc, FSharpList__get_Head(xs_1));\r\n        xs_1 = FSharpList__get_Tail(xs_1);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function reverse(xs) {\r\n    return fold((acc, x) => FSharpList_Cons_305B8EAC(x, acc), FSharpList_get_Empty(), xs);\r\n}\r\n\r\nexport function foldBack(folder, xs, state) {\r\n    return foldBack_1(folder, toArray(xs), state);\r\n}\r\n\r\nexport function foldIndexed(folder, state, xs) {\r\n    const loop = (i_mut, acc_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, acc = acc_mut, xs_1 = xs_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return acc;\r\n            }\r\n            else {\r\n                i_mut = (i + 1);\r\n                acc_mut = folder(i, acc, FSharpList__get_Head(xs_1));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0, state, xs);\r\n}\r\n\r\nexport function fold2(folder, state, xs, ys) {\r\n    let acc = state;\r\n    let xs_1 = xs;\r\n    let ys_1 = ys;\r\n    while ((!FSharpList__get_IsEmpty(xs_1)) ? (!FSharpList__get_IsEmpty(ys_1)) : false) {\r\n        acc = folder(acc, FSharpList__get_Head(xs_1), FSharpList__get_Head(ys_1));\r\n        xs_1 = FSharpList__get_Tail(xs_1);\r\n        ys_1 = FSharpList__get_Tail(ys_1);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function foldBack2(folder, xs, ys, state) {\r\n    return foldBack2_1(folder, toArray(xs), toArray(ys), state);\r\n}\r\n\r\nexport function unfold(gen, state) {\r\n    const loop = (acc_mut, node_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const acc = acc_mut, node = node_mut;\r\n            const matchValue = gen(acc);\r\n            if (matchValue != null) {\r\n                acc_mut = matchValue[1];\r\n                node_mut = ((t = (new FSharpList(matchValue[0], void 0)), (node.tail = t, t)));\r\n                continue loop;\r\n            }\r\n            else {\r\n                return node;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node_1 = loop(state, root);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node_1.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function iterate(action, xs) {\r\n    fold((unitVar0, x) => {\r\n        action(x);\r\n    }, void 0, xs);\r\n}\r\n\r\nexport function iterate2(action, xs, ys) {\r\n    fold2((unitVar0, x, y) => {\r\n        action(x, y);\r\n    }, void 0, xs, ys);\r\n}\r\n\r\nexport function iterateIndexed(action, xs) {\r\n    void fold((i, x) => {\r\n        action(i, x);\r\n        return (i + 1) | 0;\r\n    }, 0, xs);\r\n}\r\n\r\nexport function iterateIndexed2(action, xs, ys) {\r\n    void fold2((i, x, y) => {\r\n        action(i, x, y);\r\n        return (i + 1) | 0;\r\n    }, 0, xs, ys);\r\n}\r\n\r\nexport function toSeq(xs) {\r\n    return xs;\r\n}\r\n\r\nexport function ofArrayWithTail(xs, tail_1) {\r\n    let res = tail_1;\r\n    for (let i = xs.length - 1; i >= 0; i--) {\r\n        res = FSharpList_Cons_305B8EAC(xs[i], res);\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function ofArray(xs) {\r\n    return ofArrayWithTail(xs, FSharpList_get_Empty());\r\n}\r\n\r\nexport function ofSeq(xs) {\r\n    let xs_3, t;\r\n    if (isArrayLike(xs)) {\r\n        return ofArray(xs);\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return xs;\r\n    }\r\n    else {\r\n        const root = FSharpList_get_Empty();\r\n        let node = root;\r\n        const enumerator = getEnumerator(xs);\r\n        try {\r\n            while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                const x = enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n                node = ((xs_3 = node, (t = (new FSharpList(x, void 0)), (xs_3.tail = t, t))));\r\n            }\r\n        }\r\n        finally {\r\n            enumerator.Dispose();\r\n        }\r\n        const xs_5 = node;\r\n        const t_2 = FSharpList_get_Empty();\r\n        xs_5.tail = t_2;\r\n        return FSharpList__get_Tail(root);\r\n    }\r\n}\r\n\r\nexport function concat(lists) {\r\n    const root = FSharpList_get_Empty();\r\n    let node = root;\r\n    const action = (xs) => {\r\n        node = fold((acc, x) => {\r\n            const t = new FSharpList(x, void 0);\r\n            acc.tail = t;\r\n            return t;\r\n        }, node, xs);\r\n    };\r\n    if (isArrayLike(lists)) {\r\n        lists.forEach(action);\r\n    }\r\n    else if (lists instanceof FSharpList) {\r\n        iterate(action, lists);\r\n    }\r\n    else {\r\n        const enumerator = getEnumerator(lists);\r\n        try {\r\n            while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                action(enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n            }\r\n        }\r\n        finally {\r\n            enumerator.Dispose();\r\n        }\r\n    }\r\n    const xs_6 = node;\r\n    const t_2 = FSharpList_get_Empty();\r\n    xs_6.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function scan(folder, state, xs) {\r\n    let xs_4, t_2;\r\n    const root = FSharpList_get_Empty();\r\n    let node;\r\n    const t = new FSharpList(state, void 0);\r\n    root.tail = t;\r\n    node = t;\r\n    let acc = state;\r\n    let xs_3 = xs;\r\n    while (!FSharpList__get_IsEmpty(xs_3)) {\r\n        acc = folder(acc, FSharpList__get_Head(xs_3));\r\n        node = ((xs_4 = node, (t_2 = (new FSharpList(acc, void 0)), (xs_4.tail = t_2, t_2))));\r\n        xs_3 = FSharpList__get_Tail(xs_3);\r\n    }\r\n    const xs_6 = node;\r\n    const t_4 = FSharpList_get_Empty();\r\n    xs_6.tail = t_4;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function scanBack(folder, xs, state) {\r\n    return ofArray(scanBack_1(folder, toArray(xs), state));\r\n}\r\n\r\nexport function append(xs, ys) {\r\n    return fold((acc, x) => FSharpList_Cons_305B8EAC(x, acc), ys, reverse(xs));\r\n}\r\n\r\nexport function collect(mapping, xs) {\r\n    let xs_1, t;\r\n    const root = FSharpList_get_Empty();\r\n    let node = root;\r\n    let ys = xs;\r\n    while (!FSharpList__get_IsEmpty(ys)) {\r\n        let zs = mapping(FSharpList__get_Head(ys));\r\n        while (!FSharpList__get_IsEmpty(zs)) {\r\n            node = ((xs_1 = node, (t = (new FSharpList(FSharpList__get_Head(zs), void 0)), (xs_1.tail = t, t))));\r\n            zs = FSharpList__get_Tail(zs);\r\n        }\r\n        ys = FSharpList__get_Tail(ys);\r\n    }\r\n    const xs_3 = node;\r\n    const t_2 = FSharpList_get_Empty();\r\n    xs_3.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function mapIndexed(mapping, xs) {\r\n    const root = FSharpList_get_Empty();\r\n    const node = foldIndexed((i, acc, x) => {\r\n        const t = new FSharpList(mapping(i, x), void 0);\r\n        acc.tail = t;\r\n        return t;\r\n    }, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function map(mapping, xs) {\r\n    const root = FSharpList_get_Empty();\r\n    const node = fold((acc, x) => {\r\n        const t = new FSharpList(mapping(x), void 0);\r\n        acc.tail = t;\r\n        return t;\r\n    }, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function indexed(xs) {\r\n    return mapIndexed((i, x) => [i, x], xs);\r\n}\r\n\r\nexport function map2(mapping, xs, ys) {\r\n    const root = FSharpList_get_Empty();\r\n    const node = fold2((acc, x, y) => {\r\n        const t = new FSharpList(mapping(x, y), void 0);\r\n        acc.tail = t;\r\n        return t;\r\n    }, root, xs, ys);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function mapIndexed2(mapping, xs, ys) {\r\n    const loop = (i_mut, acc_mut, xs_1_mut, ys_1_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, acc = acc_mut, xs_1 = xs_1_mut, ys_1 = ys_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1) ? true : FSharpList__get_IsEmpty(ys_1)) {\r\n                return acc;\r\n            }\r\n            else {\r\n                i_mut = (i + 1);\r\n                acc_mut = ((t = (new FSharpList(mapping(i, FSharpList__get_Head(xs_1), FSharpList__get_Head(ys_1)), void 0)), (acc.tail = t, t)));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                ys_1_mut = FSharpList__get_Tail(ys_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node_1 = loop(0, root, xs, ys);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node_1.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function map3(mapping, xs, ys, zs) {\r\n    const loop = (acc_mut, xs_1_mut, ys_1_mut, zs_1_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const acc = acc_mut, xs_1 = xs_1_mut, ys_1 = ys_1_mut, zs_1 = zs_1_mut;\r\n            if ((FSharpList__get_IsEmpty(xs_1) ? true : FSharpList__get_IsEmpty(ys_1)) ? true : FSharpList__get_IsEmpty(zs_1)) {\r\n                return acc;\r\n            }\r\n            else {\r\n                acc_mut = ((t = (new FSharpList(mapping(FSharpList__get_Head(xs_1), FSharpList__get_Head(ys_1), FSharpList__get_Head(zs_1)), void 0)), (acc.tail = t, t)));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                ys_1_mut = FSharpList__get_Tail(ys_1);\r\n                zs_1_mut = FSharpList__get_Tail(zs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node_1 = loop(root, xs, ys, zs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node_1.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function mapFold(mapping, state, xs) {\r\n    const root = FSharpList_get_Empty();\r\n    const patternInput_1 = fold((tupledArg, x) => {\r\n        let t;\r\n        const patternInput = mapping(tupledArg[1], x);\r\n        return [(t = (new FSharpList(patternInput[0], void 0)), (tupledArg[0].tail = t, t)), patternInput[1]];\r\n    }, [root, state], xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    patternInput_1[0].tail = t_2;\r\n    return [FSharpList__get_Tail(root), patternInput_1[1]];\r\n}\r\n\r\nexport function mapFoldBack(mapping, xs, state) {\r\n    return mapFold((acc, x) => mapping(x, acc), state, reverse(xs));\r\n}\r\n\r\nexport function tryPick(f, xs) {\r\n    const loop = (xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const xs_1 = xs_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return void 0;\r\n            }\r\n            else {\r\n                const matchValue = f(FSharpList__get_Head(xs_1));\r\n                if (matchValue == null) {\r\n                    xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                    continue loop;\r\n                }\r\n                else {\r\n                    return matchValue;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(xs);\r\n}\r\n\r\nexport function pick(f, xs) {\r\n    const matchValue = tryPick(f, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_keyNotFoundAlt));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFind(f, xs) {\r\n    return tryPick((x) => (f(x) ? some(x) : (void 0)), xs);\r\n}\r\n\r\nexport function find(f, xs) {\r\n    const matchValue = tryFind(f, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_keyNotFoundAlt));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFindBack(f, xs) {\r\n    return tryFindBack_1(f, toArray(xs));\r\n}\r\n\r\nexport function findBack(f, xs) {\r\n    const matchValue = tryFindBack(f, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_keyNotFoundAlt));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFindIndex(f, xs) {\r\n    const loop = (i_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, xs_1 = xs_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return void 0;\r\n            }\r\n            else if (f(FSharpList__get_Head(xs_1))) {\r\n                return i;\r\n            }\r\n            else {\r\n                i_mut = (i + 1);\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0, xs);\r\n}\r\n\r\nexport function findIndex(f, xs) {\r\n    const matchValue = tryFindIndex(f, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_keyNotFoundAlt));\r\n    }\r\n    else {\r\n        return matchValue | 0;\r\n    }\r\n}\r\n\r\nexport function tryFindIndexBack(f, xs) {\r\n    return tryFindIndexBack_1(f, toArray(xs));\r\n}\r\n\r\nexport function findIndexBack(f, xs) {\r\n    const matchValue = tryFindIndexBack(f, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_keyNotFoundAlt));\r\n    }\r\n    else {\r\n        return matchValue | 0;\r\n    }\r\n}\r\n\r\nexport function tryItem(n, xs) {\r\n    const loop = (i_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, xs_1 = xs_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return void 0;\r\n            }\r\n            else if (i === n) {\r\n                return some(FSharpList__get_Head(xs_1));\r\n            }\r\n            else {\r\n                i_mut = (i + 1);\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0, xs);\r\n}\r\n\r\nexport function item(n, xs) {\r\n    return FSharpList__get_Item_Z524259A4(xs, n);\r\n}\r\n\r\nexport function filter(f, xs) {\r\n    const root = FSharpList_get_Empty();\r\n    const node = fold((acc, x) => {\r\n        if (f(x)) {\r\n            const t = new FSharpList(x, void 0);\r\n            acc.tail = t;\r\n            return t;\r\n        }\r\n        else {\r\n            return acc;\r\n        }\r\n    }, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function partition(f, xs) {\r\n    const patternInput = [FSharpList_get_Empty(), FSharpList_get_Empty()];\r\n    const root2 = patternInput[1];\r\n    const root1 = patternInput[0];\r\n    const patternInput_1 = fold(uncurry(2, (tupledArg) => {\r\n        const lacc = tupledArg[0];\r\n        const racc = tupledArg[1];\r\n        return (x) => {\r\n            let t, t_2;\r\n            return f(x) ? [(t = (new FSharpList(x, void 0)), (lacc.tail = t, t)), racc] : [lacc, (t_2 = (new FSharpList(x, void 0)), (racc.tail = t_2, t_2))];\r\n        };\r\n    }), [root1, root2], xs);\r\n    const t_4 = FSharpList_get_Empty();\r\n    patternInput_1[0].tail = t_4;\r\n    const t_5 = FSharpList_get_Empty();\r\n    patternInput_1[1].tail = t_5;\r\n    return [FSharpList__get_Tail(root1), FSharpList__get_Tail(root2)];\r\n}\r\n\r\nexport function choose(f, xs) {\r\n    const root = FSharpList_get_Empty();\r\n    const node = fold((acc, x) => {\r\n        const matchValue = f(x);\r\n        if (matchValue == null) {\r\n            return acc;\r\n        }\r\n        else {\r\n            const t = new FSharpList(value_1(matchValue), void 0);\r\n            acc.tail = t;\r\n            return t;\r\n        }\r\n    }, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function contains(value, xs, eq) {\r\n    return tryFindIndex((v) => eq.Equals(value, v), xs) != null;\r\n}\r\n\r\nexport function initialize(n, f) {\r\n    let xs, t;\r\n    const root = FSharpList_get_Empty();\r\n    let node = root;\r\n    for (let i = 0; i <= (n - 1); i++) {\r\n        node = ((xs = node, (t = (new FSharpList(f(i), void 0)), (xs.tail = t, t))));\r\n    }\r\n    const xs_2 = node;\r\n    const t_2 = FSharpList_get_Empty();\r\n    xs_2.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function replicate(n, x) {\r\n    return initialize(n, (_arg1) => x);\r\n}\r\n\r\nexport function reduce(f, xs) {\r\n    if (FSharpList__get_IsEmpty(xs)) {\r\n        throw (new Error(SR_inputListWasEmpty));\r\n    }\r\n    else {\r\n        return fold(f, head(xs), tail(xs));\r\n    }\r\n}\r\n\r\nexport function reduceBack(f, xs) {\r\n    if (FSharpList__get_IsEmpty(xs)) {\r\n        throw (new Error(SR_inputListWasEmpty));\r\n    }\r\n    else {\r\n        return foldBack(f, tail(xs), head(xs));\r\n    }\r\n}\r\n\r\nexport function forAll(f, xs) {\r\n    return fold((acc, x) => (acc ? f(x) : false), true, xs);\r\n}\r\n\r\nexport function forAll2(f, xs, ys) {\r\n    return fold2((acc, x, y) => (acc ? f(x, y) : false), true, xs, ys);\r\n}\r\n\r\nexport function exists(f, xs) {\r\n    return tryFindIndex(f, xs) != null;\r\n}\r\n\r\nexport function exists2(f_mut, xs_mut, ys_mut) {\r\n    exists2:\r\n    while (true) {\r\n        const f = f_mut, xs = xs_mut, ys = ys_mut;\r\n        const matchValue = [FSharpList__get_IsEmpty(xs), FSharpList__get_IsEmpty(ys)];\r\n        let pattern_matching_result;\r\n        if (matchValue[0]) {\r\n            if (matchValue[1]) {\r\n                pattern_matching_result = 0;\r\n            }\r\n            else {\r\n                pattern_matching_result = 2;\r\n            }\r\n        }\r\n        else if (matchValue[1]) {\r\n            pattern_matching_result = 2;\r\n        }\r\n        else {\r\n            pattern_matching_result = 1;\r\n        }\r\n        switch (pattern_matching_result) {\r\n            case 0: {\r\n                return false;\r\n            }\r\n            case 1: {\r\n                if (f(FSharpList__get_Head(xs), FSharpList__get_Head(ys))) {\r\n                    return true;\r\n                }\r\n                else {\r\n                    f_mut = f;\r\n                    xs_mut = FSharpList__get_Tail(xs);\r\n                    ys_mut = FSharpList__get_Tail(ys);\r\n                    continue exists2;\r\n                }\r\n            }\r\n            case 2: {\r\n                throw (new Error((SR_listsHadDifferentLengths + \"\\\\nParameter name: \") + \"list2\"));\r\n            }\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function unzip(xs) {\r\n    return foldBack((tupledArg, tupledArg_1) => [FSharpList_Cons_305B8EAC(tupledArg[0], tupledArg_1[0]), FSharpList_Cons_305B8EAC(tupledArg[1], tupledArg_1[1])], xs, [FSharpList_get_Empty(), FSharpList_get_Empty()]);\r\n}\r\n\r\nexport function unzip3(xs) {\r\n    return foldBack((tupledArg, tupledArg_1) => [FSharpList_Cons_305B8EAC(tupledArg[0], tupledArg_1[0]), FSharpList_Cons_305B8EAC(tupledArg[1], tupledArg_1[1]), FSharpList_Cons_305B8EAC(tupledArg[2], tupledArg_1[2])], xs, [FSharpList_get_Empty(), FSharpList_get_Empty(), FSharpList_get_Empty()]);\r\n}\r\n\r\nexport function zip(xs, ys) {\r\n    return map2((x, y) => [x, y], xs, ys);\r\n}\r\n\r\nexport function zip3(xs, ys, zs) {\r\n    return map3((x, y, z) => [x, y, z], xs, ys, zs);\r\n}\r\n\r\nexport function sortWith(comparer, xs) {\r\n    const arr = toArray(xs);\r\n    arr.sort(comparer);\r\n    return ofArray(arr);\r\n}\r\n\r\nexport function sort(xs, comparer) {\r\n    return sortWith((x, y) => comparer.Compare(x, y), xs);\r\n}\r\n\r\nexport function sortBy(projection, xs, comparer) {\r\n    return sortWith((x, y) => comparer.Compare(projection(x), projection(y)), xs);\r\n}\r\n\r\nexport function sortDescending(xs, comparer) {\r\n    return sortWith((x, y) => (comparer.Compare(x, y) * -1), xs);\r\n}\r\n\r\nexport function sortByDescending(projection, xs, comparer) {\r\n    return sortWith((x, y) => (comparer.Compare(projection(x), projection(y)) * -1), xs);\r\n}\r\n\r\nexport function sum(xs, adder) {\r\n    return fold((acc, x) => adder.Add(acc, x), adder.GetZero(), xs);\r\n}\r\n\r\nexport function sumBy(f, xs, adder) {\r\n    return fold((acc, x) => adder.Add(acc, f(x)), adder.GetZero(), xs);\r\n}\r\n\r\nexport function maxBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function max(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function minBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function min(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function average(xs, averager) {\r\n    let count = 0;\r\n    return averager.DivideByInt(fold((acc, x) => {\r\n        count = ((count + 1) | 0);\r\n        return averager.Add(acc, x);\r\n    }, averager.GetZero(), xs), count);\r\n}\r\n\r\nexport function averageBy(f, xs, averager) {\r\n    let count = 0;\r\n    return averager.DivideByInt(fold((acc, x) => {\r\n        count = ((count + 1) | 0);\r\n        return averager.Add(acc, f(x));\r\n    }, averager.GetZero(), xs), count);\r\n}\r\n\r\nexport function permute(f, xs) {\r\n    return ofArray(permute_1(f, toArray(xs)));\r\n}\r\n\r\nexport function chunkBySize(chunkSize, xs) {\r\n    return ofArray(map_1((xs_1) => ofArray(xs_1), chunkBySize_1(chunkSize, toArray(xs))));\r\n}\r\n\r\nexport function allPairs(xs, ys) {\r\n    const root = FSharpList_get_Empty();\r\n    let node = root;\r\n    iterate((x) => {\r\n        iterate((y) => {\r\n            let xs_1, t;\r\n            node = ((xs_1 = node, (t = (new FSharpList([x, y], void 0)), (xs_1.tail = t, t))));\r\n        }, ys);\r\n    }, xs);\r\n    const xs_3 = node;\r\n    const t_2 = FSharpList_get_Empty();\r\n    xs_3.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function skip(count_mut, xs_mut) {\r\n    skip:\r\n    while (true) {\r\n        const count = count_mut, xs = xs_mut;\r\n        if (count <= 0) {\r\n            return xs;\r\n        }\r\n        else if (FSharpList__get_IsEmpty(xs)) {\r\n            throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"list\"));\r\n        }\r\n        else {\r\n            count_mut = (count - 1);\r\n            xs_mut = FSharpList__get_Tail(xs);\r\n            continue skip;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function skipWhile(predicate_mut, xs_mut) {\r\n    skipWhile:\r\n    while (true) {\r\n        const predicate = predicate_mut, xs = xs_mut;\r\n        if (FSharpList__get_IsEmpty(xs)) {\r\n            return xs;\r\n        }\r\n        else if (!predicate(FSharpList__get_Head(xs))) {\r\n            return xs;\r\n        }\r\n        else {\r\n            predicate_mut = predicate;\r\n            xs_mut = FSharpList__get_Tail(xs);\r\n            continue skipWhile;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function take(count, xs) {\r\n    if (count < 0) {\r\n        throw (new Error((SR_inputMustBeNonNegative + \"\\\\nParameter name: \") + \"count\"));\r\n    }\r\n    const loop = (i_mut, acc_mut, xs_1_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, acc = acc_mut, xs_1 = xs_1_mut;\r\n            if (i <= 0) {\r\n                return acc;\r\n            }\r\n            else if (FSharpList__get_IsEmpty(xs_1)) {\r\n                throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"list\"));\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                acc_mut = ((t = (new FSharpList(FSharpList__get_Head(xs_1), void 0)), (acc.tail = t, t)));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node = loop(count, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function takeWhile(predicate, xs) {\r\n    const loop = (acc_mut, xs_1_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const acc = acc_mut, xs_1 = xs_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return acc;\r\n            }\r\n            else if (!predicate(FSharpList__get_Head(xs_1))) {\r\n                return acc;\r\n            }\r\n            else {\r\n                acc_mut = ((t = (new FSharpList(FSharpList__get_Head(xs_1), void 0)), (acc.tail = t, t)));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node = loop(root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function truncate(count, xs) {\r\n    const loop = (i_mut, acc_mut, xs_1_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, acc = acc_mut, xs_1 = xs_1_mut;\r\n            if (i <= 0) {\r\n                return acc;\r\n            }\r\n            else if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return acc;\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                acc_mut = ((t = (new FSharpList(FSharpList__get_Head(xs_1), void 0)), (acc.tail = t, t)));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node = loop(count, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function getSlice(startIndex, endIndex, xs) {\r\n    const len = length(xs) | 0;\r\n    const startIndex_1 = defaultArg(startIndex, 0) | 0;\r\n    const endIndex_1 = defaultArg(endIndex, len - 1) | 0;\r\n    if (startIndex_1 < 0) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"startIndex\"));\r\n    }\r\n    else if (endIndex_1 >= len) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"endIndex\"));\r\n    }\r\n    else if (endIndex_1 < startIndex_1) {\r\n        return FSharpList_get_Empty();\r\n    }\r\n    else {\r\n        return take((endIndex_1 - startIndex_1) + 1, skip(startIndex_1, xs));\r\n    }\r\n}\r\n\r\nexport function splitAt(index, xs) {\r\n    if (index < 0) {\r\n        throw (new Error((SR_inputMustBeNonNegative + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    if (index > FSharpList__get_Length(xs)) {\r\n        throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    return [take(index, xs), skip(index, xs)];\r\n}\r\n\r\nexport function exactlyOne(xs) {\r\n    if (FSharpList__get_IsEmpty(xs)) {\r\n        throw (new Error((SR_inputSequenceEmpty + \"\\\\nParameter name: \") + \"list\"));\r\n    }\r\n    else if (FSharpList__get_IsEmpty(FSharpList__get_Tail(xs))) {\r\n        return FSharpList__get_Head(xs);\r\n    }\r\n    else {\r\n        throw (new Error((SR_inputSequenceTooLong + \"\\\\nParameter name: \") + \"list\"));\r\n    }\r\n}\r\n\r\nexport function tryExactlyOne(xs) {\r\n    if ((!FSharpList__get_IsEmpty(xs)) ? FSharpList__get_IsEmpty(FSharpList__get_Tail(xs)) : false) {\r\n        return some(FSharpList__get_Head(xs));\r\n    }\r\n    else {\r\n        return void 0;\r\n    }\r\n}\r\n\r\nexport function where(predicate, xs) {\r\n    return filter(predicate, xs);\r\n}\r\n\r\nexport function pairwise(xs) {\r\n    return ofArray(pairwise_1(toArray(xs)));\r\n}\r\n\r\nexport function windowed(windowSize, xs) {\r\n    return ofArray(map_1((xs_1) => ofArray(xs_1), windowed_1(windowSize, toArray(xs))));\r\n}\r\n\r\nexport function splitInto(chunks, xs) {\r\n    return ofArray(map_1((xs_1) => ofArray(xs_1), splitInto_1(chunks, toArray(xs))));\r\n}\r\n\r\nexport function transpose(lists) {\r\n    return ofArray(map_1((xs_1) => ofArray(xs_1), transpose_1(map_1((xs) => toArray(xs), Array.from(lists)))));\r\n}\r\n\r\n","export class CancellationToken {\n    constructor(cancelled = false) {\n        this._id = 0;\n        this._cancelled = cancelled;\n        this._listeners = new Map();\n    }\n    get isCancelled() {\n        return this._cancelled;\n    }\n    cancel() {\n        if (!this._cancelled) {\n            this._cancelled = true;\n            for (const [, listener] of this._listeners) {\n                listener();\n            }\n        }\n    }\n    addListener(f) {\n        const id = this._id;\n        this._listeners.set(this._id++, f);\n        return id;\n    }\n    removeListener(id) {\n        return this._listeners.delete(id);\n    }\n    register(f, state) {\n        const $ = this;\n        const id = this.addListener(state == null ? f : () => f(state));\n        return { Dispose() { $.removeListener(id); } };\n    }\n}\nexport class OperationCanceledError extends Error {\n    constructor() {\n        super(\"The operation was canceled\");\n        Object.setPrototypeOf(this, OperationCanceledError.prototype);\n    }\n}\nexport class Trampoline {\n    constructor() {\n        this.callCount = 0;\n    }\n    static get maxTrampolineCallCount() {\n        return 2000;\n    }\n    incrementAndCheck() {\n        return this.callCount++ > Trampoline.maxTrampolineCallCount;\n    }\n    hijack(f) {\n        this.callCount = 0;\n        setTimeout(f, 0);\n    }\n}\nexport function protectedCont(f) {\n    return (ctx) => {\n        if (ctx.cancelToken.isCancelled) {\n            ctx.onCancel(new OperationCanceledError());\n        }\n        else if (ctx.trampoline.incrementAndCheck()) {\n            ctx.trampoline.hijack(() => {\n                try {\n                    f(ctx);\n                }\n                catch (err) {\n                    ctx.onError(err);\n                }\n            });\n        }\n        else {\n            try {\n                f(ctx);\n            }\n            catch (err) {\n                ctx.onError(err);\n            }\n        }\n    };\n}\nexport function protectedBind(computation, binder) {\n    return protectedCont((ctx) => {\n        computation({\n            onSuccess: (x) => {\n                try {\n                    binder(x)(ctx);\n                }\n                catch (ex) {\n                    ctx.onError(ex);\n                }\n            },\n            onError: ctx.onError,\n            onCancel: ctx.onCancel,\n            cancelToken: ctx.cancelToken,\n            trampoline: ctx.trampoline,\n        });\n    });\n}\nexport function protectedReturn(value) {\n    return protectedCont((ctx) => ctx.onSuccess(value));\n}\nexport class AsyncBuilder {\n    Bind(computation, binder) {\n        return protectedBind(computation, binder);\n    }\n    Combine(computation1, computation2) {\n        return this.Bind(computation1, () => computation2);\n    }\n    Delay(generator) {\n        return protectedCont((ctx) => generator()(ctx));\n    }\n    For(sequence, body) {\n        const iter = sequence[Symbol.iterator]();\n        let cur = iter.next();\n        return this.While(() => !cur.done, this.Delay(() => {\n            const res = body(cur.value);\n            cur = iter.next();\n            return res;\n        }));\n    }\n    Return(value) {\n        return protectedReturn(value);\n    }\n    ReturnFrom(computation) {\n        return computation;\n    }\n    TryFinally(computation, compensation) {\n        return protectedCont((ctx) => {\n            computation({\n                onSuccess: (x) => {\n                    compensation();\n                    ctx.onSuccess(x);\n                },\n                onError: (x) => {\n                    compensation();\n                    ctx.onError(x);\n                },\n                onCancel: (x) => {\n                    compensation();\n                    ctx.onCancel(x);\n                },\n                cancelToken: ctx.cancelToken,\n                trampoline: ctx.trampoline,\n            });\n        });\n    }\n    TryWith(computation, catchHandler) {\n        return protectedCont((ctx) => {\n            computation({\n                onSuccess: ctx.onSuccess,\n                onCancel: ctx.onCancel,\n                cancelToken: ctx.cancelToken,\n                trampoline: ctx.trampoline,\n                onError: (ex) => {\n                    try {\n                        catchHandler(ex)(ctx);\n                    }\n                    catch (ex2) {\n                        ctx.onError(ex2);\n                    }\n                },\n            });\n        });\n    }\n    Using(resource, binder) {\n        return this.TryFinally(binder(resource), () => resource.Dispose());\n    }\n    While(guard, computation) {\n        if (guard()) {\n            return this.Bind(computation, () => this.While(guard, computation));\n        }\n        else {\n            return this.Return(void 0);\n        }\n    }\n    Zero() {\n        return protectedCont((ctx) => ctx.onSuccess(void 0));\n    }\n}\nexport const singleton = new AsyncBuilder();\n","import { OperationCanceledError, Trampoline } from \"./AsyncBuilder.js\";\nimport { CancellationToken } from \"./AsyncBuilder.js\";\nimport { protectedCont } from \"./AsyncBuilder.js\";\nimport { protectedBind } from \"./AsyncBuilder.js\";\nimport { protectedReturn } from \"./AsyncBuilder.js\";\nimport { Choice_makeChoice1Of2, Choice_makeChoice2Of2 } from \"./Choice.js\";\n// Implemented just for type references\nexport class Async {\n}\nfunction emptyContinuation(_x) {\n    // NOP\n}\n// MakeAsync: body:(AsyncActivation<'T> -> AsyncReturn) -> Async<'T>\nexport function makeAsync(body) {\n    return body;\n}\n// Invoke: computation: Async<'T> -> ctxt:AsyncActivation<'T> -> AsyncReturn\nexport function invoke(computation, ctx) {\n    return computation(ctx);\n}\n// CallThenInvoke: ctxt:AsyncActivation<'T> -> result1:'U -> part2:('U -> Async<'T>) -> AsyncReturn\nexport function callThenInvoke(ctx, result1, part2) {\n    return part2(result1)(ctx);\n}\n// Bind: ctxt:AsyncActivation<'T> -> part1:Async<'U> -> part2:('U -> Async<'T>) -> AsyncReturn\nexport function bind(ctx, part1, part2) {\n    return protectedBind(part1, part2)(ctx);\n}\nexport function createCancellationToken(arg) {\n    const token = new CancellationToken(typeof arg === \"boolean\" ? arg : false);\n    if (typeof arg === \"number\") {\n        setTimeout(() => { token.cancel(); }, arg);\n    }\n    return token;\n}\nexport function cancel(token) {\n    token.cancel();\n}\nexport function cancelAfter(token, ms) {\n    setTimeout(() => { token.cancel(); }, ms);\n}\nexport function isCancellationRequested(token) {\n    return token != null && token.isCancelled;\n}\nexport function throwIfCancellationRequested(token) {\n    if (token != null && token.isCancelled) {\n        throw new Error(\"Operation is cancelled\");\n    }\n}\nexport function startChild(computation) {\n    const promise = startAsPromise(computation);\n    // JS Promises are hot, computation has already started\n    // but we delay returning the result\n    return protectedCont((ctx) => protectedReturn(awaitPromise(promise))(ctx));\n}\nexport function awaitPromise(p) {\n    return fromContinuations((conts) => p.then(conts[0]).catch((err) => (err instanceof OperationCanceledError\n        ? conts[2] : conts[1])(err)));\n}\nexport function cancellationToken() {\n    return protectedCont((ctx) => ctx.onSuccess(ctx.cancelToken));\n}\nexport const defaultCancellationToken = new CancellationToken();\nexport function catchAsync(work) {\n    return protectedCont((ctx) => {\n        work({\n            onSuccess: (x) => ctx.onSuccess(Choice_makeChoice1Of2(x)),\n            onError: (ex) => ctx.onSuccess(Choice_makeChoice2Of2(ex)),\n            onCancel: ctx.onCancel,\n            cancelToken: ctx.cancelToken,\n            trampoline: ctx.trampoline,\n        });\n    });\n}\nexport function fromContinuations(f) {\n    return protectedCont((ctx) => f([ctx.onSuccess, ctx.onError, ctx.onCancel]));\n}\nexport function ignore(computation) {\n    return protectedBind(computation, (_x) => protectedReturn(void 0));\n}\nexport function parallel(computations) {\n    return awaitPromise(Promise.all(Array.from(computations, (w) => startAsPromise(w))));\n}\nexport function sleep(millisecondsDueTime) {\n    return protectedCont((ctx) => {\n        let tokenId;\n        const timeoutId = setTimeout(() => {\n            ctx.cancelToken.removeListener(tokenId);\n            ctx.onSuccess(void 0);\n        }, millisecondsDueTime);\n        tokenId = ctx.cancelToken.addListener(() => {\n            clearTimeout(timeoutId);\n            ctx.onCancel(new OperationCanceledError());\n        });\n    });\n}\nexport function start(computation, cancellationToken) {\n    return startWithContinuations(computation, cancellationToken);\n}\nexport function startImmediate(computation, cancellationToken) {\n    return start(computation, cancellationToken);\n}\nexport function startWithContinuations(computation, continuation, exceptionContinuation, cancellationContinuation, cancelToken) {\n    if (typeof continuation !== \"function\") {\n        cancelToken = continuation;\n        continuation = undefined;\n    }\n    const trampoline = new Trampoline();\n    computation({\n        onSuccess: continuation ? continuation : emptyContinuation,\n        onError: exceptionContinuation ? exceptionContinuation : emptyContinuation,\n        onCancel: cancellationContinuation ? cancellationContinuation : emptyContinuation,\n        cancelToken: cancelToken ? cancelToken : defaultCancellationToken,\n        trampoline,\n    });\n}\nexport function startAsPromise(computation, cancellationToken) {\n    return new Promise((resolve, reject) => startWithContinuations(computation, resolve, reject, reject, cancellationToken ? cancellationToken : defaultCancellationToken));\n}\nexport default Async;\n","namespace Elmish\n\n(**\nLog\n---------\nBasic cross-platform logging API.\n\n*)\nmodule internal Log =\n\n#if FABLE_COMPILER\n    open Fable.Core.JS\n\n    let onError (text: string, ex: exn) = console.error (text,ex)\n    let toConsole(text: string, o: #obj) = console.log(text,o)\n\n#else\n#if NETSTANDARD2_0\n    let onError (text: string, ex: exn) = System.Diagnostics.Trace.TraceError(\"{0}: {1}\", text, ex)\n    let toConsole(text: string, o: #obj) = printfn \"%s: %A\" text o\n#else\n    let onError (text: string, ex: exn) = System.Console.Error.WriteLine(\"{0}: {1}\", text, ex)\n    let toConsole(text: string, o: #obj) = printfn \"%s: %A\" text o\n#endif\n#endif\n\n#if FABLE_COMPILER\nmodule internal Timer =\n    open System.Timers\n    let delay interval callback =\n        let t = new Timer(float interval, AutoReset = false)\n        t.Elapsed.Add callback\n        t.Enabled <- true\n        t.Start()\n#endif\n","(**\nCmd\n---------\nCore abstractions for dispatching messages in Elmish.\n\n*)\n\nnamespace Elmish\n\nopen System\n\n/// Dispatch - feed new message into the processing loop\ntype Dispatch<'msg> = 'msg -> unit\n\n/// Subscription - return immediately, but may schedule dispatch of a message at any time\ntype Sub<'msg> = Dispatch<'msg> -> unit\n\n/// Cmd - container for subscriptions that may produce messages\ntype Cmd<'msg> = Sub<'msg> list\n\n/// Cmd module for creating and manipulating commands\n[<RequireQualifiedAccess>]\nmodule Cmd =\n    /// Execute the commands using the supplied dispatcher\n    let internal exec onError (dispatch: Dispatch<'msg>) (cmd: Cmd<'msg>) =\n        cmd |> List.iter (fun call -> try call dispatch with ex -> onError ex)\n\n    /// None - no commands, also known as `[]`\n    let none : Cmd<'msg> =\n        []\n\n    /// When emitting the message, map to another type\n    let map (f: 'a -> 'msg) (cmd: Cmd<'a>) : Cmd<'msg> =\n        cmd |> List.map (fun g -> (fun dispatch -> f >> dispatch) >> g)\n\n    /// Aggregate multiple commands\n    let batch (cmds: #seq<Cmd<'msg>>) : Cmd<'msg> =\n        cmds |> List.concat\n\n    /// Command to call the subscriber\n    let ofSub (sub: Sub<'msg>) : Cmd<'msg> =\n        [sub]\n\n    module OfFunc =\n        /// Command to evaluate a simple function and map the result\n        /// into success or error (of exception)\n        let either (task: 'a -> _) (arg: 'a) (ofSuccess: _ -> 'msg) (ofError: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                try\n                    task arg\n                    |> (ofSuccess >> dispatch)\n                with x ->\n                    x |> (ofError >> dispatch)\n            [bind]\n\n        /// Command to evaluate a simple function and map the success to a message\n        /// discarding any possible error\n        let perform (task: 'a -> _) (arg: 'a) (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                try\n                    task arg\n                    |> (ofSuccess >> dispatch)\n                with x ->\n                    ()\n            [bind]\n\n        /// Command to evaluate a simple function and map the error (in case of exception)\n        let attempt (task: 'a -> unit) (arg: 'a) (ofError: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                try\n                    task arg\n                with x ->\n                    x |> (ofError >> dispatch)\n            [bind]\n\n        /// Command to issue a specific message\n        let result (msg:'msg) : Cmd<'msg> =\n            [fun dispatch -> dispatch msg]\n\n    module OfAsyncWith =\n        /// Command that will evaluate an async block and map the result\n        /// into success or error (of exception)\n        let either (start: Async<unit> -> unit) \n                   (task: 'a -> Async<_>)\n                   (arg: 'a)\n                   (ofSuccess: _ -> 'msg)\n                   (ofError: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                async {\n                    let! r = task arg |> Async.Catch\n                    dispatch (match r with\n                             | Choice1Of2 x -> ofSuccess x\n                             | Choice2Of2 x -> ofError x)\n                }\n            [bind >> start]\n\n        /// Command that will evaluate an async block and map the success\n        let perform (start: Async<unit> -> unit) \n                    (task: 'a -> Async<_>)\n                    (arg: 'a)\n                    (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                async {\n                    let! r = task arg |> Async.Catch\n                    match r with\n                    | Choice1Of2 x -> dispatch (ofSuccess x)\n                    | _ -> ()\n                }\n            [bind >> start]\n\n        /// Command that will evaluate an async block and map the error (of exception)\n        let attempt (start: Async<unit> -> unit) \n                    (task: 'a -> Async<_>)\n                    (arg: 'a)\n                    (ofError: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                async {\n                    let! r = task arg |> Async.Catch\n                    match r with\n                    | Choice2Of2 x -> dispatch (ofError x)\n                    | _ -> ()\n                }\n            [bind >> start]\n\n        /// Command that will evaluate an async block to the message\n        let result (start: Async<unit> -> unit) \n                   (task: Async<'msg>) : Cmd<'msg> =\n            let bind dispatch =\n                async {\n                    let! r = task\n                    dispatch r\n                }\n            [bind >> start]\n\n    module OfAsync =\n#if FABLE_COMPILER\n        let start x = Timer.delay 0 (fun _ -> Async.StartImmediate x)\n#else\n        let inline start x = Async.Start x\n#endif    \n        /// Command that will evaluate an async block and map the result\n        /// into success or error (of exception)\n        let inline either (task: 'a -> Async<_>)\n                          (arg: 'a)\n                          (ofSuccess: _ -> 'msg)\n                          (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.either start task arg ofSuccess ofError\n\n        /// Command that will evaluate an async block and map the success\n        let inline perform (task: 'a -> Async<_>)\n                           (arg: 'a)\n                           (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.perform start task arg ofSuccess\n\n        /// Command that will evaluate an async block and map the error (of exception)\n        let inline attempt (task: 'a -> Async<_>)\n                           (arg: 'a)\n                           (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.attempt start task arg ofError\n\n        /// Command that will evaluate an async block to the message\n        let inline result (task: Async<'msg>) : Cmd<'msg> =\n            OfAsyncWith.result start task\n\n    module OfAsyncImmediate =\n        /// Command that will evaluate an async block and map the result\n        /// into success or error (of exception)\n        let inline either (task: 'a -> Async<_>)\n                          (arg: 'a)\n                          (ofSuccess: _ -> 'msg)\n                          (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.either Async.StartImmediate task arg ofSuccess ofError\n\n        /// Command that will evaluate an async block and map the success\n        let inline perform (task: 'a -> Async<_>)\n                           (arg: 'a)\n                           (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.perform Async.StartImmediate task arg ofSuccess\n\n        /// Command that will evaluate an async block and map the error (of exception)\n        let inline attempt (task: 'a -> Async<_>)\n                           (arg: 'a)\n                           (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.attempt Async.StartImmediate task arg ofError\n\n        /// Command that will evaluate an async block to the message\n        let inline result (task: Async<'msg>) : Cmd<'msg> =\n            OfAsyncWith.result Async.StartImmediate task\n\n#if FABLE_COMPILER\n    module OfPromise =\n        /// Command to call `promise` block and map the results\n        let either (task: 'a -> Fable.Core.JS.Promise<_>)\n                   (arg:'a)\n                   (ofSuccess: _ -> 'msg)\n                   (ofError: #exn -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                (task arg)\n                    .``then``(ofSuccess >> dispatch)\n                    .catch(unbox >> ofError >> dispatch)\n                    |> ignore\n            [bind]\n\n        /// Command to call `promise` block and map the success\n        let perform (task: 'a -> Fable.Core.JS.Promise<_>)\n                   (arg:'a)\n                   (ofSuccess: _ -> 'msg) =\n            let bind dispatch =\n                (task arg)\n                    .``then``(ofSuccess >> dispatch)\n                    |> ignore\n            [bind]\n\n        /// Command to call `promise` block and map the error\n        let attempt (task: 'a -> Fable.Core.JS.Promise<_>)\n                    (arg:'a)\n                    (ofError: #exn -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                (task arg)\n                    .catch(unbox >> ofError >> dispatch)\n                    |> ignore\n            [bind]\n\n        /// Command to dispatch the `promise` result\n        let result (task: Fable.Core.JS.Promise<'msg>) =\n            let bind dispatch =\n                task.``then`` dispatch\n                |> ignore\n            [bind]\n\n    [<Obsolete(\"Use `OfPromise.either` instead\")>]\n    let inline ofPromise (task: 'a -> Fable.Core.JS.Promise<_>)\n                         (arg:'a)\n                         (ofSuccess: _ -> 'msg)\n                         (ofError: _ -> 'msg) : Cmd<'msg> =\n        OfPromise.either task arg ofSuccess ofError                     \n#else\n    open System.Threading.Tasks\n    module OfTask =\n        /// Command to call a task and map the results\n        let inline either (task: 'a -> Task<_>)\n                          (arg:'a)\n                          (ofSuccess: _ -> 'msg)\n                          (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsync.either (task >> Async.AwaitTask) arg ofSuccess ofError\n\n        /// Command to call a task and map the success\n        let inline perform (task: 'a -> Task<_>)\n                           (arg:'a)\n                           (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n            OfAsync.perform (task >> Async.AwaitTask) arg ofSuccess\n\n        /// Command to call a task and map the error\n        let inline attempt (task: 'a -> Task<_>)\n                           (arg:'a)\n                           (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsync.attempt (task >> Async.AwaitTask) arg ofError\n\n        /// Command and map the task success\n        let inline result (task: Task<'msg>) : Cmd<'msg> =\n            OfAsync.result (task |> Async.AwaitTask)\n\n    [<Obsolete(\"Use OfTask.either instead\")>]\n    let inline ofTask (task: 'a -> Task<_>)\n                      (arg:'a)\n                      (ofSuccess: _ -> 'msg)\n                      (ofError: _ -> 'msg) : Cmd<'msg> =\n        OfTask.either task arg ofSuccess ofError\n#endif\n\n    // Synonymous with `OfFunc.result`, may be removed in the future\n    let inline ofMsg (msg:'msg) : Cmd<'msg> =\n        OfFunc.result msg\n\n    [<Obsolete(\"Use `Cmd.OfAsync.either` instead\")>]\n    let inline ofAsync (task: 'a -> Async<_>)\n                       (arg: 'a)\n                       (ofSuccess: _ -> 'msg)\n                       (ofError: _ -> 'msg) : Cmd<'msg> =\n        OfAsync.either task arg ofSuccess ofError\n\n    [<Obsolete(\"Use `Cmd.OfFunc.either` instead\")>]\n    let inline ofFunc (task: 'a -> _) (arg: 'a) (ofSuccess: _ -> 'msg) (ofError: _ -> 'msg) : Cmd<'msg> =\n        OfFunc.either task arg ofSuccess ofError\n\n    [<Obsolete(\"Use `Cmd.OfFunc.perform` instead\")>]\n    let inline performFunc (task: 'a -> _) (arg: 'a) (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n        OfFunc.perform task arg ofSuccess\n\n    [<Obsolete(\"Use `Cmd.OfFunc.attempt` instead\")>]\n    let attemptFunc (task: 'a -> unit) (arg: 'a) (ofError: _ -> 'msg) : Cmd<'msg> =\n        OfFunc.attempt task arg ofError\n\n","import { equals, isArrayLike, isDisposable, toIterator, getEnumerator } from \"./Util.js\";\r\nimport { toString } from \"./Types.js\";\r\nimport { class_type } from \"./Reflection.js\";\r\nimport { some, value as value_1 } from \"./Option.js\";\r\nimport { Operators_NullArg } from \"./FSharp.Core.js\";\r\nimport { chunkBySize as chunkBySize_1, permute as permute_1, transpose as transpose_1, windowed as windowed_1, splitInto as splitInto_1, map as map_1, pairwise as pairwise_1, scanBack as scanBack_1, reverse as reverse_1, mapFoldBack as mapFoldBack_1, mapFold as mapFold_1, tryItem as tryItem_1, tryHead as tryHead_1, foldBack2 as foldBack2_1, foldBack as foldBack_1, tryFindIndexBack as tryFindIndexBack_1, tryFindBack as tryFindBack_1, singleton as singleton_1 } from \"./Array.js\";\r\nimport { length as length_1, tryItem as tryItem_2, isEmpty as isEmpty_1, tryHead as tryHead_2, ofSeq as ofSeq_1, ofArray as ofArray_1, toArray as toArray_1, FSharpList } from \"./List.js\";\r\n\r\nexport const SR_enumerationAlreadyFinished = \"Enumeration already finished.\";\r\n\r\nexport const SR_enumerationNotStarted = \"Enumeration has not started. Call MoveNext.\";\r\n\r\nexport const SR_inputSequenceEmpty = \"The input sequence was empty.\";\r\n\r\nexport const SR_inputSequenceTooLong = \"The input sequence contains more than one element.\";\r\n\r\nexport const SR_keyNotFoundAlt = \"An index satisfying the predicate was not found in the collection.\";\r\n\r\nexport const SR_notEnoughElements = \"The input sequence has an insufficient number of elements.\";\r\n\r\nexport const SR_resetNotSupported = \"Reset is not supported on this enumerator.\";\r\n\r\nexport function Enumerator_noReset() {\r\n    throw (new Error(SR_resetNotSupported));\r\n}\r\n\r\nexport function Enumerator_notStarted() {\r\n    throw (new Error(SR_enumerationNotStarted));\r\n}\r\n\r\nexport function Enumerator_alreadyFinished() {\r\n    throw (new Error(SR_enumerationAlreadyFinished));\r\n}\r\n\r\nexport class Enumerator_Seq {\r\n    constructor(f) {\r\n        this.f = f;\r\n    }\r\n    toString() {\r\n        const xs = this;\r\n        const maxCount = 4;\r\n        let i = 0;\r\n        let str = \"seq [\";\r\n        const e = getEnumerator(xs);\r\n        try {\r\n            while ((i < maxCount) ? e[\"System.Collections.IEnumerator.MoveNext\"]() : false) {\r\n                if (i > 0) {\r\n                    str = (str + \"; \");\r\n                }\r\n                str = (str + toString(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()));\r\n                i = ((i + 1) | 0);\r\n            }\r\n            if (i === maxCount) {\r\n                str = (str + \"; ...\");\r\n            }\r\n            return str + \"]\";\r\n        }\r\n        finally {\r\n            e.Dispose();\r\n        }\r\n    }\r\n    GetEnumerator() {\r\n        const x = this;\r\n        return x.f();\r\n    }\r\n    [Symbol.iterator]() {\r\n        return toIterator(this.GetEnumerator());\r\n    }\r\n    [\"System.Collections.IEnumerable.GetEnumerator\"]() {\r\n        const x = this;\r\n        return x.f();\r\n    }\r\n}\r\n\r\nexport function Enumerator_Seq$reflection(gen0) {\r\n    return class_type(\"SeqModule.Enumerator.Seq\", [gen0], Enumerator_Seq);\r\n}\r\n\r\nexport function Enumerator_Seq_$ctor_673A07F2(f) {\r\n    return new Enumerator_Seq(f);\r\n}\r\n\r\nexport class Enumerator_FromFunctions$1 {\r\n    constructor(current, next, dispose) {\r\n        this.current = current;\r\n        this.next = next;\r\n        this.dispose = dispose;\r\n    }\r\n    [\"System.Collections.Generic.IEnumerator`1.get_Current\"]() {\r\n        const __ = this;\r\n        return __.current();\r\n    }\r\n    [\"System.Collections.IEnumerator.get_Current\"]() {\r\n        const __ = this;\r\n        return __.current();\r\n    }\r\n    [\"System.Collections.IEnumerator.MoveNext\"]() {\r\n        const __ = this;\r\n        return __.next();\r\n    }\r\n    [\"System.Collections.IEnumerator.Reset\"]() {\r\n        Enumerator_noReset();\r\n    }\r\n    Dispose() {\r\n        const __ = this;\r\n        __.dispose();\r\n    }\r\n}\r\n\r\nexport function Enumerator_FromFunctions$1$reflection(gen0) {\r\n    return class_type(\"SeqModule.Enumerator.FromFunctions`1\", [gen0], Enumerator_FromFunctions$1);\r\n}\r\n\r\nexport function Enumerator_FromFunctions$1_$ctor_58C54629(current, next, dispose) {\r\n    return new Enumerator_FromFunctions$1(current, next, dispose);\r\n}\r\n\r\nexport function Enumerator_cast(e) {\r\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => e[\"System.Collections.IEnumerator.get_Current\"](), () => e[\"System.Collections.IEnumerator.MoveNext\"](), () => {\r\n        if (isDisposable(e)) {\r\n            e.Dispose();\r\n        }\r\n    });\r\n}\r\n\r\nexport function Enumerator_concat(sources) {\r\n    let outerOpt = void 0;\r\n    let innerOpt = void 0;\r\n    let started = false;\r\n    let finished = false;\r\n    let curr = void 0;\r\n    const finish = () => {\r\n        finished = true;\r\n        if (innerOpt != null) {\r\n            const inner = innerOpt;\r\n            try {\r\n                inner.Dispose();\r\n            }\r\n            finally {\r\n                innerOpt = (void 0);\r\n            }\r\n        }\r\n        if (outerOpt != null) {\r\n            const outer = outerOpt;\r\n            try {\r\n                outer.Dispose();\r\n            }\r\n            finally {\r\n                outerOpt = (void 0);\r\n            }\r\n        }\r\n    };\r\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => {\r\n        if (!started) {\r\n            Enumerator_notStarted();\r\n        }\r\n        else if (finished) {\r\n            Enumerator_alreadyFinished();\r\n        }\r\n        if (curr != null) {\r\n            return value_1(curr);\r\n        }\r\n        else {\r\n            return Enumerator_alreadyFinished();\r\n        }\r\n    }, () => {\r\n        let copyOfStruct;\r\n        if (!started) {\r\n            started = true;\r\n        }\r\n        if (finished) {\r\n            return false;\r\n        }\r\n        else {\r\n            let res = void 0;\r\n            while (res == null) {\r\n                const matchValue = [outerOpt, innerOpt];\r\n                if (matchValue[0] != null) {\r\n                    if (matchValue[1] != null) {\r\n                        const inner_1 = matchValue[1];\r\n                        if (inner_1[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                            curr = some(inner_1[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n                            res = true;\r\n                        }\r\n                        else {\r\n                            try {\r\n                                inner_1.Dispose();\r\n                            }\r\n                            finally {\r\n                                innerOpt = (void 0);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        const outer_1 = matchValue[0];\r\n                        if (outer_1[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                            const ie = outer_1[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n                            innerOpt = ((copyOfStruct = ie, getEnumerator(copyOfStruct)));\r\n                        }\r\n                        else {\r\n                            finish();\r\n                            res = false;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    outerOpt = getEnumerator(sources);\r\n                }\r\n            }\r\n            return value_1(res);\r\n        }\r\n    }, () => {\r\n        if (!finished) {\r\n            finish();\r\n        }\r\n    });\r\n}\r\n\r\nexport function Enumerator_enumerateThenFinally(f, e) {\r\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => e[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), () => e[\"System.Collections.IEnumerator.MoveNext\"](), () => {\r\n        try {\r\n            e.Dispose();\r\n        }\r\n        finally {\r\n            f();\r\n        }\r\n    });\r\n}\r\n\r\nexport function Enumerator_generateWhileSome(openf, compute, closef) {\r\n    let started = false;\r\n    let curr = void 0;\r\n    let state = some(openf());\r\n    const dispose = () => {\r\n        if (state != null) {\r\n            const x_1 = value_1(state);\r\n            try {\r\n                closef(x_1);\r\n            }\r\n            finally {\r\n                state = (void 0);\r\n            }\r\n        }\r\n    };\r\n    const finish = () => {\r\n        try {\r\n            dispose();\r\n        }\r\n        finally {\r\n            curr = (void 0);\r\n        }\r\n    };\r\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => {\r\n        if (!started) {\r\n            Enumerator_notStarted();\r\n        }\r\n        if (curr != null) {\r\n            return value_1(curr);\r\n        }\r\n        else {\r\n            return Enumerator_alreadyFinished();\r\n        }\r\n    }, () => {\r\n        if (!started) {\r\n            started = true;\r\n        }\r\n        if (state != null) {\r\n            const s = value_1(state);\r\n            let matchValue_1;\r\n            try {\r\n                matchValue_1 = compute(s);\r\n            }\r\n            catch (matchValue) {\r\n                finish();\r\n                throw matchValue;\r\n            }\r\n            if (matchValue_1 != null) {\r\n                curr = matchValue_1;\r\n                return true;\r\n            }\r\n            else {\r\n                finish();\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }, dispose);\r\n}\r\n\r\nexport function Enumerator_unfold(f, state) {\r\n    let curr = void 0;\r\n    let acc = state;\r\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => {\r\n        if (curr != null) {\r\n            const x = curr[0];\r\n            const st = curr[1];\r\n            return x;\r\n        }\r\n        else {\r\n            return Enumerator_notStarted();\r\n        }\r\n    }, () => {\r\n        curr = f(acc);\r\n        if (curr != null) {\r\n            const x_1 = curr[0];\r\n            const st_1 = curr[1];\r\n            acc = st_1;\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }, () => {\r\n    });\r\n}\r\n\r\nexport function indexNotFound() {\r\n    throw (new Error(SR_keyNotFoundAlt));\r\n}\r\n\r\nexport function checkNonNull(argName, arg) {\r\n    if (arg == null) {\r\n        Operators_NullArg(argName);\r\n    }\r\n}\r\n\r\nexport function mkSeq(f) {\r\n    return Enumerator_Seq_$ctor_673A07F2(f);\r\n}\r\n\r\nexport function ofSeq(xs) {\r\n    checkNonNull(\"source\", xs);\r\n    return getEnumerator(xs);\r\n}\r\n\r\nexport function delay(generator) {\r\n    return mkSeq(() => getEnumerator(generator()));\r\n}\r\n\r\nexport function concat(sources) {\r\n    return mkSeq(() => Enumerator_concat(sources));\r\n}\r\n\r\nexport function unfold(generator, state) {\r\n    return mkSeq(() => Enumerator_unfold(generator, state));\r\n}\r\n\r\nexport function empty() {\r\n    return delay(() => (new Array(0)));\r\n}\r\n\r\nexport function singleton(x) {\r\n    return delay(() => singleton_1(x));\r\n}\r\n\r\nexport function ofArray(arr) {\r\n    return arr;\r\n}\r\n\r\nexport function toArray(xs) {\r\n    if (isArrayLike(xs)) {\r\n        return xs;\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return toArray_1(xs);\r\n    }\r\n    else {\r\n        return Array.from(xs);\r\n    }\r\n}\r\n\r\nexport function ofList(xs) {\r\n    return xs;\r\n}\r\n\r\nexport function toList(xs) {\r\n    if (isArrayLike(xs)) {\r\n        return ofArray_1(xs);\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return xs;\r\n    }\r\n    else {\r\n        return ofSeq_1(xs);\r\n    }\r\n}\r\n\r\nexport function generate(create, compute, dispose) {\r\n    return mkSeq(() => Enumerator_generateWhileSome(create, compute, dispose));\r\n}\r\n\r\nexport function generateIndexed(create, compute, dispose) {\r\n    return mkSeq(() => {\r\n        let i = -1;\r\n        return Enumerator_generateWhileSome(create, (x) => {\r\n            i = ((i + 1) | 0);\r\n            return compute(i, x);\r\n        }, dispose);\r\n    });\r\n}\r\n\r\nexport function append(xs, ys) {\r\n    return concat([xs, ys]);\r\n}\r\n\r\nexport function cast(xs) {\r\n    return mkSeq(() => {\r\n        checkNonNull(\"source\", xs);\r\n        return Enumerator_cast(getEnumerator(xs));\r\n    });\r\n}\r\n\r\nexport function choose(chooser, xs) {\r\n    return generate(() => ofSeq(xs), (e) => {\r\n        let curr = void 0;\r\n        while ((curr == null) ? e[\"System.Collections.IEnumerator.MoveNext\"]() : false) {\r\n            curr = chooser(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        return curr;\r\n    }, (e_1) => {\r\n        e_1.Dispose();\r\n    });\r\n}\r\n\r\nexport function compareWith(comparer, xs, ys) {\r\n    const e1 = ofSeq(xs);\r\n    try {\r\n        const e2 = ofSeq(ys);\r\n        try {\r\n            let c = 0;\r\n            let b1 = e1[\"System.Collections.IEnumerator.MoveNext\"]();\r\n            let b2 = e2[\"System.Collections.IEnumerator.MoveNext\"]();\r\n            while (((c === 0) ? b1 : false) ? b2 : false) {\r\n                c = (comparer(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) | 0);\r\n                if (c === 0) {\r\n                    b1 = e1[\"System.Collections.IEnumerator.MoveNext\"]();\r\n                    b2 = e2[\"System.Collections.IEnumerator.MoveNext\"]();\r\n                }\r\n            }\r\n            return ((c !== 0) ? c : (b1 ? 1 : (b2 ? -1 : 0))) | 0;\r\n        }\r\n        finally {\r\n            e2.Dispose();\r\n        }\r\n    }\r\n    finally {\r\n        e1.Dispose();\r\n    }\r\n}\r\n\r\nexport function contains(value, xs, comparer) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        let found = false;\r\n        while ((!found) ? e[\"System.Collections.IEnumerator.MoveNext\"]() : false) {\r\n            found = comparer.Equals(value, e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        return found;\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function enumerateFromFunctions(create, moveNext, current) {\r\n    return generate(create, (x) => (moveNext(x) ? some(current(x)) : (void 0)), (x_1) => {\r\n        const matchValue = x_1;\r\n        if (isDisposable(matchValue)) {\r\n            matchValue.Dispose();\r\n        }\r\n    });\r\n}\r\n\r\nexport function enumerateThenFinally(source, compensation) {\r\n    const compensation_1 = compensation;\r\n    return mkSeq(() => {\r\n        try {\r\n            return Enumerator_enumerateThenFinally(compensation_1, ofSeq(source));\r\n        }\r\n        catch (matchValue) {\r\n            compensation_1();\r\n            throw matchValue;\r\n        }\r\n    });\r\n}\r\n\r\nexport function enumerateUsing(resource, source) {\r\n    const compensation = () => {\r\n        if (equals(resource, null)) {\r\n        }\r\n        else {\r\n            let copyOfStruct = resource;\r\n            copyOfStruct.Dispose();\r\n        }\r\n    };\r\n    return mkSeq(() => {\r\n        try {\r\n            return Enumerator_enumerateThenFinally(compensation, ofSeq(source(resource)));\r\n        }\r\n        catch (matchValue_1) {\r\n            compensation();\r\n            throw matchValue_1;\r\n        }\r\n    });\r\n}\r\n\r\nexport function enumerateWhile(guard, xs) {\r\n    return concat(unfold((i) => (guard() ? [xs, i + 1] : (void 0)), 0));\r\n}\r\n\r\nexport function filter(f, xs) {\r\n    return choose((x) => {\r\n        if (f(x)) {\r\n            return some(x);\r\n        }\r\n        else {\r\n            return void 0;\r\n        }\r\n    }, xs);\r\n}\r\n\r\nexport function exists(predicate, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        let found = false;\r\n        while ((!found) ? e[\"System.Collections.IEnumerator.MoveNext\"]() : false) {\r\n            found = predicate(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        return found;\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function exists2(predicate, xs, ys) {\r\n    const e1 = ofSeq(xs);\r\n    try {\r\n        const e2 = ofSeq(ys);\r\n        try {\r\n            let found = false;\r\n            while (((!found) ? e1[\"System.Collections.IEnumerator.MoveNext\"]() : false) ? e2[\"System.Collections.IEnumerator.MoveNext\"]() : false) {\r\n                found = predicate(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n            }\r\n            return found;\r\n        }\r\n        finally {\r\n            e2.Dispose();\r\n        }\r\n    }\r\n    finally {\r\n        e1.Dispose();\r\n    }\r\n}\r\n\r\nexport function exactlyOne(xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            const v = e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n            if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                throw (new Error((SR_inputSequenceTooLong + \"\\\\nParameter name: \") + \"source\"));\r\n            }\r\n            else {\r\n                return v;\r\n            }\r\n        }\r\n        else {\r\n            throw (new Error((SR_inputSequenceEmpty + \"\\\\nParameter name: \") + \"source\"));\r\n        }\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function tryExactlyOne(xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            const v = e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n            return e[\"System.Collections.IEnumerator.MoveNext\"]() ? (void 0) : some(v);\r\n        }\r\n        else {\r\n            return void 0;\r\n        }\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function tryFind(predicate, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        let res = void 0;\r\n        while ((res == null) ? e[\"System.Collections.IEnumerator.MoveNext\"]() : false) {\r\n            const c = e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n            if (predicate(c)) {\r\n                res = some(c);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function find(predicate, xs) {\r\n    const matchValue = tryFind(predicate, xs);\r\n    if (matchValue == null) {\r\n        return indexNotFound();\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFindBack(predicate, xs) {\r\n    return tryFindBack_1(predicate, toArray(xs));\r\n}\r\n\r\nexport function findBack(predicate, xs) {\r\n    const matchValue = tryFindBack(predicate, xs);\r\n    if (matchValue == null) {\r\n        return indexNotFound();\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFindIndex(predicate, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        const loop = (i_mut) => {\r\n            loop:\r\n            while (true) {\r\n                const i = i_mut;\r\n                if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                    if (predicate(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) {\r\n                        return i;\r\n                    }\r\n                    else {\r\n                        i_mut = (i + 1);\r\n                        continue loop;\r\n                    }\r\n                }\r\n                else {\r\n                    return void 0;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return loop(0);\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function findIndex(predicate, xs) {\r\n    const matchValue = tryFindIndex(predicate, xs);\r\n    if (matchValue == null) {\r\n        return indexNotFound() | 0;\r\n    }\r\n    else {\r\n        return matchValue | 0;\r\n    }\r\n}\r\n\r\nexport function tryFindIndexBack(predicate, xs) {\r\n    return tryFindIndexBack_1(predicate, toArray(xs));\r\n}\r\n\r\nexport function findIndexBack(predicate, xs) {\r\n    const matchValue = tryFindIndexBack(predicate, xs);\r\n    if (matchValue == null) {\r\n        return indexNotFound() | 0;\r\n    }\r\n    else {\r\n        return matchValue | 0;\r\n    }\r\n}\r\n\r\nexport function fold(folder, state, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        let acc = state;\r\n        while (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            acc = folder(acc, e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        return acc;\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function foldBack(folder, xs, state) {\r\n    return foldBack_1(folder, toArray(xs), state);\r\n}\r\n\r\nexport function fold2(folder, state, xs, ys) {\r\n    const e1 = ofSeq(xs);\r\n    try {\r\n        const e2 = ofSeq(ys);\r\n        try {\r\n            let acc = state;\r\n            while (e1[\"System.Collections.IEnumerator.MoveNext\"]() ? e2[\"System.Collections.IEnumerator.MoveNext\"]() : false) {\r\n                acc = folder(acc, e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n            }\r\n            return acc;\r\n        }\r\n        finally {\r\n            e2.Dispose();\r\n        }\r\n    }\r\n    finally {\r\n        e1.Dispose();\r\n    }\r\n}\r\n\r\nexport function foldBack2(folder, xs, ys, state) {\r\n    return foldBack2_1(folder, toArray(xs), toArray(ys), state);\r\n}\r\n\r\nexport function forAll(predicate, xs) {\r\n    return !exists((x) => (!predicate(x)), xs);\r\n}\r\n\r\nexport function forAll2(predicate, xs, ys) {\r\n    return !exists2((x, y) => (!predicate(x, y)), xs, ys);\r\n}\r\n\r\nexport function tryHead(xs) {\r\n    if (isArrayLike(xs)) {\r\n        return tryHead_1(xs);\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return tryHead_2(xs);\r\n    }\r\n    else {\r\n        const e = ofSeq(xs);\r\n        try {\r\n            return e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : (void 0);\r\n        }\r\n        finally {\r\n            e.Dispose();\r\n        }\r\n    }\r\n}\r\n\r\nexport function head(xs) {\r\n    const matchValue = tryHead(xs);\r\n    if (matchValue == null) {\r\n        throw (new Error((SR_inputSequenceEmpty + \"\\\\nParameter name: \") + \"source\"));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function initialize(count, f) {\r\n    return unfold((i) => ((i < count) ? [f(i), i + 1] : (void 0)), 0);\r\n}\r\n\r\nexport function initializeInfinite(f) {\r\n    return initialize(2147483647, f);\r\n}\r\n\r\nexport function isEmpty(xs) {\r\n    if (isArrayLike(xs)) {\r\n        return xs.length === 0;\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return isEmpty_1(xs);\r\n    }\r\n    else {\r\n        const e = ofSeq(xs);\r\n        try {\r\n            return !e[\"System.Collections.IEnumerator.MoveNext\"]();\r\n        }\r\n        finally {\r\n            e.Dispose();\r\n        }\r\n    }\r\n}\r\n\r\nexport function tryItem(index, xs) {\r\n    if (isArrayLike(xs)) {\r\n        return tryItem_1(index, xs);\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return tryItem_2(index, xs);\r\n    }\r\n    else {\r\n        const e = ofSeq(xs);\r\n        try {\r\n            const loop = (index_1_mut) => {\r\n                loop:\r\n                while (true) {\r\n                    const index_1 = index_1_mut;\r\n                    if (!e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                        return void 0;\r\n                    }\r\n                    else if (index_1 === 0) {\r\n                        return some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n                    }\r\n                    else {\r\n                        index_1_mut = (index_1 - 1);\r\n                        continue loop;\r\n                    }\r\n                    break;\r\n                }\r\n            };\r\n            return loop(index);\r\n        }\r\n        finally {\r\n            e.Dispose();\r\n        }\r\n    }\r\n}\r\n\r\nexport function item(index, xs) {\r\n    const matchValue = tryItem(index, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function iterate(action, xs) {\r\n    fold((unitVar0, x) => {\r\n        action(x);\r\n    }, void 0, xs);\r\n}\r\n\r\nexport function iterate2(action, xs, ys) {\r\n    fold2((unitVar0, x, y) => {\r\n        action(x, y);\r\n    }, void 0, xs, ys);\r\n}\r\n\r\nexport function iterateIndexed(action, xs) {\r\n    void fold((i, x) => {\r\n        action(i, x);\r\n        return (i + 1) | 0;\r\n    }, 0, xs);\r\n}\r\n\r\nexport function iterateIndexed2(action, xs, ys) {\r\n    void fold2((i, x, y) => {\r\n        action(i, x, y);\r\n        return (i + 1) | 0;\r\n    }, 0, xs, ys);\r\n}\r\n\r\nexport function tryLast(xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        const loop = (acc_mut) => {\r\n            loop:\r\n            while (true) {\r\n                const acc = acc_mut;\r\n                if (!e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                    return acc;\r\n                }\r\n                else {\r\n                    acc_mut = e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n                    continue loop;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(loop(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0);\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function last(xs) {\r\n    const matchValue = tryLast(xs);\r\n    if (matchValue == null) {\r\n        throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"source\"));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function length(xs) {\r\n    if (isArrayLike(xs)) {\r\n        return xs.length | 0;\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return length_1(xs) | 0;\r\n    }\r\n    else {\r\n        const e = ofSeq(xs);\r\n        try {\r\n            let count = 0;\r\n            while (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                count = ((count + 1) | 0);\r\n            }\r\n            return count | 0;\r\n        }\r\n        finally {\r\n            e.Dispose();\r\n        }\r\n    }\r\n}\r\n\r\nexport function map(mapping, xs) {\r\n    return generate(() => ofSeq(xs), (e) => (e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(mapping(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0)), (e_1) => {\r\n        e_1.Dispose();\r\n    });\r\n}\r\n\r\nexport function mapIndexed(mapping, xs) {\r\n    return generateIndexed(() => ofSeq(xs), (i, e) => (e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(mapping(i, e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0)), (e_1) => {\r\n        e_1.Dispose();\r\n    });\r\n}\r\n\r\nexport function indexed(xs) {\r\n    return mapIndexed((i, x) => [i, x], xs);\r\n}\r\n\r\nexport function map2(mapping, xs, ys) {\r\n    return generate(() => [ofSeq(xs), ofSeq(ys)], (tupledArg) => {\r\n        const e1 = tupledArg[0];\r\n        const e2 = tupledArg[1];\r\n        return (e1[\"System.Collections.IEnumerator.MoveNext\"]() ? e2[\"System.Collections.IEnumerator.MoveNext\"]() : false) ? some(mapping(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0);\r\n    }, (tupledArg_1) => {\r\n        try {\r\n            tupledArg_1[0].Dispose();\r\n        }\r\n        finally {\r\n            tupledArg_1[1].Dispose();\r\n        }\r\n    });\r\n}\r\n\r\nexport function mapIndexed2(mapping, xs, ys) {\r\n    return generateIndexed(() => [ofSeq(xs), ofSeq(ys)], (i, tupledArg) => {\r\n        const e1 = tupledArg[0];\r\n        const e2 = tupledArg[1];\r\n        return (e1[\"System.Collections.IEnumerator.MoveNext\"]() ? e2[\"System.Collections.IEnumerator.MoveNext\"]() : false) ? some(mapping(i, e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0);\r\n    }, (tupledArg_1) => {\r\n        try {\r\n            tupledArg_1[0].Dispose();\r\n        }\r\n        finally {\r\n            tupledArg_1[1].Dispose();\r\n        }\r\n    });\r\n}\r\n\r\nexport function map3(mapping, xs, ys, zs) {\r\n    return generate(() => [ofSeq(xs), ofSeq(ys), ofSeq(zs)], (tupledArg) => {\r\n        const e1 = tupledArg[0];\r\n        const e2 = tupledArg[1];\r\n        const e3 = tupledArg[2];\r\n        return ((e1[\"System.Collections.IEnumerator.MoveNext\"]() ? e2[\"System.Collections.IEnumerator.MoveNext\"]() : false) ? e3[\"System.Collections.IEnumerator.MoveNext\"]() : false) ? some(mapping(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e3[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0);\r\n    }, (tupledArg_1) => {\r\n        try {\r\n            tupledArg_1[0].Dispose();\r\n        }\r\n        finally {\r\n            try {\r\n                tupledArg_1[1].Dispose();\r\n            }\r\n            finally {\r\n                tupledArg_1[2].Dispose();\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function readOnly(xs) {\r\n    checkNonNull(\"source\", xs);\r\n    return map((x) => x, xs);\r\n}\r\n\r\nexport function cache(xs) {\r\n    let cached = false;\r\n    const xsCache = [];\r\n    return delay(() => {\r\n        if (!cached) {\r\n            cached = true;\r\n            return map((x) => {\r\n                void (xsCache.push(x));\r\n                return x;\r\n            }, xs);\r\n        }\r\n        else {\r\n            return xsCache;\r\n        }\r\n    });\r\n}\r\n\r\nexport function allPairs(xs, ys) {\r\n    const ysCache = cache(ys);\r\n    return delay(() => concat(map((x) => map((y) => [x, y], ysCache), xs)));\r\n}\r\n\r\nexport function mapFold(mapping, state, xs) {\r\n    const patternInput = mapFold_1(mapping, state, toArray(xs));\r\n    return [readOnly(patternInput[0]), patternInput[1]];\r\n}\r\n\r\nexport function mapFoldBack(mapping, xs, state) {\r\n    const patternInput = mapFoldBack_1(mapping, toArray(xs), state);\r\n    return [readOnly(patternInput[0]), patternInput[1]];\r\n}\r\n\r\nexport function tryPick(chooser, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        let res = void 0;\r\n        while ((res == null) ? e[\"System.Collections.IEnumerator.MoveNext\"]() : false) {\r\n            res = chooser(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        return res;\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function pick(chooser, xs) {\r\n    const matchValue = tryPick(chooser, xs);\r\n    if (matchValue == null) {\r\n        return indexNotFound();\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function reduce(folder, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        const loop = (acc_mut) => {\r\n            loop:\r\n            while (true) {\r\n                const acc = acc_mut;\r\n                if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                    acc_mut = folder(acc, e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n                    continue loop;\r\n                }\r\n                else {\r\n                    return acc;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            return loop(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        else {\r\n            throw (new Error(SR_inputSequenceEmpty));\r\n        }\r\n    }\r\n    finally {\r\n        e.Dispose();\r\n    }\r\n}\r\n\r\nexport function reduceBack(folder, xs) {\r\n    const arr = toArray(xs);\r\n    if (arr.length > 0) {\r\n        return arr.reduceRight(folder);\r\n    }\r\n    else {\r\n        throw (new Error(SR_inputSequenceEmpty));\r\n    }\r\n}\r\n\r\nexport function replicate(n, x) {\r\n    return initialize(n, (_arg1) => x);\r\n}\r\n\r\nexport function reverse(xs) {\r\n    return delay(() => ofArray(reverse_1(toArray(xs))));\r\n}\r\n\r\nexport function scan(folder, state, xs) {\r\n    return delay(() => {\r\n        let acc = state;\r\n        return concat([singleton(state), map((x) => {\r\n            acc = folder(acc, x);\r\n            return acc;\r\n        }, xs)]);\r\n    });\r\n}\r\n\r\nexport function scanBack(folder, xs, state) {\r\n    return delay(() => ofArray(scanBack_1(folder, toArray(xs), state)));\r\n}\r\n\r\nexport function skip(count, xs) {\r\n    return mkSeq(() => {\r\n        const e = ofSeq(xs);\r\n        try {\r\n            for (let i = 1; i <= count; i++) {\r\n                if (!e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                    throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"source\"));\r\n                }\r\n            }\r\n            return Enumerator_enumerateThenFinally(() => {\r\n            }, e);\r\n        }\r\n        catch (matchValue) {\r\n            e.Dispose();\r\n            throw matchValue;\r\n        }\r\n    });\r\n}\r\n\r\nexport function skipWhile(predicate, xs) {\r\n    return delay(() => {\r\n        let skipped = true;\r\n        return filter((x) => {\r\n            if (skipped) {\r\n                skipped = predicate(x);\r\n            }\r\n            return !skipped;\r\n        }, xs);\r\n    });\r\n}\r\n\r\nexport function tail(xs) {\r\n    return skip(1, xs);\r\n}\r\n\r\nexport function take(count, xs) {\r\n    return generateIndexed(() => ofSeq(xs), (i, e) => {\r\n        if (i < count) {\r\n            if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                return some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n            }\r\n            else {\r\n                throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"source\"));\r\n            }\r\n        }\r\n        else {\r\n            return void 0;\r\n        }\r\n    }, (e_1) => {\r\n        e_1.Dispose();\r\n    });\r\n}\r\n\r\nexport function takeWhile(predicate, xs) {\r\n    return generate(() => ofSeq(xs), (e) => ((e[\"System.Collections.IEnumerator.MoveNext\"]() ? predicate(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : false) ? some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : (void 0)), (e_1) => {\r\n        e_1.Dispose();\r\n    });\r\n}\r\n\r\nexport function truncate(count, xs) {\r\n    return generateIndexed(() => ofSeq(xs), (i, e) => (((i < count) ? e[\"System.Collections.IEnumerator.MoveNext\"]() : false) ? some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : (void 0)), (e_1) => {\r\n        e_1.Dispose();\r\n    });\r\n}\r\n\r\nexport function zip(xs, ys) {\r\n    return map2((x, y) => [x, y], xs, ys);\r\n}\r\n\r\nexport function zip3(xs, ys, zs) {\r\n    return map3((x, y, z) => [x, y, z], xs, ys, zs);\r\n}\r\n\r\nexport function collect(mapping, xs) {\r\n    return delay(() => concat(map(mapping, xs)));\r\n}\r\n\r\nexport function where(predicate, xs) {\r\n    return filter(predicate, xs);\r\n}\r\n\r\nexport function pairwise(xs) {\r\n    return delay(() => ofArray(pairwise_1(toArray(xs))));\r\n}\r\n\r\nexport function splitInto(chunks, xs) {\r\n    return delay(() => ofArray(map_1((arr) => ofArray(arr), splitInto_1(chunks, toArray(xs)))));\r\n}\r\n\r\nexport function windowed(windowSize, xs) {\r\n    return delay(() => ofArray(map_1((arr) => ofArray(arr), windowed_1(windowSize, toArray(xs)))));\r\n}\r\n\r\nexport function transpose(xss) {\r\n    return delay(() => ofArray(map_1((arr) => ofArray(arr), transpose_1(map_1((xs_1) => toArray(xs_1), toArray(xss))))));\r\n}\r\n\r\nexport function sortWith(comparer, xs) {\r\n    return delay(() => {\r\n        const arr = toArray(xs);\r\n        arr.sort(comparer);\r\n        return ofArray(arr);\r\n    });\r\n}\r\n\r\nexport function sort(xs, comparer) {\r\n    return sortWith((x, y) => comparer.Compare(x, y), xs);\r\n}\r\n\r\nexport function sortBy(projection, xs, comparer) {\r\n    return sortWith((x, y) => comparer.Compare(projection(x), projection(y)), xs);\r\n}\r\n\r\nexport function sortDescending(xs, comparer) {\r\n    return sortWith((x, y) => (comparer.Compare(x, y) * -1), xs);\r\n}\r\n\r\nexport function sortByDescending(projection, xs, comparer) {\r\n    return sortWith((x, y) => (comparer.Compare(projection(x), projection(y)) * -1), xs);\r\n}\r\n\r\nexport function sum(xs, adder) {\r\n    return fold((acc, x) => adder.Add(acc, x), adder.GetZero(), xs);\r\n}\r\n\r\nexport function sumBy(f, xs, adder) {\r\n    return fold((acc, x) => adder.Add(acc, f(x)), adder.GetZero(), xs);\r\n}\r\n\r\nexport function maxBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function max(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function minBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function min(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function average(xs, averager) {\r\n    let count = 0;\r\n    const total = fold((acc, x) => {\r\n        count = ((count + 1) | 0);\r\n        return averager.Add(acc, x);\r\n    }, averager.GetZero(), xs);\r\n    if (count === 0) {\r\n        throw (new Error(\"The input sequence was empty\\\\nParameter name: xs\"));\r\n    }\r\n    else {\r\n        return averager.DivideByInt(total, count);\r\n    }\r\n}\r\n\r\nexport function averageBy(f, xs, averager) {\r\n    let count = 0;\r\n    const total = fold((acc, x) => {\r\n        count = ((count + 1) | 0);\r\n        return averager.Add(acc, f(x));\r\n    }, averager.GetZero(), xs);\r\n    if (count === 0) {\r\n        throw (new Error(\"The input sequence was empty\\\\nParameter name: xs\"));\r\n    }\r\n    else {\r\n        return averager.DivideByInt(total, count);\r\n    }\r\n}\r\n\r\nexport function permute(f, xs) {\r\n    return delay(() => ofArray(permute_1(f, toArray(xs))));\r\n}\r\n\r\nexport function chunkBySize(chunkSize, xs) {\r\n    return delay(() => ofArray(map_1((arr) => ofArray(arr), chunkBySize_1(chunkSize, toArray(xs)))));\r\n}\r\n\r\n","import { structuralHash, equals } from \"./Util.js\";\r\nimport { HashIdentity_Structural, ComparisonIdentity_Structural } from \"./FSharp.Collections.js\";\r\nimport { StringBuilder__Append_Z721C83C5 } from \"./System.Text.js\";\r\n\r\nexport const LanguagePrimitives_GenericEqualityComparer = {\r\n    [\"System.Collections.IEqualityComparer.Equals541DA560\"](x, y) {\r\n        return equals(x, y);\r\n    },\r\n    [\"System.Collections.IEqualityComparer.GetHashCode4E60E31B\"](x_1) {\r\n        return structuralHash(x_1);\r\n    },\r\n};\r\n\r\nexport const LanguagePrimitives_GenericEqualityERComparer = {\r\n    [\"System.Collections.IEqualityComparer.Equals541DA560\"](x, y) {\r\n        return equals(x, y);\r\n    },\r\n    [\"System.Collections.IEqualityComparer.GetHashCode4E60E31B\"](x_1) {\r\n        return structuralHash(x_1);\r\n    },\r\n};\r\n\r\nexport function LanguagePrimitives_FastGenericComparer() {\r\n    return ComparisonIdentity_Structural();\r\n}\r\n\r\nexport function LanguagePrimitives_FastGenericComparerFromTable() {\r\n    return ComparisonIdentity_Structural();\r\n}\r\n\r\nexport function LanguagePrimitives_FastGenericEqualityComparer() {\r\n    return HashIdentity_Structural();\r\n}\r\n\r\nexport function LanguagePrimitives_FastGenericEqualityComparerFromTable() {\r\n    return HashIdentity_Structural();\r\n}\r\n\r\nexport function Operators_Failure(message) {\r\n    return new Error(message);\r\n}\r\n\r\nexport function Operators_FailurePattern(exn) {\r\n    return exn.message;\r\n}\r\n\r\nexport function Operators_NullArg(x) {\r\n    throw (new Error(x));\r\n}\r\n\r\nexport function Operators_Using(resource, action) {\r\n    try {\r\n        return action(resource);\r\n    }\r\n    finally {\r\n        if (equals(resource, null)) {\r\n        }\r\n        else {\r\n            resource.Dispose();\r\n        }\r\n    }\r\n}\r\n\r\nexport function Operators_Lock(_lockObj, action) {\r\n    return action();\r\n}\r\n\r\nexport function ExtraTopLevelOperators_LazyPattern(input) {\r\n    return input.Value;\r\n}\r\n\r\nexport function PrintfModule_PrintFormatToStringBuilderThen(continuation, builder, format) {\r\n    return format.cont((s) => {\r\n        void StringBuilder__Append_Z721C83C5(builder, s);\r\n        return continuation();\r\n    });\r\n}\r\n\r\nexport function PrintfModule_PrintFormatToStringBuilder(builder, format) {\r\n    return PrintfModule_PrintFormatToStringBuilderThen(() => {\r\n    }, builder, format);\r\n}\r\n\r\n","import { Record } from \"../Types.js\";\r\nimport { record_type, array_type, int32_type } from \"../Reflection.js\";\r\nimport { op_LeftShift, op_BitwiseAnd, op_Addition, compare, op_Subtraction, op_Division, equals, fromInteger, op_Multiply, op_Modulus, toInt, fromBits } from \"../Long.js\";\r\nimport { copy, initialize, map, fill } from \"../Array.js\";\r\nimport { toArray, empty, head, tail, isEmpty, cons } from \"../List.js\";\r\nimport { int32ToString } from \"../Util.js\";\r\nimport { isNullOrEmpty, join } from \"../String.js\";\r\n\r\nexport class BigNat extends Record {\r\n    constructor(bound, digits) {\r\n        super();\r\n        this.bound = (bound | 0);\r\n        this.digits = digits;\r\n    }\r\n}\r\n\r\nexport function BigNat$reflection() {\r\n    return record_type(\"BigInt.BigNat\", [], BigNat, () => [[\"bound\", int32_type], [\"digits\", array_type(int32_type)]]);\r\n}\r\n\r\nexport function BigNatModule_FFT_pow32(x_mut, n_mut) {\r\n    BigNatModule_FFT_pow32:\r\n    while (true) {\r\n        const x = x_mut, n = n_mut;\r\n        if (n === 0) {\r\n            return 1;\r\n        }\r\n        else if ((n % 2) === 0) {\r\n            x_mut = (x * x);\r\n            n_mut = (~(~(n / 2)));\r\n            continue BigNatModule_FFT_pow32;\r\n        }\r\n        else {\r\n            return (x * BigNatModule_FFT_pow32(x * x, ~(~(n / 2)))) | 0;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_FFT_leastBounding2Power(b) {\r\n    const findBounding2Power = (b_1_mut, tp_mut, i_mut) => {\r\n        findBounding2Power:\r\n        while (true) {\r\n            const b_1 = b_1_mut, tp = tp_mut, i = i_mut;\r\n            if (b_1 <= tp) {\r\n                return [tp, i];\r\n            }\r\n            else {\r\n                b_1_mut = b_1;\r\n                tp_mut = (tp * 2);\r\n                i_mut = (i + 1);\r\n                continue findBounding2Power;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return findBounding2Power(b, 1, 0);\r\n}\r\n\r\nexport const BigNatModule_FFT_p = fromBits(2013265921, 0, false);\r\n\r\nconst BigNatModule_FFT_patternInput$004075 = [27, 15, 31, 440564289];\r\n\r\nexport const BigNatModule_FFT_w = BigNatModule_FFT_patternInput$004075[3];\r\n\r\nexport const BigNatModule_FFT_m = BigNatModule_FFT_patternInput$004075[1];\r\n\r\nexport const BigNatModule_FFT_k = BigNatModule_FFT_patternInput$004075[0];\r\n\r\nexport const BigNatModule_FFT_g = BigNatModule_FFT_patternInput$004075[2];\r\n\r\nexport const BigNatModule_FFT_primeP = BigNatModule_FFT_p;\r\n\r\nexport const BigNatModule_FFT_maxBitsInsideFp = 30;\r\n\r\nexport const BigNatModule_FFT_Fp_p = 2013265921;\r\n\r\nexport const BigNatModule_FFT_Fp_p64 = fromBits(2013265921, 0, true);\r\n\r\nexport function BigNatModule_FFT_Fp_toInt(x) {\r\n    return ~(~x);\r\n}\r\n\r\nexport function BigNatModule_FFT_Fp_ofInt32(x) {\r\n    return x >>> 0;\r\n}\r\n\r\nexport const BigNatModule_FFT_Fp_mzero = 0;\r\n\r\nexport const BigNatModule_FFT_Fp_mone = 1;\r\n\r\nexport const BigNatModule_FFT_Fp_mtwo = 2;\r\n\r\nexport function BigNatModule_FFT_Fp_mpow(x_mut, n_mut) {\r\n    BigNatModule_FFT_Fp_mpow:\r\n    while (true) {\r\n        const x = x_mut, n = n_mut;\r\n        if (n === 0) {\r\n            return BigNatModule_FFT_Fp_mone;\r\n        }\r\n        else if ((n % 2) === 0) {\r\n            x_mut = (toInt(op_Modulus(op_Multiply(fromInteger(x, true, 6), fromInteger(x, true, 6)), BigNatModule_FFT_Fp_p64)) >>> 0);\r\n            n_mut = (~(~(n / 2)));\r\n            continue BigNatModule_FFT_Fp_mpow;\r\n        }\r\n        else {\r\n            const y_2 = BigNatModule_FFT_Fp_mpow(toInt(op_Modulus(op_Multiply(fromInteger(x, true, 6), fromInteger(x, true, 6)), BigNatModule_FFT_Fp_p64)) >>> 0, ~(~(n / 2)));\r\n            return toInt(op_Modulus(op_Multiply(fromInteger(x, true, 6), fromInteger(y_2, true, 6)), BigNatModule_FFT_Fp_p64)) >>> 0;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_FFT_Fp_mpowL(x_mut, n_mut) {\r\n    BigNatModule_FFT_Fp_mpowL:\r\n    while (true) {\r\n        const x = x_mut, n = n_mut;\r\n        if (equals(n, fromBits(0, 0, false))) {\r\n            return BigNatModule_FFT_Fp_mone;\r\n        }\r\n        else if (equals(op_Modulus(n, fromBits(2, 0, false)), fromBits(0, 0, false))) {\r\n            x_mut = (toInt(op_Modulus(op_Multiply(fromInteger(x, true, 6), fromInteger(x, true, 6)), BigNatModule_FFT_Fp_p64)) >>> 0);\r\n            n_mut = op_Division(n, fromBits(2, 0, false));\r\n            continue BigNatModule_FFT_Fp_mpowL;\r\n        }\r\n        else {\r\n            const y_2 = BigNatModule_FFT_Fp_mpowL(toInt(op_Modulus(op_Multiply(fromInteger(x, true, 6), fromInteger(x, true, 6)), BigNatModule_FFT_Fp_p64)) >>> 0, op_Division(n, fromBits(2, 0, false)));\r\n            return toInt(op_Modulus(op_Multiply(fromInteger(x, true, 6), fromInteger(y_2, true, 6)), BigNatModule_FFT_Fp_p64)) >>> 0;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_FFT_Fp_m2PowNthRoot(n) {\r\n    return BigNatModule_FFT_Fp_mpow(BigNatModule_FFT_w >>> 0, BigNatModule_FFT_pow32(2, BigNatModule_FFT_k - n));\r\n}\r\n\r\nexport function BigNatModule_FFT_Fp_minv(x) {\r\n    return BigNatModule_FFT_Fp_mpowL(x, op_Subtraction(BigNatModule_FFT_primeP, fromBits(2, 0, false)));\r\n}\r\n\r\nexport function BigNatModule_FFT_computeFFT(lambda, mu, n, w, u, res, offset) {\r\n    let x_1, x_3, y_5;\r\n    if (n === 1) {\r\n        res[offset] = u[mu];\r\n    }\r\n    else {\r\n        const halfN = (~(~(n / 2))) | 0;\r\n        const ww = toInt(op_Modulus(op_Multiply(fromInteger(w, true, 6), fromInteger(w, true, 6)), BigNatModule_FFT_Fp_p64)) >>> 0;\r\n        const offsetHalfN = (offset + halfN) | 0;\r\n        BigNatModule_FFT_computeFFT(lambda * 2, mu, halfN, ww, u, res, offset);\r\n        BigNatModule_FFT_computeFFT(lambda * 2, lambda + mu, halfN, ww, u, res, offsetHalfN);\r\n        let wj = BigNatModule_FFT_Fp_mone;\r\n        for (let j = 0; j <= (halfN - 1); j++) {\r\n            const even = res[offset + j];\r\n            const odd = res[offsetHalfN + j];\r\n            res[offset + j] = ((even + ((x_1 = wj, toInt(op_Modulus(op_Multiply(fromInteger(x_1, true, 6), fromInteger(odd, true, 6)), BigNatModule_FFT_Fp_p64)) >>> 0))) % BigNatModule_FFT_Fp_p);\r\n            res[offsetHalfN + j] = (((even + BigNatModule_FFT_Fp_p) - ((x_3 = wj, toInt(op_Modulus(op_Multiply(fromInteger(x_3, true, 6), fromInteger(odd, true, 6)), BigNatModule_FFT_Fp_p64)) >>> 0))) % BigNatModule_FFT_Fp_p);\r\n            wj = ((y_5 = wj, toInt(op_Modulus(op_Multiply(fromInteger(w, true, 6), fromInteger(y_5, true, 6)), BigNatModule_FFT_Fp_p64)) >>> 0));\r\n        }\r\n    }\r\n}\r\n\r\nexport function BigNatModule_FFT_computFftInPlace(n, w, u) {\r\n    const res = fill(new Uint32Array(n), 0, n, BigNatModule_FFT_Fp_mzero);\r\n    BigNatModule_FFT_computeFFT(1, 0, n, w, u, res, 0);\r\n    return res;\r\n}\r\n\r\nexport function BigNatModule_FFT_computeInverseFftInPlace(n, w, uT) {\r\n    const bigKInv = BigNatModule_FFT_Fp_minv(n >>> 0);\r\n    return map((y) => (toInt(op_Modulus(op_Multiply(fromInteger(bigKInv, true, 6), fromInteger(y, true, 6)), BigNatModule_FFT_Fp_p64)) >>> 0), BigNatModule_FFT_computFftInPlace(n, BigNatModule_FFT_Fp_minv(w), uT), Uint32Array);\r\n}\r\n\r\nexport const BigNatModule_FFT_maxTwoPower = 29;\r\n\r\nexport const BigNatModule_FFT_twoPowerTable = initialize(BigNatModule_FFT_maxTwoPower - 1, (i) => BigNatModule_FFT_pow32(2, i), Int32Array);\r\n\r\nexport function BigNatModule_FFT_computeFftPaddedPolynomialProduct(bigK, k, u, v) {\r\n    const w = BigNatModule_FFT_Fp_m2PowNthRoot(k);\r\n    const n = bigK | 0;\r\n    const uT = BigNatModule_FFT_computFftInPlace(n, w, u);\r\n    const vT = BigNatModule_FFT_computFftInPlace(n, w, v);\r\n    return BigNatModule_FFT_computeInverseFftInPlace(n, w, initialize(n, (i) => {\r\n        const x = uT[i];\r\n        const y = vT[i];\r\n        return toInt(op_Modulus(op_Multiply(fromInteger(x, true, 6), fromInteger(y, true, 6)), BigNatModule_FFT_Fp_p64)) >>> 0;\r\n    }, Uint32Array));\r\n}\r\n\r\nexport function BigNatModule_FFT_padTo(n, u) {\r\n    const uBound = u.length | 0;\r\n    return initialize(n, (i) => ((i < uBound) ? BigNatModule_FFT_Fp_ofInt32(u[i]) : BigNatModule_FFT_Fp_mzero), Uint32Array);\r\n}\r\n\r\nexport function BigNatModule_FFT_computeFftPolynomialProduct(degu, u, degv, v) {\r\n    const patternInput = BigNatModule_FFT_leastBounding2Power((degu + degv) + 1);\r\n    const bigK = patternInput[0] | 0;\r\n    const w = BigNatModule_FFT_Fp_m2PowNthRoot(patternInput[1]);\r\n    const u_1 = BigNatModule_FFT_padTo(bigK, u);\r\n    const v_1 = BigNatModule_FFT_padTo(bigK, v);\r\n    const n = bigK | 0;\r\n    const uT = BigNatModule_FFT_computFftInPlace(n, w, u_1);\r\n    const vT = BigNatModule_FFT_computFftInPlace(n, w, v_1);\r\n    return map((x_1) => BigNatModule_FFT_Fp_toInt(x_1), BigNatModule_FFT_computeInverseFftInPlace(n, w, initialize(n, (i) => {\r\n        const x = uT[i];\r\n        const y = vT[i];\r\n        return toInt(op_Modulus(op_Multiply(fromInteger(x, true, 6), fromInteger(y, true, 6)), BigNatModule_FFT_Fp_p64)) >>> 0;\r\n    }, Uint32Array)), Int32Array);\r\n}\r\n\r\nexport const BigNatModule_FFT_mzero = BigNatModule_FFT_Fp_mzero;\r\n\r\nexport const BigNatModule_FFT_mone = BigNatModule_FFT_Fp_mone;\r\n\r\nexport const BigNatModule_FFT_maxFp = ((BigNatModule_FFT_Fp_p + BigNatModule_FFT_Fp_p) - BigNatModule_FFT_mone) % BigNatModule_FFT_Fp_p;\r\n\r\nexport function BigNatModule_bound(n) {\r\n    return n.bound;\r\n}\r\n\r\nexport function BigNatModule_setBound(n, v) {\r\n    n.bound = (v | 0);\r\n}\r\n\r\nexport function BigNatModule_coeff(n, i) {\r\n    return n.digits[i];\r\n}\r\n\r\nexport function BigNatModule_coeff64(n, i) {\r\n    return fromInteger(BigNatModule_coeff(n, i), false, 2);\r\n}\r\n\r\nexport function BigNatModule_setCoeff(n, i, v) {\r\n    n.digits[i] = (v | 0);\r\n}\r\n\r\nexport function BigNatModule_pow64(x_mut, n_mut) {\r\n    BigNatModule_pow64:\r\n    while (true) {\r\n        const x = x_mut, n = n_mut;\r\n        if (n === 0) {\r\n            return fromBits(1, 0, false);\r\n        }\r\n        else if ((n % 2) === 0) {\r\n            x_mut = op_Multiply(x, x);\r\n            n_mut = (~(~(n / 2)));\r\n            continue BigNatModule_pow64;\r\n        }\r\n        else {\r\n            return op_Multiply(x, BigNatModule_pow64(op_Multiply(x, x), ~(~(n / 2))));\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_pow32(x_mut, n_mut) {\r\n    BigNatModule_pow32:\r\n    while (true) {\r\n        const x = x_mut, n = n_mut;\r\n        if (n === 0) {\r\n            return 1;\r\n        }\r\n        else if ((n % 2) === 0) {\r\n            x_mut = (x * x);\r\n            n_mut = (~(~(n / 2)));\r\n            continue BigNatModule_pow32;\r\n        }\r\n        else {\r\n            return (x * BigNatModule_pow32(x * x, ~(~(n / 2)))) | 0;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_hash(n) {\r\n    let res = 0;\r\n    for (let i = 0; i <= (n.bound - 1); i++) {\r\n        res = ((n.digits[i] + (res << 3)) | 0);\r\n    }\r\n    return res | 0;\r\n}\r\n\r\nexport function BigNatModule_maxInt(a, b) {\r\n    if (a < b) {\r\n        return b | 0;\r\n    }\r\n    else {\r\n        return a | 0;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_minInt(a, b) {\r\n    if (a < b) {\r\n        return a | 0;\r\n    }\r\n    else {\r\n        return b | 0;\r\n    }\r\n}\r\n\r\nexport const BigNatModule_baseBits = 24;\r\n\r\nexport const BigNatModule_baseN = 16777216;\r\n\r\nexport const BigNatModule_baseMask = 16777215;\r\n\r\nexport const BigNatModule_baseNi64 = fromBits(16777216, 0, false);\r\n\r\nexport const BigNatModule_baseMaski64 = fromBits(16777215, 0, false);\r\n\r\nexport const BigNatModule_baseMaskU = fromBits(16777215, 0, true);\r\n\r\nexport const BigNatModule_baseMask32A = 16777215;\r\n\r\nexport const BigNatModule_baseMask32B = 255;\r\n\r\nexport const BigNatModule_baseShift32B = 24;\r\n\r\nexport const BigNatModule_baseMask64A = 16777215;\r\n\r\nexport const BigNatModule_baseMask64B = 16777215;\r\n\r\nexport const BigNatModule_baseMask64C = 65535;\r\n\r\nexport const BigNatModule_baseShift64B = 24;\r\n\r\nexport const BigNatModule_baseShift64C = 48;\r\n\r\nexport function BigNatModule_divbase(x) {\r\n    return ~(~((x >>> 0) >>> BigNatModule_baseBits));\r\n}\r\n\r\nexport function BigNatModule_modbase(x) {\r\n    return x & BigNatModule_baseMask;\r\n}\r\n\r\nexport function BigNatModule_createN(b) {\r\n    return new BigNat(b, new Int32Array(b));\r\n}\r\n\r\nexport function BigNatModule_copyN(x) {\r\n    return new BigNat(x.bound, copy(x.digits));\r\n}\r\n\r\nexport function BigNatModule_normN(n) {\r\n    const findLeastBound = (na_mut, i_mut) => {\r\n        findLeastBound:\r\n        while (true) {\r\n            const na = na_mut, i = i_mut;\r\n            if ((i === -1) ? true : (na[i] !== 0)) {\r\n                return (i + 1) | 0;\r\n            }\r\n            else {\r\n                na_mut = na;\r\n                i_mut = (i - 1);\r\n                continue findLeastBound;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const bound = findLeastBound(n.digits, n.bound - 1) | 0;\r\n    n.bound = (bound | 0);\r\n    return n;\r\n}\r\n\r\nexport const BigNatModule_boundInt = 2;\r\n\r\nexport const BigNatModule_boundInt64 = 3;\r\n\r\nexport const BigNatModule_boundBase = 1;\r\n\r\nexport function BigNatModule_embed(x) {\r\n    const x_1 = ((x < 0) ? 0 : x) | 0;\r\n    if (x_1 < BigNatModule_baseN) {\r\n        const r = BigNatModule_createN(1);\r\n        r.digits[0] = (x_1 | 0);\r\n        return BigNatModule_normN(r);\r\n    }\r\n    else {\r\n        const r_1 = BigNatModule_createN(BigNatModule_boundInt);\r\n        for (let i = 0; i <= (BigNatModule_boundInt - 1); i++) {\r\n            r_1.digits[i] = (((~(~(x_1 / BigNatModule_pow32(BigNatModule_baseN, i)))) % BigNatModule_baseN) | 0);\r\n        }\r\n        return BigNatModule_normN(r_1);\r\n    }\r\n}\r\n\r\nexport function BigNatModule_embed64(x) {\r\n    const x_1 = (compare(x, fromBits(0, 0, false)) < 0) ? fromBits(0, 0, false) : x;\r\n    const r = BigNatModule_createN(BigNatModule_boundInt64);\r\n    for (let i = 0; i <= (BigNatModule_boundInt64 - 1); i++) {\r\n        r.digits[i] = ((~(~toInt(op_Modulus(op_Division(x_1, BigNatModule_pow64(BigNatModule_baseNi64, i)), BigNatModule_baseNi64)))) | 0);\r\n    }\r\n    return BigNatModule_normN(r);\r\n}\r\n\r\nexport function BigNatModule_eval32(n) {\r\n    if (n.bound === 1) {\r\n        return n.digits[0] | 0;\r\n    }\r\n    else {\r\n        let acc = 0;\r\n        for (let i = n.bound - 1; i >= 0; i--) {\r\n            acc = ((n.digits[i] + (BigNatModule_baseN * acc)) | 0);\r\n        }\r\n        return acc | 0;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_eval64(n) {\r\n    if (n.bound === 1) {\r\n        return fromInteger(n.digits[0], false, 2);\r\n    }\r\n    else {\r\n        let acc = fromBits(0, 0, false);\r\n        for (let i = n.bound - 1; i >= 0; i--) {\r\n            acc = op_Addition(fromInteger(n.digits[i], false, 2), op_Multiply(BigNatModule_baseNi64, acc));\r\n        }\r\n        return acc;\r\n    }\r\n}\r\n\r\nexport const BigNatModule_one = BigNatModule_embed(1);\r\n\r\nexport const BigNatModule_zero = BigNatModule_embed(0);\r\n\r\nexport function BigNatModule_restrictTo(d, n) {\r\n    return new BigNat(BigNatModule_minInt(d, n.bound), n.digits);\r\n}\r\n\r\nexport function BigNatModule_shiftUp(d, n) {\r\n    const m = BigNatModule_createN(n.bound + d);\r\n    for (let i = 0; i <= (n.bound - 1); i++) {\r\n        m.digits[i + d] = (n.digits[i] | 0);\r\n    }\r\n    return m;\r\n}\r\n\r\nexport function BigNatModule_shiftDown(d, n) {\r\n    if ((n.bound - d) <= 0) {\r\n        return BigNatModule_zero;\r\n    }\r\n    else {\r\n        const m = BigNatModule_createN(n.bound - d);\r\n        for (let i = 0; i <= (m.bound - 1); i++) {\r\n            m.digits[i] = (n.digits[i + d] | 0);\r\n        }\r\n        return m;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_degree(n) {\r\n    return n.bound - 1;\r\n}\r\n\r\nexport function BigNatModule_addP(i_mut, n_mut, c_mut, p_mut, q_mut, r_mut) {\r\n    let z, i_1, z_1, i_2;\r\n    BigNatModule_addP:\r\n    while (true) {\r\n        const i = i_mut, n = n_mut, c = c_mut, p = p_mut, q = q_mut, r = r_mut;\r\n        if (i < n) {\r\n            const x = ((((z = p, (i_1 = (i | 0), (i_1 < z.bound) ? z.digits[i_1] : 0))) + ((z_1 = q, (i_2 = (i | 0), (i_2 < z_1.bound) ? z_1.digits[i_2] : 0)))) + c) | 0;\r\n            r.digits[i] = (BigNatModule_modbase(x) | 0);\r\n            i_mut = (i + 1);\r\n            n_mut = n;\r\n            c_mut = BigNatModule_divbase(x);\r\n            p_mut = p;\r\n            q_mut = q;\r\n            r_mut = r;\r\n            continue BigNatModule_addP;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_add(p, q) {\r\n    const rbound = (1 + BigNatModule_maxInt(p.bound, q.bound)) | 0;\r\n    const r = BigNatModule_createN(rbound);\r\n    BigNatModule_addP(0, rbound, 0, p, q, r);\r\n    return BigNatModule_normN(r);\r\n}\r\n\r\nexport function BigNatModule_subP(i_mut, n_mut, c_mut, p_mut, q_mut, r_mut) {\r\n    let z, i_1, z_1, i_2;\r\n    BigNatModule_subP:\r\n    while (true) {\r\n        const i = i_mut, n = n_mut, c = c_mut, p = p_mut, q = q_mut, r = r_mut;\r\n        if (i < n) {\r\n            const x = ((((z = p, (i_1 = (i | 0), (i_1 < z.bound) ? z.digits[i_1] : 0))) - ((z_1 = q, (i_2 = (i | 0), (i_2 < z_1.bound) ? z_1.digits[i_2] : 0)))) + c) | 0;\r\n            if (x > 0) {\r\n                r.digits[i] = (BigNatModule_modbase(x) | 0);\r\n                i_mut = (i + 1);\r\n                n_mut = n;\r\n                c_mut = BigNatModule_divbase(x);\r\n                p_mut = p;\r\n                q_mut = q;\r\n                r_mut = r;\r\n                continue BigNatModule_subP;\r\n            }\r\n            else {\r\n                const x_1 = (x + BigNatModule_baseN) | 0;\r\n                r.digits[i] = (BigNatModule_modbase(x_1) | 0);\r\n                i_mut = (i + 1);\r\n                n_mut = n;\r\n                c_mut = (BigNatModule_divbase(x_1) - 1);\r\n                p_mut = p;\r\n                q_mut = q;\r\n                r_mut = r;\r\n                continue BigNatModule_subP;\r\n            }\r\n        }\r\n        else {\r\n            return c !== 0;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_sub(p, q) {\r\n    const rbound = BigNatModule_maxInt(p.bound, q.bound) | 0;\r\n    const r = BigNatModule_createN(rbound);\r\n    if (BigNatModule_subP(0, rbound, 0, p, q, r)) {\r\n        return BigNatModule_embed(0);\r\n    }\r\n    else {\r\n        return BigNatModule_normN(r);\r\n    }\r\n}\r\n\r\nexport function BigNatModule_isZero(p) {\r\n    return p.bound === 0;\r\n}\r\n\r\nexport function BigNatModule_IsZero(p) {\r\n    return BigNatModule_isZero(p);\r\n}\r\n\r\nexport function BigNatModule_isOne(p) {\r\n    if (p.bound === 1) {\r\n        return p.digits[0] === 1;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_equal(p, q) {\r\n    if (p.bound === q.bound) {\r\n        const check = (pa_mut, qa_mut, i_mut) => {\r\n            check:\r\n            while (true) {\r\n                const pa = pa_mut, qa = qa_mut, i = i_mut;\r\n                if (i === -1) {\r\n                    return true;\r\n                }\r\n                else if (pa[i] === qa[i]) {\r\n                    pa_mut = pa;\r\n                    qa_mut = qa;\r\n                    i_mut = (i - 1);\r\n                    continue check;\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return check(p.digits, q.digits, p.bound - 1);\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_shiftCompare(p, pn, q, qn) {\r\n    if ((p.bound + pn) < (q.bound + qn)) {\r\n        return -1;\r\n    }\r\n    else if ((p.bound + pn) > (q.bound + pn)) {\r\n        return 1;\r\n    }\r\n    else {\r\n        const check = (pa_mut, qa_mut, i_mut) => {\r\n            check:\r\n            while (true) {\r\n                const pa = pa_mut, qa = qa_mut, i = i_mut;\r\n                if (i === -1) {\r\n                    return 0;\r\n                }\r\n                else {\r\n                    const pai = ((i < pn) ? 0 : pa[i - pn]) | 0;\r\n                    const qai = ((i < qn) ? 0 : qa[i - qn]) | 0;\r\n                    if (pai === qai) {\r\n                        pa_mut = pa;\r\n                        qa_mut = qa;\r\n                        i_mut = (i - 1);\r\n                        continue check;\r\n                    }\r\n                    else if (pai < qai) {\r\n                        return -1;\r\n                    }\r\n                    else {\r\n                        return 1;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return check(p.digits, q.digits, (p.bound + pn) - 1) | 0;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_compare(p, q) {\r\n    if (p.bound < q.bound) {\r\n        return -1;\r\n    }\r\n    else if (p.bound > q.bound) {\r\n        return 1;\r\n    }\r\n    else {\r\n        const check = (pa_mut, qa_mut, i_mut) => {\r\n            check:\r\n            while (true) {\r\n                const pa = pa_mut, qa = qa_mut, i = i_mut;\r\n                if (i === -1) {\r\n                    return 0;\r\n                }\r\n                else if (pa[i] === qa[i]) {\r\n                    pa_mut = pa;\r\n                    qa_mut = qa;\r\n                    i_mut = (i - 1);\r\n                    continue check;\r\n                }\r\n                else if (pa[i] < qa[i]) {\r\n                    return -1;\r\n                }\r\n                else {\r\n                    return 1;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return check(p.digits, q.digits, p.bound - 1) | 0;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_lt(p, q) {\r\n    return BigNatModule_compare(p, q) === -1;\r\n}\r\n\r\nexport function BigNatModule_gt(p, q) {\r\n    return BigNatModule_compare(p, q) === 1;\r\n}\r\n\r\nexport function BigNatModule_lte(p, q) {\r\n    return BigNatModule_compare(p, q) !== 1;\r\n}\r\n\r\nexport function BigNatModule_gte(p, q) {\r\n    return BigNatModule_compare(p, q) !== -1;\r\n}\r\n\r\nexport function BigNatModule_min(a, b) {\r\n    if (BigNatModule_lt(a, b)) {\r\n        return a;\r\n    }\r\n    else {\r\n        return b;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_max(a, b) {\r\n    if (BigNatModule_lt(a, b)) {\r\n        return b;\r\n    }\r\n    else {\r\n        return a;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_contributeArr(a_mut, i_mut, c_mut) {\r\n    BigNatModule_contributeArr:\r\n    while (true) {\r\n        const a = a_mut, i = i_mut, c = c_mut;\r\n        const x = op_Addition(fromInteger(a[i], false, 2), c);\r\n        const c_1 = op_Division(x, BigNatModule_baseNi64);\r\n        const x_3 = (~(~toInt(op_BitwiseAnd(x, BigNatModule_baseMaski64)))) | 0;\r\n        a[i] = (x_3 | 0);\r\n        if (compare(c_1, fromBits(0, 0, false)) > 0) {\r\n            a_mut = a;\r\n            i_mut = (i + 1);\r\n            c_mut = c_1;\r\n            continue BigNatModule_contributeArr;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_scale(k, p) {\r\n    const r = BigNatModule_createN(p.bound + BigNatModule_boundInt);\r\n    const k_1 = fromInteger(k, false, 2);\r\n    for (let i = 0; i <= (p.bound - 1); i++) {\r\n        BigNatModule_contributeArr(r.digits, i, op_Multiply(k_1, fromInteger(p.digits[i], false, 2)));\r\n    }\r\n    return BigNatModule_normN(r);\r\n}\r\n\r\nexport function BigNatModule_mulSchoolBookBothSmall(p, q) {\r\n    const r = BigNatModule_createN(2);\r\n    const rak = op_Multiply(fromInteger(p, false, 2), fromInteger(q, false, 2));\r\n    BigNatModule_setCoeff(r, 0, ~(~toInt(op_BitwiseAnd(rak, BigNatModule_baseMaski64))));\r\n    BigNatModule_setCoeff(r, 1, ~(~toInt(op_Division(rak, BigNatModule_baseNi64))));\r\n    return BigNatModule_normN(r);\r\n}\r\n\r\nexport function BigNatModule_mulSchoolBookCarry(r_mut, c_mut, k_mut) {\r\n    BigNatModule_mulSchoolBookCarry:\r\n    while (true) {\r\n        const r = r_mut, c = c_mut, k = k_mut;\r\n        if (compare(c, fromBits(0, 0, false)) > 0) {\r\n            const rak = op_Addition(BigNatModule_coeff64(r, k), c);\r\n            BigNatModule_setCoeff(r, k, ~(~toInt(op_BitwiseAnd(rak, BigNatModule_baseMaski64))));\r\n            r_mut = r;\r\n            c_mut = op_Division(rak, BigNatModule_baseNi64);\r\n            k_mut = (k + 1);\r\n            continue BigNatModule_mulSchoolBookCarry;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_mulSchoolBookOneSmall(p, q) {\r\n    const bp = BigNatModule_bound(p) | 0;\r\n    const r = BigNatModule_createN(bp + 1);\r\n    const q_1 = fromInteger(q, false, 2);\r\n    let c = fromBits(0, 0, false);\r\n    for (let i = 0; i <= (bp - 1); i++) {\r\n        const rak = op_Addition(op_Addition(c, BigNatModule_coeff64(r, i)), op_Multiply(BigNatModule_coeff64(p, i), q_1));\r\n        BigNatModule_setCoeff(r, i, ~(~toInt(op_BitwiseAnd(rak, BigNatModule_baseMaski64))));\r\n        c = op_Division(rak, BigNatModule_baseNi64);\r\n    }\r\n    BigNatModule_mulSchoolBookCarry(r, c, bp);\r\n    return BigNatModule_normN(r);\r\n}\r\n\r\nexport function BigNatModule_mulSchoolBookNeitherSmall(p, q) {\r\n    const r = BigNatModule_createN(p.bound + q.bound);\r\n    const ra = r.digits;\r\n    for (let i = 0; i <= (p.bound - 1); i++) {\r\n        const pai = fromInteger(p.digits[i], false, 2);\r\n        let c = fromBits(0, 0, false);\r\n        let k = i;\r\n        for (let j = 0; j <= (q.bound - 1); j++) {\r\n            const qaj = fromInteger(q.digits[j], false, 2);\r\n            const rak = op_Addition(op_Addition(fromInteger(ra[k], false, 2), c), op_Multiply(pai, qaj));\r\n            ra[k] = ((~(~toInt(op_BitwiseAnd(rak, BigNatModule_baseMaski64)))) | 0);\r\n            c = op_Division(rak, BigNatModule_baseNi64);\r\n            k = ((k + 1) | 0);\r\n        }\r\n        BigNatModule_mulSchoolBookCarry(r, c, k);\r\n    }\r\n    return BigNatModule_normN(r);\r\n}\r\n\r\nexport function BigNatModule_mulSchoolBook(p, q) {\r\n    const pSmall = BigNatModule_bound(p) === 1;\r\n    const qSmall = BigNatModule_bound(q) === 1;\r\n    if (pSmall ? qSmall : false) {\r\n        return BigNatModule_mulSchoolBookBothSmall(BigNatModule_coeff(p, 0), BigNatModule_coeff(q, 0));\r\n    }\r\n    else if (pSmall) {\r\n        return BigNatModule_mulSchoolBookOneSmall(q, BigNatModule_coeff(p, 0));\r\n    }\r\n    else if (qSmall) {\r\n        return BigNatModule_mulSchoolBookOneSmall(p, BigNatModule_coeff(q, 0));\r\n    }\r\n    else {\r\n        return BigNatModule_mulSchoolBookNeitherSmall(p, q);\r\n    }\r\n}\r\n\r\nexport class BigNatModule_encoding extends Record {\r\n    constructor(bigL, twoToBigL, k, bigK, bigN, split, splits) {\r\n        super();\r\n        this.bigL = (bigL | 0);\r\n        this.twoToBigL = (twoToBigL | 0);\r\n        this.k = (k | 0);\r\n        this.bigK = (bigK | 0);\r\n        this.bigN = (bigN | 0);\r\n        this.split = (split | 0);\r\n        this.splits = splits;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_encoding$reflection() {\r\n    return record_type(\"BigInt.BigNatModule.encoding\", [], BigNatModule_encoding, () => [[\"bigL\", int32_type], [\"twoToBigL\", int32_type], [\"k\", int32_type], [\"bigK\", int32_type], [\"bigN\", int32_type], [\"split\", int32_type], [\"splits\", array_type(int32_type)]]);\r\n}\r\n\r\nexport function BigNatModule_mkEncoding(bigL, k, bigK, bigN) {\r\n    return new BigNatModule_encoding(bigL, BigNatModule_pow32(2, bigL), k, bigK, bigN, ~(~(BigNatModule_baseBits / bigL)), initialize(~(~(BigNatModule_baseBits / bigL)), (i) => BigNatModule_pow32(2, bigL * i), Int32Array));\r\n}\r\n\r\nexport const BigNatModule_table = [BigNatModule_mkEncoding(1, 28, 268435456, 268435456), BigNatModule_mkEncoding(2, 26, 67108864, 134217728), BigNatModule_mkEncoding(3, 24, 16777216, 50331648), BigNatModule_mkEncoding(4, 22, 4194304, 16777216), BigNatModule_mkEncoding(5, 20, 1048576, 5242880), BigNatModule_mkEncoding(6, 18, 262144, 1572864), BigNatModule_mkEncoding(7, 16, 65536, 458752), BigNatModule_mkEncoding(8, 14, 16384, 131072), BigNatModule_mkEncoding(9, 12, 4096, 36864), BigNatModule_mkEncoding(10, 10, 1024, 10240), BigNatModule_mkEncoding(11, 8, 256, 2816), BigNatModule_mkEncoding(12, 6, 64, 768), BigNatModule_mkEncoding(13, 4, 16, 208)];\r\n\r\nexport function BigNatModule_calculateTableTow(bigL) {\r\n    const k = (BigNatModule_FFT_maxBitsInsideFp - (2 * bigL)) | 0;\r\n    const bigK = BigNatModule_pow64(fromBits(2, 0, false), k);\r\n    return [bigL, k, bigK, op_Multiply(bigK, fromInteger(bigL, false, 2))];\r\n}\r\n\r\nexport function BigNatModule_encodingGivenResultBits(bitsRes) {\r\n    const selectFrom = (i_mut) => {\r\n        selectFrom:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (((i + 1) < BigNatModule_table.length) ? (bitsRes < BigNatModule_table[i + 1].bigN) : false) {\r\n                i_mut = (i + 1);\r\n                continue selectFrom;\r\n            }\r\n            else {\r\n                return BigNatModule_table[i];\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    if (bitsRes >= BigNatModule_table[0].bigN) {\r\n        throw (new Error(\"Product is huge, around 268435456 bits, beyond quickmul\"));\r\n    }\r\n    else {\r\n        return selectFrom(0);\r\n    }\r\n}\r\n\r\nexport const BigNatModule_bitmask = initialize(BigNatModule_baseBits, (i) => (BigNatModule_pow32(2, i) - 1), Int32Array);\r\n\r\nexport const BigNatModule_twopowers = initialize(BigNatModule_baseBits, (i) => BigNatModule_pow32(2, i), Int32Array);\r\n\r\nexport const BigNatModule_twopowersI64 = initialize(BigNatModule_baseBits, (i) => BigNatModule_pow64(fromBits(2, 0, false), i));\r\n\r\nexport function BigNatModule_wordBits(word) {\r\n    const hi = (k_mut) => {\r\n        hi:\r\n        while (true) {\r\n            const k = k_mut;\r\n            if (k === 0) {\r\n                return 0;\r\n            }\r\n            else if ((word & BigNatModule_twopowers[k - 1]) !== 0) {\r\n                return k | 0;\r\n            }\r\n            else {\r\n                k_mut = (k - 1);\r\n                continue hi;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return hi(BigNatModule_baseBits) | 0;\r\n}\r\n\r\nexport function BigNatModule_bits(u) {\r\n    if (u.bound === 0) {\r\n        return 0;\r\n    }\r\n    else {\r\n        return ((BigNatModule_degree(u) * BigNatModule_baseBits) + BigNatModule_wordBits(u.digits[BigNatModule_degree(u)])) | 0;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_extractBits(n, enc, bi) {\r\n    let z, i, z_1, i_1, z_2, i_2;\r\n    const biw = (~(~(bi / BigNatModule_baseBits))) | 0;\r\n    const bjw = (~(~(((bi + enc.bigL) - 1) / BigNatModule_baseBits))) | 0;\r\n    if (biw !== bjw) {\r\n        const xbit = (bi % BigNatModule_baseBits) | 0;\r\n        return (((((z = n, (i = (biw | 0), (i < z.bound) ? z.digits[i] : 0))) >> xbit) | (((z_1 = n, (i_1 = (bjw | 0), (i_1 < z_1.bound) ? z_1.digits[i_1] : 0))) << (BigNatModule_baseBits - xbit))) & BigNatModule_bitmask[enc.bigL]) | 0;\r\n    }\r\n    else {\r\n        return ((((z_2 = n, (i_2 = (biw | 0), (i_2 < z_2.bound) ? z_2.digits[i_2] : 0))) >> (bi % BigNatModule_baseBits)) & BigNatModule_bitmask[enc.bigL]) | 0;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_encodePoly(enc, n) {\r\n    const poly = fill(new Uint32Array(enc.bigK), 0, enc.bigK, BigNatModule_FFT_Fp_ofInt32(0));\r\n    const biMax = (n.bound * BigNatModule_baseBits) | 0;\r\n    const encoder = (i_mut, bi_mut) => {\r\n        encoder:\r\n        while (true) {\r\n            const i = i_mut, bi = bi_mut;\r\n            if ((i === enc.bigK) ? true : (bi > biMax)) {\r\n            }\r\n            else {\r\n                const pi = BigNatModule_extractBits(n, enc, bi) | 0;\r\n                poly[i] = BigNatModule_FFT_Fp_ofInt32(pi);\r\n                i_mut = (i + 1);\r\n                bi_mut = (bi + enc.bigL);\r\n                continue encoder;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    encoder(0, 0);\r\n    return poly;\r\n}\r\n\r\nexport function BigNatModule_decodeResultBits(enc, poly) {\r\n    let n = 0;\r\n    for (let i = 0; i <= (poly.length - 1); i++) {\r\n        if (poly[i] !== BigNatModule_FFT_mzero) {\r\n            n = (i | 0);\r\n        }\r\n    }\r\n    return (((BigNatModule_FFT_maxBitsInsideFp + (enc.bigL * n)) + 1) + 1) | 0;\r\n}\r\n\r\nexport function BigNatModule_decodePoly(enc, poly) {\r\n    const rbound = ((~(~(BigNatModule_decodeResultBits(enc, poly) / BigNatModule_baseBits))) + 1) | 0;\r\n    const r = BigNatModule_createN(rbound);\r\n    const evaluate = (i_mut, j_mut, d_mut) => {\r\n        evaluate:\r\n        while (true) {\r\n            const i = i_mut, j = j_mut, d = d_mut;\r\n            if (i === enc.bigK) {\r\n            }\r\n            else {\r\n                if (j >= rbound) {\r\n                }\r\n                else {\r\n                    BigNatModule_contributeArr(r.digits, j, op_Multiply(fromInteger(BigNatModule_FFT_Fp_toInt(poly[i]), false, 2), BigNatModule_twopowersI64[d]));\r\n                }\r\n                const d_1 = (d + enc.bigL) | 0;\r\n                const patternInput = (d_1 >= BigNatModule_baseBits) ? [j + 1, d_1 - BigNatModule_baseBits] : [j, d_1];\r\n                i_mut = (i + 1);\r\n                j_mut = patternInput[0];\r\n                d_mut = patternInput[1];\r\n                continue evaluate;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    evaluate(0, 0, 0);\r\n    return BigNatModule_normN(r);\r\n}\r\n\r\nexport function BigNatModule_quickMulUsingFft(u, v) {\r\n    const enc = BigNatModule_encodingGivenResultBits(BigNatModule_bits(u) + BigNatModule_bits(v));\r\n    return BigNatModule_normN(BigNatModule_decodePoly(enc, BigNatModule_FFT_computeFftPaddedPolynomialProduct(enc.bigK, enc.k, BigNatModule_encodePoly(enc, u), BigNatModule_encodePoly(enc, v))));\r\n}\r\n\r\nexport const BigNatModule_minDigitsKaratsuba = 16;\r\n\r\nexport function BigNatModule_recMulKaratsuba(mul, p, q) {\r\n    const bmax = BigNatModule_maxInt(p.bound, q.bound) | 0;\r\n    if (bmax > BigNatModule_minDigitsKaratsuba) {\r\n        const k = (~(~(bmax / 2))) | 0;\r\n        const a0 = BigNatModule_restrictTo(k, p);\r\n        const a1 = BigNatModule_shiftDown(k, p);\r\n        const b0 = BigNatModule_restrictTo(k, q);\r\n        const b1 = BigNatModule_shiftDown(k, q);\r\n        const q0 = mul(a0, b0);\r\n        const q1 = mul(BigNatModule_add(a0, a1), BigNatModule_add(b0, b1));\r\n        const q2 = mul(a1, b1);\r\n        return BigNatModule_add(q0, BigNatModule_shiftUp(k, BigNatModule_add(BigNatModule_sub(q1, BigNatModule_add(q0, q2)), BigNatModule_shiftUp(k, q2))));\r\n    }\r\n    else {\r\n        return BigNatModule_mulSchoolBook(p, q);\r\n    }\r\n}\r\n\r\nexport function BigNatModule_mulKaratsuba(x, y) {\r\n    return BigNatModule_recMulKaratsuba((x_1, y_1) => BigNatModule_mulKaratsuba(x_1, y_1), x, y);\r\n}\r\n\r\nexport const BigNatModule_productDigitsUpperSchoolBook = ~(~(64000 / BigNatModule_baseBits));\r\n\r\nexport const BigNatModule_singleDigitForceSchoolBook = ~(~(32000 / BigNatModule_baseBits));\r\n\r\nexport const BigNatModule_productDigitsUpperFft = ~(~(BigNatModule_table[0].bigN / BigNatModule_baseBits));\r\n\r\nexport function BigNatModule_mul(p, q) {\r\n    return BigNatModule_mulSchoolBook(p, q);\r\n}\r\n\r\nexport function BigNatModule_scaleSubInPlace(x, f, a, n) {\r\n    const patternInput = [x.digits, BigNatModule_degree(x)];\r\n    const x_1 = patternInput[0];\r\n    const patternInput_1 = [a.digits, BigNatModule_degree(a)];\r\n    const ad = patternInput_1[1] | 0;\r\n    const a_1 = patternInput_1[0];\r\n    const f_1 = fromInteger(f, false, 2);\r\n    let j = 0;\r\n    let z = op_Multiply(f_1, fromInteger(a_1[0], false, 2));\r\n    while ((compare(z, fromBits(0, 0, false)) > 0) ? true : (j < ad)) {\r\n        if (j > patternInput[1]) {\r\n            throw (new Error(\"scaleSubInPlace: pre-condition did not apply, result would be -ve\"));\r\n        }\r\n        let zLo = ~(~toInt(op_BitwiseAnd(z, BigNatModule_baseMaski64)));\r\n        let zHi = op_Division(z, BigNatModule_baseNi64);\r\n        if (zLo <= x_1[j + n]) {\r\n            x_1[j + n] = ((x_1[j + n] - zLo) | 0);\r\n        }\r\n        else {\r\n            x_1[j + n] = ((x_1[j + n] + (BigNatModule_baseN - zLo)) | 0);\r\n            zHi = op_Addition(zHi, fromBits(1, 0, false));\r\n        }\r\n        if (j < ad) {\r\n            z = op_Addition(zHi, op_Multiply(f_1, fromInteger(a_1[j + 1], false, 2)));\r\n        }\r\n        else {\r\n            z = zHi;\r\n        }\r\n        j = ((j + 1) | 0);\r\n    }\r\n    void BigNatModule_normN(x);\r\n}\r\n\r\nexport function BigNatModule_scaleSub(x, f, a, n) {\r\n    const freshx = BigNatModule_add(x, BigNatModule_zero);\r\n    BigNatModule_scaleSubInPlace(freshx, f, a, n);\r\n    return BigNatModule_normN(freshx);\r\n}\r\n\r\nexport function BigNatModule_scaleAddInPlace(x, f, a, n) {\r\n    const patternInput = [x.digits, BigNatModule_degree(x)];\r\n    const x_1 = patternInput[0];\r\n    const patternInput_1 = [a.digits, BigNatModule_degree(a)];\r\n    const ad = patternInput_1[1] | 0;\r\n    const a_1 = patternInput_1[0];\r\n    const f_1 = fromInteger(f, false, 2);\r\n    let j = 0;\r\n    let z = op_Multiply(f_1, fromInteger(a_1[0], false, 2));\r\n    while ((compare(z, fromBits(0, 0, false)) > 0) ? true : (j < ad)) {\r\n        if (j > patternInput[1]) {\r\n            throw (new Error(\"scaleSubInPlace: pre-condition did not apply, result would be -ve\"));\r\n        }\r\n        let zLo = ~(~toInt(op_BitwiseAnd(z, BigNatModule_baseMaski64)));\r\n        let zHi = op_Division(z, BigNatModule_baseNi64);\r\n        if (zLo < (BigNatModule_baseN - x_1[j + n])) {\r\n            x_1[j + n] = ((x_1[j + n] + zLo) | 0);\r\n        }\r\n        else {\r\n            x_1[j + n] = ((zLo - (BigNatModule_baseN - x_1[j + n])) | 0);\r\n            zHi = op_Addition(zHi, fromBits(1, 0, false));\r\n        }\r\n        if (j < ad) {\r\n            z = op_Addition(zHi, op_Multiply(f_1, fromInteger(a_1[j + 1], false, 2)));\r\n        }\r\n        else {\r\n            z = zHi;\r\n        }\r\n        j = ((j + 1) | 0);\r\n    }\r\n    void BigNatModule_normN(x);\r\n}\r\n\r\nexport function BigNatModule_scaleAdd(x, f, a, n) {\r\n    const freshx = BigNatModule_add(x, BigNatModule_zero);\r\n    BigNatModule_scaleAddInPlace(freshx, f, a, n);\r\n    return BigNatModule_normN(freshx);\r\n}\r\n\r\nexport function BigNatModule_removeFactor(x, a, n) {\r\n    const patternInput = [BigNatModule_degree(a), BigNatModule_degree(x)];\r\n    const degx = patternInput[1] | 0;\r\n    const dega = patternInput[0] | 0;\r\n    if (degx < (dega + n)) {\r\n        return 0;\r\n    }\r\n    else {\r\n        const patternInput_1 = [a.digits, x.digits];\r\n        const xa = patternInput_1[1];\r\n        const aa = patternInput_1[0];\r\n        const f = ((dega === 0) ? ((degx === n) ? (~(~(xa[n] / aa[0]))) : (~(~toInt(op_Division(op_Addition(op_Multiply(fromInteger(xa[degx], false, 2), BigNatModule_baseNi64), fromInteger(xa[degx - 1], false, 2)), fromInteger(aa[0], false, 2)))))) : ((degx === (dega + n)) ? (~(~(xa[degx] / (aa[dega] + 1)))) : (~(~toInt(op_Division(op_Addition(op_Multiply(fromInteger(xa[degx], false, 2), BigNatModule_baseNi64), fromInteger(xa[degx - 1], false, 2)), op_Addition(fromInteger(aa[dega], false, 2), fromBits(1, 0, false)))))))) | 0;\r\n        if (f === 0) {\r\n            if (BigNatModule_shiftCompare(a, n, x, 0) !== 1) {\r\n                return 1;\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        }\r\n        else {\r\n            return f | 0;\r\n        }\r\n    }\r\n}\r\n\r\nexport function BigNatModule_divmod(b, a) {\r\n    if (BigNatModule_isZero(a)) {\r\n        throw (new Error());\r\n    }\r\n    else if (BigNatModule_degree(b) < BigNatModule_degree(a)) {\r\n        return [BigNatModule_zero, b];\r\n    }\r\n    else {\r\n        const x = BigNatModule_copyN(b);\r\n        const d = BigNatModule_createN(((BigNatModule_degree(b) - BigNatModule_degree(a)) + 1) + 1);\r\n        let p = BigNatModule_degree(b);\r\n        const m = BigNatModule_degree(a) | 0;\r\n        let n = p - m;\r\n        const Invariant = (tupledArg) => {\r\n        };\r\n        let finished = false;\r\n        while (!finished) {\r\n            Invariant([d, x, n, p]);\r\n            const f = BigNatModule_removeFactor(x, a, n) | 0;\r\n            if (f > 0) {\r\n                BigNatModule_scaleSubInPlace(x, f, a, n);\r\n                BigNatModule_scaleAddInPlace(d, f, BigNatModule_one, n);\r\n                Invariant([d, x, n, p]);\r\n            }\r\n            else {\r\n                finished = ((f === 0) ? (n === 0) : false);\r\n                if (!finished) {\r\n                    if (p === (m + n)) {\r\n                        Invariant([d, x, n - 1, p]);\r\n                        n = ((n - 1) | 0);\r\n                    }\r\n                    else {\r\n                        Invariant([d, x, n - 1, p - 1]);\r\n                        n = ((n - 1) | 0);\r\n                        p = ((p - 1) | 0);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return [BigNatModule_normN(d), BigNatModule_normN(x)];\r\n    }\r\n}\r\n\r\nexport function BigNatModule_div(b, a) {\r\n    return BigNatModule_divmod(b, a)[0];\r\n}\r\n\r\nexport function BigNatModule_rem(b, a) {\r\n    return BigNatModule_divmod(b, a)[1];\r\n}\r\n\r\nexport function BigNatModule_bitAnd(a, b) {\r\n    const r = BigNatModule_createN(BigNatModule_minInt(a.bound, b.bound));\r\n    for (let i = 0; i <= (r.bound - 1); i++) {\r\n        r.digits[i] = ((a.digits[i] & b.digits[i]) | 0);\r\n    }\r\n    return BigNatModule_normN(r);\r\n}\r\n\r\nexport function BigNatModule_bitOr(a, b) {\r\n    const r = BigNatModule_createN(BigNatModule_maxInt(a.bound, b.bound));\r\n    for (let i = 0; i <= (a.bound - 1); i++) {\r\n        r.digits[i] = ((r.digits[i] | a.digits[i]) | 0);\r\n    }\r\n    for (let i_1 = 0; i_1 <= (b.bound - 1); i_1++) {\r\n        r.digits[i_1] = ((r.digits[i_1] | b.digits[i_1]) | 0);\r\n    }\r\n    return BigNatModule_normN(r);\r\n}\r\n\r\nexport function BigNatModule_bitXor(a, b) {\r\n    const r = BigNatModule_createN(BigNatModule_maxInt(a.bound, b.bound));\r\n    for (let i = 0; i <= (a.bound - 1); i++) {\r\n        r.digits[i] = ((r.digits[i] ^ a.digits[i]) | 0);\r\n    }\r\n    for (let i_1 = 0; i_1 <= (b.bound - 1); i_1++) {\r\n        r.digits[i_1] = ((r.digits[i_1] ^ b.digits[i_1]) | 0);\r\n    }\r\n    return BigNatModule_normN(r);\r\n}\r\n\r\nexport function BigNatModule_hcf(a, b) {\r\n    const hcfloop = (a_1_mut, b_1_mut) => {\r\n        hcfloop:\r\n        while (true) {\r\n            const a_1 = a_1_mut, b_1 = b_1_mut;\r\n            if (BigNatModule_equal(BigNatModule_zero, a_1)) {\r\n                return b_1;\r\n            }\r\n            else {\r\n                a_1_mut = BigNatModule_divmod(b_1, a_1)[1];\r\n                b_1_mut = a_1;\r\n                continue hcfloop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    if (BigNatModule_lt(a, b)) {\r\n        return hcfloop(a, b);\r\n    }\r\n    else {\r\n        return hcfloop(b, a);\r\n    }\r\n}\r\n\r\nexport const BigNatModule_two = BigNatModule_embed(2);\r\n\r\nexport function BigNatModule_powi(x, n) {\r\n    const power = (acc_mut, x_1_mut, n_1_mut) => {\r\n        power:\r\n        while (true) {\r\n            const acc = acc_mut, x_1 = x_1_mut, n_1 = n_1_mut;\r\n            if (n_1 === 0) {\r\n                return acc;\r\n            }\r\n            else if ((n_1 % 2) === 0) {\r\n                acc_mut = acc;\r\n                x_1_mut = BigNatModule_mul(x_1, x_1);\r\n                n_1_mut = (~(~(n_1 / 2)));\r\n                continue power;\r\n            }\r\n            else {\r\n                acc_mut = BigNatModule_mul(x_1, acc);\r\n                x_1_mut = BigNatModule_mul(x_1, x_1);\r\n                n_1_mut = (~(~(n_1 / 2)));\r\n                continue power;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return power(BigNatModule_one, x, n);\r\n}\r\n\r\nexport function BigNatModule_pow(x, n) {\r\n    const power = (acc_mut, x_1_mut, n_1_mut) => {\r\n        power:\r\n        while (true) {\r\n            const acc = acc_mut, x_1 = x_1_mut, n_1 = n_1_mut;\r\n            if (BigNatModule_isZero(n_1)) {\r\n                return acc;\r\n            }\r\n            else {\r\n                const patternInput = BigNatModule_divmod(n_1, BigNatModule_two);\r\n                const ndiv2 = patternInput[0];\r\n                if (BigNatModule_isZero(patternInput[1])) {\r\n                    acc_mut = acc;\r\n                    x_1_mut = BigNatModule_mul(x_1, x_1);\r\n                    n_1_mut = ndiv2;\r\n                    continue power;\r\n                }\r\n                else {\r\n                    acc_mut = BigNatModule_mul(x_1, acc);\r\n                    x_1_mut = BigNatModule_mul(x_1, x_1);\r\n                    n_1_mut = ndiv2;\r\n                    continue power;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return power(BigNatModule_one, x, n);\r\n}\r\n\r\nexport function BigNatModule_toFloat(n) {\r\n    const evalFloat = (acc_mut, k_mut, i_mut) => {\r\n        evalFloat:\r\n        while (true) {\r\n            const acc = acc_mut, k = k_mut, i = i_mut;\r\n            if (i === n.bound) {\r\n                return acc;\r\n            }\r\n            else {\r\n                acc_mut = (acc + (k * n.digits[i]));\r\n                k_mut = (k * BigNatModule_baseN);\r\n                i_mut = (i + 1);\r\n                continue evalFloat;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return evalFloat(0, 1, 0);\r\n}\r\n\r\nexport function BigNatModule_ofInt32(n) {\r\n    return BigNatModule_embed(n);\r\n}\r\n\r\nexport function BigNatModule_ofInt64(n) {\r\n    return BigNatModule_embed64(n);\r\n}\r\n\r\nexport function BigNatModule_toUInt32(n) {\r\n    const matchValue = n.bound | 0;\r\n    switch (matchValue) {\r\n        case 0: {\r\n            return 0;\r\n        }\r\n        case 1: {\r\n            const value = n.digits[0] | 0;\r\n            return value >>> 0;\r\n        }\r\n        case 2: {\r\n            const patternInput = [n.digits[0], n.digits[1]];\r\n            const xB = patternInput[1] | 0;\r\n            if (xB > BigNatModule_baseMask32B) {\r\n                throw (new Error());\r\n            }\r\n            return ((patternInput[0] & BigNatModule_baseMask32A) >>> 0) + ((((xB & BigNatModule_baseMask32B) >>> 0) << BigNatModule_baseShift32B) >>> 0);\r\n        }\r\n        default: {\r\n            throw (new Error());\r\n        }\r\n    }\r\n}\r\n\r\nexport function BigNatModule_toUInt64(n) {\r\n    const matchValue = n.bound | 0;\r\n    switch (matchValue) {\r\n        case 0: {\r\n            return fromBits(0, 0, true);\r\n        }\r\n        case 1: {\r\n            return fromInteger(n.digits[0], true, 2);\r\n        }\r\n        case 2: {\r\n            const patternInput = [n.digits[0], n.digits[1]];\r\n            return op_Addition(fromInteger(patternInput[0] & BigNatModule_baseMask64A, true, 2), op_LeftShift(fromInteger(patternInput[1] & BigNatModule_baseMask64B, true, 2), BigNatModule_baseShift64B));\r\n        }\r\n        case 3: {\r\n            const patternInput_1 = [n.digits[0], n.digits[1], n.digits[2]];\r\n            const xC = patternInput_1[2] | 0;\r\n            if (xC > BigNatModule_baseMask64C) {\r\n                throw (new Error());\r\n            }\r\n            return op_Addition(op_Addition(fromInteger(patternInput_1[0] & BigNatModule_baseMask64A, true, 2), op_LeftShift(fromInteger(patternInput_1[1] & BigNatModule_baseMask64B, true, 2), BigNatModule_baseShift64B)), op_LeftShift(fromInteger(xC & BigNatModule_baseMask64C, true, 2), BigNatModule_baseShift64C));\r\n        }\r\n        default: {\r\n            throw (new Error());\r\n        }\r\n    }\r\n}\r\n\r\nexport function BigNatModule_toString(n) {\r\n    const degn = BigNatModule_degree(n) | 0;\r\n    const route = (prior_mut, k_mut, ten2k_mut) => {\r\n        route:\r\n        while (true) {\r\n            const prior = prior_mut, k = k_mut, ten2k = ten2k_mut;\r\n            if (BigNatModule_degree(ten2k) > degn) {\r\n                return cons([k, ten2k], prior);\r\n            }\r\n            else {\r\n                prior_mut = cons([k, ten2k], prior);\r\n                k_mut = (k + 1);\r\n                ten2k_mut = BigNatModule_mul(ten2k, ten2k);\r\n                continue route;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const collect = (isLeading_mut, digits_mut, n_1_mut, _arg1_mut) => {\r\n        collect:\r\n        while (true) {\r\n            const isLeading = isLeading_mut, digits = digits_mut, n_1 = n_1_mut, _arg1 = _arg1_mut;\r\n            if (!isEmpty(_arg1)) {\r\n                const prior_1 = tail(_arg1);\r\n                const patternInput = BigNatModule_divmod(n_1, head(_arg1)[1]);\r\n                const nL = patternInput[1];\r\n                const nH = patternInput[0];\r\n                if (isLeading ? BigNatModule_isZero(nH) : false) {\r\n                    isLeading_mut = isLeading;\r\n                    digits_mut = digits;\r\n                    n_1_mut = nL;\r\n                    _arg1_mut = prior_1;\r\n                    continue collect;\r\n                }\r\n                else {\r\n                    isLeading_mut = isLeading;\r\n                    digits_mut = collect(false, digits, nL, prior_1);\r\n                    n_1_mut = nH;\r\n                    _arg1_mut = prior_1;\r\n                    continue collect;\r\n                }\r\n            }\r\n            else {\r\n                const n_2 = BigNatModule_eval32(n_1) | 0;\r\n                if (isLeading ? (n_2 === 0) : false) {\r\n                    return digits;\r\n                }\r\n                else {\r\n                    return cons(int32ToString(n_2), digits);\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const digits_4 = collect(true, empty(), n, route(empty(), 0, BigNatModule_embed(10)));\r\n    if (isEmpty(digits_4)) {\r\n        return \"0\";\r\n    }\r\n    else {\r\n        return join(\"\", toArray(digits_4));\r\n    }\r\n}\r\n\r\nexport function BigNatModule_ofString(str) {\r\n    const len = str.length | 0;\r\n    if (isNullOrEmpty(str)) {\r\n        throw (new Error(\"empty string\\\\nParameter name: str\"));\r\n    }\r\n    const ten = BigNatModule_embed(10);\r\n    const build = (acc_mut, i_mut) => {\r\n        build:\r\n        while (true) {\r\n            const acc = acc_mut, i = i_mut;\r\n            if (i === len) {\r\n                return acc;\r\n            }\r\n            else {\r\n                const d = (str[i].charCodeAt(0) - \"0\".charCodeAt(0)) | 0;\r\n                if ((0 <= d) ? (d <= 9) : false) {\r\n                    acc_mut = BigNatModule_add(BigNatModule_mul(ten, acc), BigNatModule_embed(d));\r\n                    i_mut = (i + 1);\r\n                    continue build;\r\n                }\r\n                else {\r\n                    throw (new Error());\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return build(BigNatModule_embed(0), 0);\r\n}\r\n\r\nexport function BigNatModule_isSmall(n) {\r\n    return n.bound <= 1;\r\n}\r\n\r\nexport function BigNatModule_getSmall(n) {\r\n    const z = n;\r\n    const i = 0;\r\n    if (i < z.bound) {\r\n        return z.digits[i] | 0;\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\n\r\nexport function BigNatModule_factorial(n) {\r\n    const productR = (a, b) => {\r\n        if (BigNatModule_equal(a, b)) {\r\n            return a;\r\n        }\r\n        else {\r\n            const m = BigNatModule_div(BigNatModule_add(a, b), BigNatModule_ofInt32(2));\r\n            return BigNatModule_mul(productR(a, m), productR(BigNatModule_add(m, BigNatModule_one), b));\r\n        }\r\n    };\r\n    return productR(BigNatModule_one, n);\r\n}\r\n\r\n","// Adapted from https://github.com/MikeMcl/big.js/blob/0f94dc9110d55c4f324a47ba6a2e832ce23ac589/big.mjs\n/* tslint:disable */\nimport { combineHashCodes } from \"../Util.js\";\nimport { symbol } from \"../Numeric.js\";\n// The shared prototype object.\nvar P = {\n    GetHashCode() { return combineHashCodes([this.s, this.e].concat(this.c)); },\n    Equals(x) { return !this.cmp(x); },\n    CompareTo(x) { return this.cmp(x); },\n    [symbol]() {\n        const _this = this;\n        return {\n            multiply: y => _this.mul(y),\n            toPrecision: sd => _this.toPrecision(sd),\n            toExponential: dp => _this.toExponential(dp),\n            toFixed: dp => _this.toFixed(dp),\n            toHex: () => (Number(_this) >>> 0).toString(16),\n        };\n    }\n};\n/*\n *  big.js v6.0.3\n *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\n *  Copyright (c) 2020 Michael Mclaughlin\n *  https://github.com/MikeMcl/big.js/LICENCE.md\n */\n/************************************** EDITABLE DEFAULTS *****************************************/\n// The default values below must be integers within the stated ranges.\n/*\n * The maximum number of decimal places (DP) of the results of operations involving division:\n * div and sqrt, and pow with negative exponents.\n */\nvar DP = 28, // 0 to MAX_DP\n/*\n * The rounding mode (RM) used when rounding to the above decimal places.\n *\n *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\n *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\n *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\n *  3  Away from zero.                                  (ROUND_UP)\n */\nRM = 1, // 0, 1, 2 or 3\n// The maximum value of DP and Big.DP.\nMAX_DP = 1E6, // 0 to 1000000\n// The maximum magnitude of the exponent argument to the pow method.\nMAX_POWER = 1E6, // 1 to 1000000\n/*\n * The negative exponent (NE) at and beneath which toString returns exponential notation.\n * (JavaScript numbers: -7)\n * -1000000 is the minimum recommended exponent value of a Big.\n */\nNE = -29, // 0 to -1000000\n/*\n * The positive exponent (PE) at and above which toString returns exponential notation.\n * (JavaScript numbers: 21)\n * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.\n */\nPE = 29, // 0 to 1000000\n/*\n * When true, an error will be thrown if a primitive number is passed to the Big constructor,\n * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a\n * primitive number without a loss of precision.\n */\nSTRICT = false, // true or false\n/**************************************************************************************************/\n// Error messages.\nNAME = '[big.js] ', INVALID = NAME + 'Invalid ', INVALID_DP = INVALID + 'decimal places', INVALID_RM = INVALID + 'rounding mode', DIV_BY_ZERO = NAME + 'Division by zero', UNDEFINED = void 0, NUMERIC = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\n/*\n * Create and return a Big constructor.\n */\nfunction _Big_() {\n    /*\n     * The Big constructor and exported function.\n     * Create and return a new instance of a Big number object.\n     *\n     * n {number|string|Big} A numeric value.\n     */\n    function Big(n) {\n        var x = this;\n        // Enable constructor usage without new.\n        if (!(x instanceof Big))\n            return n === UNDEFINED ? _Big_() : new Big(n);\n        // Duplicate.\n        if (n instanceof Big) {\n            x.s = n.s;\n            x.e = n.e;\n            x.c = n.c.slice();\n            normalize(x);\n        }\n        else {\n            if (typeof n !== 'string') {\n                if (Big.strict === true) {\n                    throw TypeError(INVALID + 'number');\n                }\n                // Minus zero?\n                n = n === 0 && 1 / n < 0 ? '-0' : String(n);\n            }\n            parse(x, n);\n        }\n        // Retain a reference to this Big constructor.\n        // Shadow Big.prototype.constructor which points to Object.\n        x.constructor = Big;\n    }\n    Big.prototype = P;\n    Big.DP = DP;\n    Big.RM = RM;\n    Big.NE = NE;\n    Big.PE = PE;\n    Big.strict = STRICT;\n    return Big;\n}\nfunction normalize(x) {\n    // x = round(x, DP, 0);\n    if (x.c.length > 1 && !x.c[0]) {\n        let i = x.c.findIndex(x => x);\n        x.c = x.c.slice(i);\n        x.e = x.e - i;\n    }\n}\n/*\n * Parse the number or string value passed to a Big constructor.\n *\n * x {Big} A Big number instance.\n * n {number|string} A numeric value.\n */\nfunction parse(x, n) {\n    var e, i, nl;\n    if (!NUMERIC.test(n)) {\n        throw Error(INVALID + 'number');\n    }\n    // Determine sign.\n    x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;\n    // Decimal point?\n    if ((e = n.indexOf('.')) > -1)\n        n = n.replace('.', '');\n    // Exponential form?\n    if ((i = n.search(/e/i)) > 0) {\n        // Determine exponent.\n        if (e < 0)\n            e = i;\n        e += +n.slice(i + 1);\n        n = n.substring(0, i);\n    }\n    else if (e < 0) {\n        // Integer.\n        e = n.length;\n    }\n    nl = n.length;\n    // Determine leading zeros before decimal point.\n    for (i = 0; i < e && i < nl && n.charAt(i) == '0';)\n        ++i;\n    // original version (ignores decimal point).\n    // // Determine leading zeros.\n    // for (i = 0; i < nl && n.charAt(i) == '0';) ++i;\n    if (i == nl) {\n        // Zero.\n        x.c = [x.e = 0];\n    }\n    else {\n        x.e = e - i - 1;\n        x.c = [];\n        // Convert string to array of digits without leading zeros\n        for (e = 0; i < nl;)\n            x.c[e++] = +n.charAt(i++);\n        // older version (doesn't keep trailing zeroes).\n        // // Determine trailing zeros.\n        // for (; nl > 0 && n.charAt(--nl) == '0';);\n        // // Convert string to array of digits without leading/trailing zeros.\n        // for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);\n    }\n    x = round(x, Big.DP + 1, Big.RM);\n    return x;\n}\n/*\n * Round Big x to a maximum of sd significant digits using rounding mode rm.\n *\n * x {Big} The Big to round.\n * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.\n * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n * [more] {boolean} Whether the result of division was truncated.\n */\nfunction round(x, sd, rm, more) {\n    var xc = x.c;\n    if (rm === UNDEFINED)\n        rm = Big.RM;\n    if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {\n        throw Error(INVALID_RM);\n    }\n    if (sd < 1) {\n        more =\n            rm === 3 && (more || !!xc[0]) || sd === 0 && (rm === 1 && xc[0] >= 5 ||\n                rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED)));\n        xc.length = 1;\n        if (more) {\n            // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n            x.e = x.e - sd + 1;\n            xc[0] = 1;\n        }\n        else {\n            // Zero.\n            xc[0] = x.e = 0;\n        }\n    }\n    else if (sd < xc.length) {\n        // xc[sd] is the digit after the digit that may be rounded up.\n        const isZero = xc.findIndex((xci, idx) => idx >= sd && xci > 0) < 0;\n        more =\n            rm === 1 && xc[sd] >= 5 ||\n                rm === 2 && (xc[sd] > 5 || xc[sd] === 5 &&\n                    (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) ||\n                rm === 3 && (more || !isZero);\n        // Remove any digits after the required precision.\n        xc.length = sd--;\n        // Round up?\n        if (more) {\n            // Rounding up may mean the previous digit has to be rounded up.\n            for (; ++xc[sd] > 9;) {\n                xc[sd] = 0;\n                if (!sd--) {\n                    ++x.e;\n                    xc.unshift(1);\n                }\n            }\n        }\n        // Remove trailing zeros.\n        for (sd = xc.length; !xc[--sd];)\n            xc.pop();\n    }\n    return x;\n}\n/*\n * Return a string representing the value of Big x in normal or exponential notation.\n * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.\n */\nfunction stringify(x, doExponential, isNonzero) {\n    var e = x.e, s = x.c.join(''), n = s.length;\n    // Exponential notation?\n    if (doExponential) {\n        s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;\n        // Normal notation.\n    }\n    else if (e < 0) {\n        for (; ++e;)\n            s = '0' + s;\n        s = '0.' + s;\n    }\n    else if (e > 0) {\n        if (++e > n) {\n            for (e -= n; e--;)\n                s += '0';\n        }\n        else if (e < n) {\n            s = s.slice(0, e) + '.' + s.slice(e);\n        }\n    }\n    else if (n > 1) {\n        s = s.charAt(0) + '.' + s.slice(1);\n    }\n    return x.s < 0 && isNonzero ? '-' + s : s;\n}\n// Prototype/instance methods\n/*\n * Return a new Big whose value is the absolute value of this Big.\n */\nP.abs = function () {\n    var x = new this.constructor(this);\n    x.s = 1;\n    return x;\n};\n/*\n * Return 1 if the value of this Big is greater than the value of Big y,\n *       -1 if the value of this Big is less than the value of Big y, or\n *        0 if they have the same value.\n */\nP.cmp = function (y) {\n    var isneg, Big = this.constructor, x = new Big(this), y = new Big(y), xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;\n    // Either zero?\n    if (!xc[0] || !yc[0])\n        return !xc[0] ? !yc[0] ? 0 : -j : i;\n    // Signs differ?\n    if (i != j)\n        return i;\n    isneg = i < 0;\n    // Compare exponents.\n    if (k != l)\n        return k > l ^ isneg ? 1 : -1;\n    // Compare digit by digit.\n    j = Math.max(xc.length, yc.length);\n    for (i = 0; i < j; i++) {\n        k = i < xc.length ? xc[i] : 0;\n        l = i < yc.length ? yc[i] : 0;\n        if (k != l)\n            return k > l ^ isneg ? 1 : -1;\n    }\n    return 0;\n    // original version (doesn't compare well trailing zeroes, e.g. 1.0 with 1.00)\n    // j = (k = xc.length) < (l = yc.length) ? k : l;\n    // // Compare digit by digit.\n    // for (i = -1; ++i < j;) {\n    //   if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;\n    // }\n    // // Compare lengths.\n    // return k == l ? 0 : k > l ^ isneg ? 1 : -1;\n};\n/*\n * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,\n * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\n */\nP.div = function (y) {\n    var Big = this.constructor, x = new Big(this), y = new Big(y), a = x.c, // dividend\n    b = y.c, // divisor\n    k = x.s == y.s ? 1 : -1, dp = Big.DP;\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n        throw Error(INVALID_DP);\n    }\n    // Divisor is zero?\n    if (!b[0]) {\n        throw Error(DIV_BY_ZERO);\n    }\n    // Dividend is 0? Return +-0.\n    if (!a[0]) {\n        y.s = k;\n        y.c = [y.e = 0];\n        return y;\n    }\n    var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), // remainder\n    rl = r.length, q = y, // quotient\n    qc = q.c = [], qi = 0, p = dp + (q.e = x.e - y.e) + 1; // precision of the result\n    q.s = k;\n    k = p < 0 ? 0 : p;\n    // Create version of divisor with leading zero.\n    bz.unshift(0);\n    // Add zeros to make remainder as long as divisor.\n    for (; rl++ < bl;)\n        r.push(0);\n    do {\n        // n is how many times the divisor goes into current remainder.\n        for (n = 0; n < 10; n++) {\n            // Compare divisor and remainder.\n            if (bl != (rl = r.length)) {\n                cmp = bl > rl ? 1 : -1;\n            }\n            else {\n                for (ri = -1, cmp = 0; ++ri < bl;) {\n                    if (b[ri] != r[ri]) {\n                        cmp = b[ri] > r[ri] ? 1 : -1;\n                        break;\n                    }\n                }\n            }\n            // If divisor < remainder, subtract divisor from remainder.\n            if (cmp < 0) {\n                // Remainder can't be more than 1 digit longer than divisor.\n                // Equalise lengths using divisor with extra leading zero?\n                for (bt = rl == bl ? b : bz; rl;) {\n                    if (r[--rl] < bt[rl]) {\n                        ri = rl;\n                        for (; ri && !r[--ri];)\n                            r[ri] = 9;\n                        --r[ri];\n                        r[rl] += 10;\n                    }\n                    r[rl] -= bt[rl];\n                }\n                for (; !r[0];)\n                    r.shift();\n            }\n            else {\n                break;\n            }\n        }\n        // Add the digit n to the result array.\n        qc[qi++] = cmp ? n : ++n;\n        // Update the remainder.\n        if (r[0] && cmp)\n            r[rl] = a[ai] || 0;\n        else\n            r = [a[ai]];\n    } while ((ai++ < al || r[0] !== UNDEFINED) && k--);\n    // Leading zero? Do not remove if result is simply zero (qi == 1).\n    if (!qc[0] && qi != 1) {\n        // There can't be more than one zero.\n        qc.shift();\n        q.e--;\n        p--;\n    }\n    // Round?\n    if (qi > p)\n        round(q, p, Big.RM, r[0] !== UNDEFINED);\n    return q;\n};\n/*\n * Return true if the value of this Big is equal to the value of Big y, otherwise return false.\n */\nP.eq = function (y) {\n    return this.cmp(y) === 0;\n};\n/*\n * Return true if the value of this Big is greater than the value of Big y, otherwise return\n * false.\n */\nP.gt = function (y) {\n    return this.cmp(y) > 0;\n};\n/*\n * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise\n * return false.\n */\nP.gte = function (y) {\n    return this.cmp(y) > -1;\n};\n/*\n * Return true if the value of this Big is less than the value of Big y, otherwise return false.\n */\nP.lt = function (y) {\n    return this.cmp(y) < 0;\n};\n/*\n * Return true if the value of this Big is less than or equal to the value of Big y, otherwise\n * return false.\n */\nP.lte = function (y) {\n    return this.cmp(y) < 1;\n};\n/*\n * Return a new Big whose value is the value of this Big minus the value of Big y.\n */\nP.minus = P.sub = function (y) {\n    var i, j, t, xlty, Big = this.constructor, x = new Big(this), y = new Big(y), a = x.s, b = y.s;\n    // Signs differ?\n    if (a != b) {\n        y.s = -b;\n        return x.plus(y);\n    }\n    var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;\n    // Either zero?\n    if (!xc[0] || !yc[0]) {\n        if (yc[0]) {\n            y.s = -b;\n        }\n        else if (xc[0]) {\n            y = new Big(x);\n        }\n        else {\n            y.s = 1;\n        }\n        return y;\n    }\n    // Determine which is the bigger number. Prepend zeros to equalise exponents.\n    if (a = xe - ye) {\n        if (xlty = a < 0) {\n            a = -a;\n            t = xc;\n        }\n        else {\n            ye = xe;\n            t = yc;\n        }\n        t.reverse();\n        for (b = a; b--;)\n            t.push(0);\n        t.reverse();\n    }\n    else {\n        // Exponents equal. Check digit by digit.\n        j = ((xlty = xc.length < yc.length) ? xc : yc).length;\n        for (a = b = 0; b < j; b++) {\n            if (xc[b] != yc[b]) {\n                xlty = xc[b] < yc[b];\n                break;\n            }\n        }\n    }\n    // x < y? Point xc to the array of the bigger number.\n    if (xlty) {\n        t = xc;\n        xc = yc;\n        yc = t;\n        y.s = -y.s;\n    }\n    /*\n     * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only\n     * needs to start at yc.length.\n     */\n    if ((b = (j = yc.length) - (i = xc.length)) > 0)\n        for (; b--;)\n            xc[i++] = 0;\n    // Subtract yc from xc.\n    for (b = i; j > a;) {\n        if (xc[--j] < yc[j]) {\n            for (i = j; i && !xc[--i];)\n                xc[i] = 9;\n            --xc[i];\n            xc[j] += 10;\n        }\n        xc[j] -= yc[j];\n    }\n    // Remove trailing zeros.\n    for (; xc[--b] === 0;)\n        xc.pop();\n    // Remove leading zeros and adjust exponent accordingly.\n    for (; xc[0] === 0;) {\n        xc.shift();\n        --ye;\n    }\n    if (!xc[0]) {\n        // n - n = +0\n        y.s = 1;\n        // Result must be zero.\n        xc = [ye = 0];\n    }\n    y.c = xc;\n    y.e = ye;\n    return y;\n};\n/*\n * Return a new Big whose value is the value of this Big modulo the value of Big y.\n */\nP.mod = function (y) {\n    var ygtx, Big = this.constructor, x = new Big(this), y = new Big(y), a = x.s, b = y.s;\n    if (!y.c[0]) {\n        throw Error(DIV_BY_ZERO);\n    }\n    x.s = y.s = 1;\n    ygtx = y.cmp(x) == 1;\n    x.s = a;\n    y.s = b;\n    if (ygtx)\n        return new Big(x);\n    a = Big.DP;\n    b = Big.RM;\n    Big.DP = Big.RM = 0;\n    x = x.div(y);\n    Big.DP = a;\n    Big.RM = b;\n    return this.minus(x.times(y));\n};\n/*\n * Return a new Big whose value is the value of this Big plus the value of Big y.\n */\nP.plus = P.add = function (y) {\n    var e, k, t, Big = this.constructor, x = new Big(this), y = new Big(y);\n    // Signs differ?\n    if (x.s != y.s) {\n        y.s = -y.s;\n        return x.minus(y);\n    }\n    var xe = x.e, xc = x.c, ye = y.e, yc = y.c;\n    // Either zero?\n    if (!xc[0] || !yc[0]) {\n        if (!yc[0]) {\n            if (xc[0]) {\n                y = new Big(x);\n            }\n            else {\n                y.s = x.s;\n            }\n        }\n        return y;\n    }\n    xc = xc.slice();\n    // Prepend zeros to equalise exponents.\n    // Note: reverse faster than unshifts.\n    if (e = xe - ye) {\n        if (e > 0) {\n            ye = xe;\n            t = yc;\n        }\n        else {\n            e = -e;\n            t = xc;\n        }\n        t.reverse();\n        for (; e--;)\n            t.push(0);\n        t.reverse();\n    }\n    // Point xc to the longer array.\n    if (xc.length - yc.length < 0) {\n        t = yc;\n        yc = xc;\n        xc = t;\n    }\n    e = yc.length;\n    // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\n    for (k = 0; e; xc[e] %= 10)\n        k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n    if (k) {\n        xc.unshift(k);\n        ++ye;\n    }\n    // Remove trailing zeros.\n    for (e = xc.length; xc[--e] === 0;)\n        xc.pop();\n    y.c = xc;\n    y.e = ye;\n    return y;\n};\n/*\n * Return a Big whose value is the value of this Big raised to the power n.\n * If n is negative, round to a maximum of Big.DP decimal places using rounding\n * mode Big.RM.\n *\n * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\n */\nP.pow = function (n) {\n    var Big = this.constructor, x = new Big(this), y = new Big('1'), one = new Big('1'), isneg = n < 0;\n    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {\n        throw Error(INVALID + 'exponent');\n    }\n    if (isneg)\n        n = -n;\n    for (;;) {\n        if (n & 1)\n            y = y.times(x);\n        n >>= 1;\n        if (!n)\n            break;\n        x = x.times(x);\n    }\n    return isneg ? one.div(y) : y;\n};\n/*\n * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd\n * significant digits using rounding mode rm, or Big.RM if rm is not specified.\n *\n * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n */\nP.prec = function (sd, rm) {\n    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\n        throw Error(INVALID + 'precision');\n    }\n    return round(new this.constructor(this), sd, rm);\n};\n/*\n * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places\n * using rounding mode rm, or Big.RM if rm is not specified.\n * If dp is negative, round to an integer which is a multiple of 10**-dp.\n * If dp is not specified, round to 0 decimal places.\n *\n * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n */\nP.round = function (dp, rm) {\n    if (dp === UNDEFINED)\n        dp = 0;\n    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {\n        throw Error(INVALID_DP);\n    }\n    return round(new this.constructor(this), dp + this.e + 1, rm);\n};\n/*\n * Return a new Big whose value is the square root of the value of this Big, rounded, if\n * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\n */\nP.sqrt = function () {\n    var r, c, t, Big = this.constructor, x = new Big(this), s = x.s, e = x.e, half = new Big('0.5');\n    // Zero?\n    if (!x.c[0])\n        return new Big(x);\n    // Negative?\n    if (s < 0) {\n        throw Error(NAME + 'No square root');\n    }\n    // Estimate.\n    s = Math.sqrt(x + '');\n    // Math.sqrt underflow/overflow?\n    // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.\n    if (s === 0 || s === 1 / 0) {\n        c = x.c.join('');\n        if (!(c.length + e & 1))\n            c += '0';\n        s = Math.sqrt(c);\n        e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\n        r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);\n    }\n    else {\n        r = new Big(s + '');\n    }\n    e = r.e + (Big.DP += 4);\n    // Newton-Raphson iteration.\n    do {\n        t = r;\n        r = half.times(t.plus(x.div(t)));\n    } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));\n    return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);\n};\n/*\n * Return a new Big whose value is the value of this Big times the value of Big y.\n */\nP.times = P.mul = function (y) {\n    var c, Big = this.constructor, x = new Big(this), y = new Big(y), xc = x.c, yc = y.c, a = xc.length, b = yc.length, i = x.e, j = y.e;\n    // Determine sign of result.\n    y.s = x.s == y.s ? 1 : -1;\n    // Return signed 0 if either 0.\n    if (!xc[0] || !yc[0]) {\n        y.c = [y.e = 0];\n        return y;\n    }\n    // Initialise exponent of result as x.e + y.e.\n    y.e = i + j;\n    // If array xc has fewer digits than yc, swap xc and yc, and lengths.\n    if (a < b) {\n        c = xc;\n        xc = yc;\n        yc = c;\n        j = a;\n        a = b;\n        b = j;\n    }\n    // Initialise coefficient array of result with zeros.\n    for (c = new Array(j = a + b); j--;)\n        c[j] = 0;\n    // Multiply.\n    // i is initially xc.length.\n    for (i = b; i--;) {\n        b = 0;\n        // a is yc.length.\n        for (j = a + i; j > i;) {\n            // Current sum of products at this digit position, plus carry.\n            b = c[j] + yc[i] * xc[j - i - 1] + b;\n            c[j--] = b % 10;\n            // carry\n            b = b / 10 | 0;\n        }\n        c[j] = b;\n    }\n    // Increment result exponent if there is a final carry, otherwise remove leading zero.\n    if (b)\n        ++y.e;\n    else\n        c.shift();\n    // Remove trailing zeros.\n    for (i = c.length; !c[--i];)\n        c.pop();\n    y.c = c;\n    return y;\n};\n/*\n * Return a string representing the value of this Big in exponential notation rounded to dp fixed\n * decimal places using rounding mode rm, or Big.RM if rm is not specified.\n *\n * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n */\nP.toExponential = function (dp, rm) {\n    var x = this, n = x.c[0];\n    if (dp !== UNDEFINED) {\n        if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n            throw Error(INVALID_DP);\n        }\n        x = round(new x.constructor(x), ++dp, rm);\n        for (; x.c.length < dp;)\n            x.c.push(0);\n    }\n    return stringify(x, true, !!n);\n};\n/*\n * Return a string representing the value of this Big in normal notation rounded to dp fixed\n * decimal places using rounding mode rm, or Big.RM if rm is not specified.\n *\n * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n *\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\n */\nP.toFixed = function (dp, rm) {\n    var x = this, n = x.c[0];\n    if (dp !== UNDEFINED) {\n        if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n            throw Error(INVALID_DP);\n        }\n        x = round(new x.constructor(x), dp + x.e + 1, rm);\n        // x.e may have changed if the value is rounded up.\n        for (dp = dp + x.e + 1; x.c.length < dp;)\n            x.c.push(0);\n    }\n    return stringify(x, false, !!n);\n};\n/*\n * Return a string representing the value of this Big.\n * Return exponential notation if this Big has a positive exponent equal to or greater than\n * Big.PE, or a negative exponent equal to or less than Big.NE.\n * Omit the sign for negative zero.\n */\nP.toJSON = P.toString = function () {\n    var x = this, Big = x.constructor;\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);\n};\n/*\n * Return the value of this Big as a primitve number.\n */\nP.toNumber = function () {\n    var n = Number(stringify(this, true, true));\n    if (this.constructor.strict === true && !this.eq(n.toString())) {\n        throw Error(NAME + 'Imprecise conversion');\n    }\n    return n;\n};\n/*\n * Return a string representing the value of this Big rounded to sd significant digits using\n * rounding mode rm, or Big.RM if rm is not specified.\n * Use exponential notation if sd is less than the number of digits necessary to represent\n * the integer part of the value in normal notation.\n *\n * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n */\nP.toPrecision = function (sd, rm) {\n    var x = this, Big = x.constructor, n = x.c[0];\n    if (sd !== UNDEFINED) {\n        if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\n            throw Error(INVALID + 'precision');\n        }\n        x = round(new Big(x), sd, rm);\n        for (; x.c.length < sd;)\n            x.c.push(0);\n    }\n    return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);\n};\n/*\n * Return a string representing the value of this Big.\n * Return exponential notation if this Big has a positive exponent equal to or greater than\n * Big.PE, or a negative exponent equal to or less than Big.NE.\n * Include the sign for negative zero.\n */\nP.valueOf = function () {\n    var x = this, Big = x.constructor;\n    if (Big.strict === true) {\n        throw Error(NAME + 'valueOf disallowed');\n    }\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);\n};\n// Export\nexport var Big = _Big_();\n/// <reference types=\"https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/master/types/big.js/index.d.ts\" />\nexport default Big;\n","import Decimal from \"./lib/big.js\";\nimport { FSharpRef } from \"./Types.js\";\nexport default Decimal;\nexport const get_Zero = new Decimal(0);\nexport const get_One = new Decimal(1);\nexport const get_MinusOne = new Decimal(-1);\nexport const get_MaxValue = new Decimal(\"79228162514264337593543950335\");\nexport const get_MinValue = new Decimal(\"-79228162514264337593543950335\");\nexport function compare(x, y) {\n    return x.cmp(y);\n}\nexport function equals(x, y) {\n    return !x.cmp(y);\n}\nexport function abs(x) {\n    return x.abs();\n}\nexport function round(x, digits = 0) {\n    return x.round(digits, 2 /* ROUND_HALF_EVEN */);\n}\nexport function truncate(x) {\n    return x.round(0, 0 /* ROUND_DOWN */);\n}\nexport function ceiling(x) {\n    return x.round(0, x.cmp(0) >= 0 ? 3 /* ROUND_UP */ : 0 /* ROUND_DOWN */);\n}\nexport function floor(x) {\n    return x.round(0, x.cmp(0) >= 0 ? 0 /* ROUND_DOWN */ : 3 /* ROUND_UP */);\n}\nexport function pow(x, n) {\n    return x.pow(n);\n}\nexport function sqrt(x) {\n    return x.sqrt();\n}\nexport function op_Addition(x, y) {\n    return x.add(y);\n}\nexport function op_Subtraction(x, y) {\n    return x.sub(y);\n}\nexport function op_Multiply(x, y) {\n    return x.mul(y);\n}\nexport function op_Division(x, y) {\n    return x.div(y);\n}\nexport function op_Modulus(x, y) {\n    return x.mod(y);\n}\nexport function op_UnaryNegation(x) {\n    const x2 = new Decimal(x);\n    x2.s = -x2.s || 0;\n    return x2;\n}\nexport const add = op_Addition;\nexport const subtract = op_Subtraction;\nexport const multiply = op_Multiply;\nexport const divide = op_Division;\nexport const remainder = op_Modulus;\nexport const negate = op_UnaryNegation;\nexport function toString(x) {\n    return x.toString();\n}\nexport function tryParse(str, defValue) {\n    try {\n        defValue.contents = new Decimal(str.trim());\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexport function parse(str) {\n    const defValue = new FSharpRef(get_Zero);\n    if (tryParse(str, defValue)) {\n        return defValue.contents;\n    }\n    else {\n        throw new Error(\"Input string was not in a correct format.\");\n    }\n}\nexport function toNumber(x) {\n    return +x;\n}\nfunction decimalToHex(dec, bitSize) {\n    const hex = new Uint8Array(bitSize / 4 | 0);\n    let hexCount = 1;\n    for (let d = 0; d < dec.length; d++) {\n        let value = dec[d];\n        for (let i = 0; i < hexCount; i++) {\n            const digit = hex[i] * 10 + value | 0;\n            hex[i] = digit & 0xF;\n            value = digit >> 4;\n        }\n        if (value !== 0) {\n            hex[hexCount++] = value;\n        }\n    }\n    return hex.slice(0, hexCount); // digits in reverse order\n}\nfunction hexToDecimal(hex, bitSize) {\n    const dec = new Uint8Array(bitSize * 301 / 1000 + 1 | 0);\n    let decCount = 1;\n    for (let d = hex.length - 1; d >= 0; d--) {\n        let carry = hex[d];\n        for (let i = 0; i < decCount; i++) {\n            const val = dec[i] * 16 + carry | 0;\n            dec[i] = (val % 10) | 0;\n            carry = (val / 10) | 0;\n        }\n        while (carry > 0) {\n            dec[decCount++] = (carry % 10) | 0;\n            carry = (carry / 10) | 0;\n        }\n    }\n    return dec.slice(0, decCount); // digits in reverse order\n}\nfunction setInt32Bits(hexDigits, bits, offset) {\n    for (let i = 0; i < 8; i++) {\n        hexDigits[offset + i] = (bits >> (i * 4)) & 0xF;\n    }\n}\nfunction getInt32Bits(hexDigits, offset) {\n    let bits = 0;\n    for (let i = 0; i < 8; i++) {\n        bits = bits | (hexDigits[offset + i] << (i * 4));\n    }\n    return bits;\n}\nexport function fromIntArray(bits) {\n    return fromInts(bits[0], bits[1], bits[2], bits[3]);\n}\nexport function fromInts(low, mid, high, signExp) {\n    const isNegative = signExp < 0;\n    const scale = (signExp >> 16) & 0x7F;\n    return fromParts(low, mid, high, isNegative, scale);\n}\nexport function fromParts(low, mid, high, isNegative, scale) {\n    const bitSize = 96;\n    const hexDigits = new Uint8Array(bitSize / 4);\n    setInt32Bits(hexDigits, low, 0);\n    setInt32Bits(hexDigits, mid, 8);\n    setInt32Bits(hexDigits, high, 16);\n    const decDigits = hexToDecimal(hexDigits, bitSize);\n    scale = scale & 0x7F;\n    const big = new Decimal(0);\n    big.c = Array.from(decDigits.reverse());\n    big.e = decDigits.length - scale - 1;\n    big.s = isNegative ? -1 : 1;\n    const d = new Decimal(big);\n    return d;\n}\nexport function getBits(d) {\n    const bitSize = 96;\n    const decDigits = Uint8Array.from(d.c);\n    const hexDigits = decimalToHex(decDigits, bitSize);\n    const low = getInt32Bits(hexDigits, 0);\n    const mid = getInt32Bits(hexDigits, 8);\n    const high = getInt32Bits(hexDigits, 16);\n    const decStr = d.toString();\n    const dotPos = decStr.indexOf(\".\");\n    const scale = dotPos < 0 ? 0 : decStr.length - dotPos - 1;\n    const signExp = ((scale & 0x7F) << 16) | (d.s < 0 ? 0x80000000 : 0);\n    return [low, mid, high, signExp];\n}\n// export function makeRangeStepFunction(step: Decimal, last: Decimal) {\n//   const stepComparedWithZero = step.cmp(get_Zero);\n//   if (stepComparedWithZero === 0) {\n//     throw new Error(\"The step of a range cannot be zero\");\n//   }\n//   const stepGreaterThanZero = stepComparedWithZero > 0;\n//   return (x: Decimal) => {\n//     const comparedWithLast = x.cmp(last);\n//     if ((stepGreaterThanZero && comparedWithLast <= 0)\n//       || (!stepGreaterThanZero && comparedWithLast >= 0)) {\n//       return [x, op_Addition(x, step)];\n//     } else {\n//       return undefined;\n//     }\n//   };\n// }\n","import { BigNatModule_factorial, BigNatModule_ofString, BigNatModule_toFloat, BigNatModule_toUInt64, BigNatModule_toUInt32, BigNatModule_pow, BigNatModule_two, BigNatModule_rem, BigNatModule_lte, BigNatModule_hcf, BigNatModule_bitXor, BigNatModule_bitOr, BigNatModule_bitAnd, BigNatModule_divmod, BigNatModule_mul, BigNatModule_isOne, BigNatModule_sub, BigNatModule_gte, BigNatModule_scale, BigNatModule_one, BigNatModule_add, BigNatModule_ofInt64, BigNatModule_hash, BigNatModule_gt, BigNatModule_lt, BigNatModule_equal, BigNatModule_getSmall, BigNatModule_isSmall, BigNatModule_ofInt32, BigNatModule_toString, BigNatModule_isZero } from \"./n.js\";\r\nimport { Record, toString } from \"../Types.js\";\r\nimport { class_type } from \"../Reflection.js\";\r\nimport { initialize } from \"../Array.js\";\r\nimport { op_Addition, op_Multiply, fromValue, equals, fromBits, compare, fromInteger, op_UnaryNegation } from \"../Long.js\";\r\nimport { op_UnaryNegation_Int32 } from \"../Int32.js\";\r\nimport Decimal from \"../Decimal.js\";\r\n\r\nexport class BigInteger extends Record {\r\n    constructor(signInt, v) {\r\n        super();\r\n        this.signInt = (signInt | 0);\r\n        this.v = v;\r\n    }\r\n    toString() {\r\n        const x = this;\r\n        const matchValue = BigInteger__get_SignInt(x) | 0;\r\n        switch (matchValue) {\r\n            case -1: {\r\n                return BigNatModule_isZero(BigInteger__get_V(x)) ? \"0\" : (\"-\" + BigNatModule_toString(BigInteger__get_V(x)));\r\n            }\r\n            case 0: {\r\n                return \"0\";\r\n            }\r\n            case 1: {\r\n                return BigNatModule_toString(BigInteger__get_V(x));\r\n            }\r\n            default: {\r\n                throw (new Error(\"signs should be +/- 1 or 0\"));\r\n            }\r\n        }\r\n    }\r\n    Equals(obj) {\r\n        const this$ = this;\r\n        return (obj instanceof BigInteger) ? BigInteger_op_Equality_56F059C0(this$, obj) : false;\r\n    }\r\n    GetHashCode() {\r\n        const x = this;\r\n        return BigInteger_hash_Z665282C2(x) | 0;\r\n    }\r\n    toJSON(_key) {\r\n        const this$ = this;\r\n        return toString(this$);\r\n    }\r\n    CompareTo(obj) {\r\n        const this$ = this;\r\n        if (obj instanceof BigInteger) {\r\n            return BigInteger_compare_56F059C0(this$, obj) | 0;\r\n        }\r\n        else {\r\n            throw (new Error(\"the objects are not comparable\\\\nParameter name: obj\"));\r\n        }\r\n    }\r\n}\r\n\r\nexport function BigInteger$reflection() {\r\n    return class_type(\"BigInt.BigInteger\", void 0, BigInteger, class_type(\"System.ValueType\"));\r\n}\r\n\r\nexport function BigInteger_$ctor_Z2BE94A1(signInt, v) {\r\n    return new BigInteger(signInt, v);\r\n}\r\n\r\n(() => {\r\n    BigInteger.smallLim = 4096;\r\n    BigInteger.smallPosTab = initialize(BigInteger.smallLim, (n) => BigNatModule_ofInt32(n));\r\n    BigInteger.one = BigInteger_$ctor_Z524259A4(1);\r\n    BigInteger.two = BigInteger_$ctor_Z524259A4(2);\r\n    BigInteger.zero = BigInteger_$ctor_Z524259A4(0);\r\n})();\r\n\r\nexport function BigInteger_nat_Z67CCE57D(n) {\r\n    if (BigNatModule_isSmall(n) ? (BigNatModule_getSmall(n) < BigInteger.smallLim) : false) {\r\n        return BigInteger.smallPosTab[BigNatModule_getSmall(n)];\r\n    }\r\n    else {\r\n        return n;\r\n    }\r\n}\r\n\r\nexport function BigInteger_create_Z2BE94A1(s, n) {\r\n    return BigInteger_$ctor_Z2BE94A1(s, BigInteger_nat_Z67CCE57D(n));\r\n}\r\n\r\nexport function BigInteger_posn_Z67CCE57D(n) {\r\n    return BigInteger_$ctor_Z2BE94A1(1, BigInteger_nat_Z67CCE57D(n));\r\n}\r\n\r\nexport function BigInteger_negn_Z67CCE57D(n) {\r\n    return BigInteger_$ctor_Z2BE94A1(-1, BigInteger_nat_Z67CCE57D(n));\r\n}\r\n\r\nexport function BigInteger__get_Sign(x) {\r\n    if (BigInteger__get_IsZero(x)) {\r\n        return 0;\r\n    }\r\n    else {\r\n        return x.signInt | 0;\r\n    }\r\n}\r\n\r\nexport function BigInteger__get_SignInt(x) {\r\n    return x.signInt;\r\n}\r\n\r\nexport function BigInteger__get_V(x) {\r\n    return x.v;\r\n}\r\n\r\nexport function BigInteger_op_Equality_56F059C0(x, y) {\r\n    const matchValue = [BigInteger__get_SignInt(x), BigInteger__get_SignInt(y)];\r\n    let pattern_matching_result;\r\n    if (matchValue[0] === -1) {\r\n        if (matchValue[1] === -1) {\r\n            pattern_matching_result = 1;\r\n        }\r\n        else if (matchValue[1] === 0) {\r\n            pattern_matching_result = 8;\r\n        }\r\n        else if (matchValue[1] === 1) {\r\n            pattern_matching_result = 3;\r\n        }\r\n        else {\r\n            pattern_matching_result = 9;\r\n        }\r\n    }\r\n    else if (matchValue[0] === 0) {\r\n        if (matchValue[1] === -1) {\r\n            pattern_matching_result = 6;\r\n        }\r\n        else if (matchValue[1] === 0) {\r\n            pattern_matching_result = 4;\r\n        }\r\n        else if (matchValue[1] === 1) {\r\n            pattern_matching_result = 5;\r\n        }\r\n        else {\r\n            pattern_matching_result = 9;\r\n        }\r\n    }\r\n    else if (matchValue[0] === 1) {\r\n        if (matchValue[1] === -1) {\r\n            pattern_matching_result = 2;\r\n        }\r\n        else if (matchValue[1] === 0) {\r\n            pattern_matching_result = 7;\r\n        }\r\n        else if (matchValue[1] === 1) {\r\n            pattern_matching_result = 0;\r\n        }\r\n        else {\r\n            pattern_matching_result = 9;\r\n        }\r\n    }\r\n    else {\r\n        pattern_matching_result = 9;\r\n    }\r\n    switch (pattern_matching_result) {\r\n        case 0: {\r\n            return BigNatModule_equal(BigInteger__get_V(x), BigInteger__get_V(y));\r\n        }\r\n        case 1: {\r\n            return BigNatModule_equal(BigInteger__get_V(x), BigInteger__get_V(y));\r\n        }\r\n        case 2: {\r\n            if (BigNatModule_isZero(BigInteger__get_V(x))) {\r\n                return BigNatModule_isZero(BigInteger__get_V(y));\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        case 3: {\r\n            if (BigNatModule_isZero(BigInteger__get_V(x))) {\r\n                return BigNatModule_isZero(BigInteger__get_V(y));\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        case 4: {\r\n            return true;\r\n        }\r\n        case 5: {\r\n            return BigNatModule_isZero(BigInteger__get_V(y));\r\n        }\r\n        case 6: {\r\n            return BigNatModule_isZero(BigInteger__get_V(y));\r\n        }\r\n        case 7: {\r\n            return BigNatModule_isZero(BigInteger__get_V(x));\r\n        }\r\n        case 8: {\r\n            return BigNatModule_isZero(BigInteger__get_V(x));\r\n        }\r\n        case 9: {\r\n            throw (new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\"));\r\n        }\r\n    }\r\n}\r\n\r\nexport function BigInteger_op_Inequality_56F059C0(x, y) {\r\n    return !BigInteger_op_Equality_56F059C0(x, y);\r\n}\r\n\r\nexport function BigInteger_op_LessThan_56F059C0(x, y) {\r\n    const matchValue = [BigInteger__get_SignInt(x), BigInteger__get_SignInt(y)];\r\n    let pattern_matching_result;\r\n    if (matchValue[0] === -1) {\r\n        if (matchValue[1] === -1) {\r\n            pattern_matching_result = 1;\r\n        }\r\n        else if (matchValue[1] === 0) {\r\n            pattern_matching_result = 8;\r\n        }\r\n        else if (matchValue[1] === 1) {\r\n            pattern_matching_result = 3;\r\n        }\r\n        else {\r\n            pattern_matching_result = 9;\r\n        }\r\n    }\r\n    else if (matchValue[0] === 0) {\r\n        if (matchValue[1] === -1) {\r\n            pattern_matching_result = 6;\r\n        }\r\n        else if (matchValue[1] === 0) {\r\n            pattern_matching_result = 4;\r\n        }\r\n        else if (matchValue[1] === 1) {\r\n            pattern_matching_result = 5;\r\n        }\r\n        else {\r\n            pattern_matching_result = 9;\r\n        }\r\n    }\r\n    else if (matchValue[0] === 1) {\r\n        if (matchValue[1] === -1) {\r\n            pattern_matching_result = 2;\r\n        }\r\n        else if (matchValue[1] === 0) {\r\n            pattern_matching_result = 7;\r\n        }\r\n        else if (matchValue[1] === 1) {\r\n            pattern_matching_result = 0;\r\n        }\r\n        else {\r\n            pattern_matching_result = 9;\r\n        }\r\n    }\r\n    else {\r\n        pattern_matching_result = 9;\r\n    }\r\n    switch (pattern_matching_result) {\r\n        case 0: {\r\n            return BigNatModule_lt(BigInteger__get_V(x), BigInteger__get_V(y));\r\n        }\r\n        case 1: {\r\n            return BigNatModule_lt(BigInteger__get_V(y), BigInteger__get_V(x));\r\n        }\r\n        case 2: {\r\n            return false;\r\n        }\r\n        case 3: {\r\n            if (!BigNatModule_isZero(BigInteger__get_V(x))) {\r\n                return true;\r\n            }\r\n            else {\r\n                return !BigNatModule_isZero(BigInteger__get_V(y));\r\n            }\r\n        }\r\n        case 4: {\r\n            return false;\r\n        }\r\n        case 5: {\r\n            return !BigNatModule_isZero(BigInteger__get_V(y));\r\n        }\r\n        case 6: {\r\n            return false;\r\n        }\r\n        case 7: {\r\n            return false;\r\n        }\r\n        case 8: {\r\n            return !BigNatModule_isZero(BigInteger__get_V(x));\r\n        }\r\n        case 9: {\r\n            throw (new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\"));\r\n        }\r\n    }\r\n}\r\n\r\nexport function BigInteger_op_GreaterThan_56F059C0(x, y) {\r\n    const matchValue = [BigInteger__get_SignInt(x), BigInteger__get_SignInt(y)];\r\n    let pattern_matching_result;\r\n    if (matchValue[0] === -1) {\r\n        if (matchValue[1] === -1) {\r\n            pattern_matching_result = 1;\r\n        }\r\n        else if (matchValue[1] === 0) {\r\n            pattern_matching_result = 8;\r\n        }\r\n        else if (matchValue[1] === 1) {\r\n            pattern_matching_result = 3;\r\n        }\r\n        else {\r\n            pattern_matching_result = 9;\r\n        }\r\n    }\r\n    else if (matchValue[0] === 0) {\r\n        if (matchValue[1] === -1) {\r\n            pattern_matching_result = 6;\r\n        }\r\n        else if (matchValue[1] === 0) {\r\n            pattern_matching_result = 4;\r\n        }\r\n        else if (matchValue[1] === 1) {\r\n            pattern_matching_result = 5;\r\n        }\r\n        else {\r\n            pattern_matching_result = 9;\r\n        }\r\n    }\r\n    else if (matchValue[0] === 1) {\r\n        if (matchValue[1] === -1) {\r\n            pattern_matching_result = 2;\r\n        }\r\n        else if (matchValue[1] === 0) {\r\n            pattern_matching_result = 7;\r\n        }\r\n        else if (matchValue[1] === 1) {\r\n            pattern_matching_result = 0;\r\n        }\r\n        else {\r\n            pattern_matching_result = 9;\r\n        }\r\n    }\r\n    else {\r\n        pattern_matching_result = 9;\r\n    }\r\n    switch (pattern_matching_result) {\r\n        case 0: {\r\n            return BigNatModule_gt(BigInteger__get_V(x), BigInteger__get_V(y));\r\n        }\r\n        case 1: {\r\n            return BigNatModule_gt(BigInteger__get_V(y), BigInteger__get_V(x));\r\n        }\r\n        case 2: {\r\n            if (!BigNatModule_isZero(BigInteger__get_V(x))) {\r\n                return true;\r\n            }\r\n            else {\r\n                return !BigNatModule_isZero(BigInteger__get_V(y));\r\n            }\r\n        }\r\n        case 3: {\r\n            return false;\r\n        }\r\n        case 4: {\r\n            return false;\r\n        }\r\n        case 5: {\r\n            return false;\r\n        }\r\n        case 6: {\r\n            return !BigNatModule_isZero(BigInteger__get_V(y));\r\n        }\r\n        case 7: {\r\n            return !BigNatModule_isZero(BigInteger__get_V(x));\r\n        }\r\n        case 8: {\r\n            return false;\r\n        }\r\n        case 9: {\r\n            throw (new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\"));\r\n        }\r\n    }\r\n}\r\n\r\nexport function BigInteger_compare_56F059C0(n, nn) {\r\n    if (BigInteger_op_LessThan_56F059C0(n, nn)) {\r\n        return -1;\r\n    }\r\n    else if (BigInteger_op_Equality_56F059C0(n, nn)) {\r\n        return 0;\r\n    }\r\n    else {\r\n        return 1;\r\n    }\r\n}\r\n\r\nexport function BigInteger_hash_Z665282C2(z) {\r\n    if (BigInteger__get_SignInt(z) === 0) {\r\n        return 1;\r\n    }\r\n    else {\r\n        return (BigInteger__get_SignInt(z) + BigNatModule_hash(BigInteger__get_V(z))) | 0;\r\n    }\r\n}\r\n\r\nexport function BigInteger__get_StructuredDisplayString(x) {\r\n    return toString(x);\r\n}\r\n\r\nexport function BigInteger_$ctor_Z524259A4(n) {\r\n    if (n >= 0) {\r\n        return BigInteger_$ctor_Z2BE94A1(1, BigInteger_nat_Z67CCE57D(BigNatModule_ofInt32(n)));\r\n    }\r\n    else if (n === -2147483648) {\r\n        return BigInteger_$ctor_Z2BE94A1(-1, BigInteger_nat_Z67CCE57D(BigNatModule_ofInt64(op_UnaryNegation(fromInteger(n, false, 2)))));\r\n    }\r\n    else {\r\n        return BigInteger_$ctor_Z2BE94A1(-1, BigInteger_nat_Z67CCE57D(BigNatModule_ofInt32(op_UnaryNegation_Int32(n))));\r\n    }\r\n}\r\n\r\nexport function BigInteger_$ctor_Z524259C1(n) {\r\n    if (compare(n, fromBits(0, 0, false)) >= 0) {\r\n        return BigInteger_$ctor_Z2BE94A1(1, BigInteger_nat_Z67CCE57D(BigNatModule_ofInt64(n)));\r\n    }\r\n    else if (equals(n, fromBits(0, 2147483648, false))) {\r\n        return BigInteger_$ctor_Z2BE94A1(-1, BigInteger_nat_Z67CCE57D(BigNatModule_add(BigNatModule_ofInt64(fromBits(4294967295, 2147483647, false)), BigNatModule_one)));\r\n    }\r\n    else {\r\n        return BigInteger_$ctor_Z2BE94A1(-1, BigInteger_nat_Z67CCE57D(BigNatModule_ofInt64(op_UnaryNegation(n))));\r\n    }\r\n}\r\n\r\nexport function BigInteger_get_One() {\r\n    return BigInteger.one;\r\n}\r\n\r\nexport function BigInteger_get_Two() {\r\n    return BigInteger.two;\r\n}\r\n\r\nexport function BigInteger_get_Zero() {\r\n    return BigInteger.zero;\r\n}\r\n\r\nexport function BigInteger_op_UnaryNegation_Z665282C2(z) {\r\n    const matchValue = BigInteger__get_SignInt(z) | 0;\r\n    if (matchValue === 0) {\r\n        return BigInteger_get_Zero();\r\n    }\r\n    else {\r\n        return BigInteger_create_Z2BE94A1(op_UnaryNegation_Int32(matchValue), BigInteger__get_V(z));\r\n    }\r\n}\r\n\r\nexport function BigInteger_Scale_Z320F31E(k, z) {\r\n    if (BigInteger__get_SignInt(z) === 0) {\r\n        return BigInteger_get_Zero();\r\n    }\r\n    else if (k < 0) {\r\n        return BigInteger_create_Z2BE94A1(op_UnaryNegation_Int32(BigInteger__get_SignInt(z)), BigNatModule_scale(op_UnaryNegation_Int32(k), BigInteger__get_V(z)));\r\n    }\r\n    else {\r\n        return BigInteger_create_Z2BE94A1(BigInteger__get_SignInt(z), BigNatModule_scale(k, BigInteger__get_V(z)));\r\n    }\r\n}\r\n\r\nexport function BigInteger_subnn_6A57060(nx, ny) {\r\n    if (BigNatModule_gte(nx, ny)) {\r\n        return BigInteger_posn_Z67CCE57D(BigNatModule_sub(nx, ny));\r\n    }\r\n    else {\r\n        return BigInteger_negn_Z67CCE57D(BigNatModule_sub(ny, nx));\r\n    }\r\n}\r\n\r\nexport function BigInteger_addnn_6A57060(nx, ny) {\r\n    return BigInteger_posn_Z67CCE57D(BigNatModule_add(nx, ny));\r\n}\r\n\r\nexport function BigInteger__get_IsZero(x) {\r\n    if (BigInteger__get_SignInt(x) === 0) {\r\n        return true;\r\n    }\r\n    else {\r\n        return BigNatModule_isZero(BigInteger__get_V(x));\r\n    }\r\n}\r\n\r\nexport function BigInteger__get_IsOne(x) {\r\n    if (BigInteger__get_SignInt(x) === 1) {\r\n        return BigNatModule_isOne(BigInteger__get_V(x));\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function BigInteger_op_Addition_56F059C0(x, y) {\r\n    if (BigInteger__get_IsZero(y)) {\r\n        return x;\r\n    }\r\n    else if (BigInteger__get_IsZero(x)) {\r\n        return y;\r\n    }\r\n    else {\r\n        const matchValue = [BigInteger__get_SignInt(x), BigInteger__get_SignInt(y)];\r\n        let pattern_matching_result;\r\n        if (matchValue[0] === -1) {\r\n            if (matchValue[1] === -1) {\r\n                pattern_matching_result = 1;\r\n            }\r\n            else if (matchValue[1] === 1) {\r\n                pattern_matching_result = 3;\r\n            }\r\n            else {\r\n                pattern_matching_result = 4;\r\n            }\r\n        }\r\n        else if (matchValue[0] === 1) {\r\n            if (matchValue[1] === -1) {\r\n                pattern_matching_result = 2;\r\n            }\r\n            else if (matchValue[1] === 1) {\r\n                pattern_matching_result = 0;\r\n            }\r\n            else {\r\n                pattern_matching_result = 4;\r\n            }\r\n        }\r\n        else {\r\n            pattern_matching_result = 4;\r\n        }\r\n        switch (pattern_matching_result) {\r\n            case 0: {\r\n                return BigInteger_addnn_6A57060(BigInteger__get_V(x), BigInteger__get_V(y));\r\n            }\r\n            case 1: {\r\n                return BigInteger_op_UnaryNegation_Z665282C2(BigInteger_addnn_6A57060(BigInteger__get_V(x), BigInteger__get_V(y)));\r\n            }\r\n            case 2: {\r\n                return BigInteger_subnn_6A57060(BigInteger__get_V(x), BigInteger__get_V(y));\r\n            }\r\n            case 3: {\r\n                return BigInteger_subnn_6A57060(BigInteger__get_V(y), BigInteger__get_V(x));\r\n            }\r\n            case 4: {\r\n                throw (new Error(\"signs should be +/- 1\\\\nParameter name: x\"));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport function BigInteger_op_Subtraction_56F059C0(x, y) {\r\n    if (BigInteger__get_IsZero(y)) {\r\n        return x;\r\n    }\r\n    else if (BigInteger__get_IsZero(x)) {\r\n        return BigInteger_op_UnaryNegation_Z665282C2(y);\r\n    }\r\n    else {\r\n        const matchValue = [BigInteger__get_SignInt(x), BigInteger__get_SignInt(y)];\r\n        let pattern_matching_result;\r\n        if (matchValue[0] === -1) {\r\n            if (matchValue[1] === -1) {\r\n                pattern_matching_result = 1;\r\n            }\r\n            else if (matchValue[1] === 1) {\r\n                pattern_matching_result = 3;\r\n            }\r\n            else {\r\n                pattern_matching_result = 4;\r\n            }\r\n        }\r\n        else if (matchValue[0] === 1) {\r\n            if (matchValue[1] === -1) {\r\n                pattern_matching_result = 2;\r\n            }\r\n            else if (matchValue[1] === 1) {\r\n                pattern_matching_result = 0;\r\n            }\r\n            else {\r\n                pattern_matching_result = 4;\r\n            }\r\n        }\r\n        else {\r\n            pattern_matching_result = 4;\r\n        }\r\n        switch (pattern_matching_result) {\r\n            case 0: {\r\n                return BigInteger_subnn_6A57060(BigInteger__get_V(x), BigInteger__get_V(y));\r\n            }\r\n            case 1: {\r\n                return BigInteger_subnn_6A57060(BigInteger__get_V(y), BigInteger__get_V(x));\r\n            }\r\n            case 2: {\r\n                return BigInteger_addnn_6A57060(BigInteger__get_V(x), BigInteger__get_V(y));\r\n            }\r\n            case 3: {\r\n                return BigInteger_op_UnaryNegation_Z665282C2(BigInteger_addnn_6A57060(BigInteger__get_V(x), BigInteger__get_V(y)));\r\n            }\r\n            case 4: {\r\n                throw (new Error(\"signs should be +/- 1\\\\nParameter name: x\"));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport function BigInteger_op_Multiply_56F059C0(x, y) {\r\n    if (BigInteger__get_IsZero(x)) {\r\n        return x;\r\n    }\r\n    else if (BigInteger__get_IsZero(y)) {\r\n        return y;\r\n    }\r\n    else if (BigInteger__get_IsOne(x)) {\r\n        return y;\r\n    }\r\n    else if (BigInteger__get_IsOne(y)) {\r\n        return x;\r\n    }\r\n    else {\r\n        const m = BigNatModule_mul(BigInteger__get_V(x), BigInteger__get_V(y));\r\n        return BigInteger_create_Z2BE94A1(BigInteger__get_SignInt(x) * BigInteger__get_SignInt(y), m);\r\n    }\r\n}\r\n\r\nexport function BigInteger_DivRem_56F059C0(x, y) {\r\n    if (BigInteger__get_IsZero(y)) {\r\n        throw (new Error());\r\n    }\r\n    if (BigInteger__get_IsZero(x)) {\r\n        return [BigInteger_get_Zero(), BigInteger_get_Zero()];\r\n    }\r\n    else {\r\n        const patternInput = BigNatModule_divmod(BigInteger__get_V(x), BigInteger__get_V(y));\r\n        const r = patternInput[1];\r\n        const d = patternInput[0];\r\n        const matchValue = [BigInteger__get_SignInt(x), BigInteger__get_SignInt(y)];\r\n        let pattern_matching_result;\r\n        if (matchValue[0] === -1) {\r\n            if (matchValue[1] === -1) {\r\n                pattern_matching_result = 1;\r\n            }\r\n            else if (matchValue[1] === 1) {\r\n                pattern_matching_result = 3;\r\n            }\r\n            else {\r\n                pattern_matching_result = 4;\r\n            }\r\n        }\r\n        else if (matchValue[0] === 1) {\r\n            if (matchValue[1] === -1) {\r\n                pattern_matching_result = 2;\r\n            }\r\n            else if (matchValue[1] === 1) {\r\n                pattern_matching_result = 0;\r\n            }\r\n            else {\r\n                pattern_matching_result = 4;\r\n            }\r\n        }\r\n        else {\r\n            pattern_matching_result = 4;\r\n        }\r\n        switch (pattern_matching_result) {\r\n            case 0: {\r\n                return [BigInteger_posn_Z67CCE57D(d), BigInteger_posn_Z67CCE57D(r)];\r\n            }\r\n            case 1: {\r\n                return [BigInteger_posn_Z67CCE57D(d), BigInteger_negn_Z67CCE57D(r)];\r\n            }\r\n            case 2: {\r\n                return [BigInteger_negn_Z67CCE57D(d), BigInteger_posn_Z67CCE57D(r)];\r\n            }\r\n            case 3: {\r\n                return [BigInteger_negn_Z67CCE57D(d), BigInteger_negn_Z67CCE57D(r)];\r\n            }\r\n            case 4: {\r\n                throw (new Error(\"signs should be +/- 1\\\\nParameter name: x\"));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport function BigInteger_op_Division_56F059C0(x, y) {\r\n    return BigInteger_DivRem_56F059C0(x, y)[0];\r\n}\r\n\r\nexport function BigInteger_op_Modulus_56F059C0(x, y) {\r\n    return BigInteger_DivRem_56F059C0(x, y)[1];\r\n}\r\n\r\nexport function BigInteger_op_RightShift_62E082A2(x, y) {\r\n    return BigInteger_op_Division_56F059C0(x, BigInteger_Pow_62E082A2(BigInteger_get_Two(), y));\r\n}\r\n\r\nexport function BigInteger_op_LeftShift_62E082A2(x, y) {\r\n    return BigInteger_op_Multiply_56F059C0(x, BigInteger_Pow_62E082A2(BigInteger_get_Two(), y));\r\n}\r\n\r\nexport function BigInteger_op_BitwiseAnd_56F059C0(x, y) {\r\n    return BigInteger_posn_Z67CCE57D(BigNatModule_bitAnd(BigInteger__get_V(x), BigInteger__get_V(y)));\r\n}\r\n\r\nexport function BigInteger_op_BitwiseOr_56F059C0(x, y) {\r\n    return BigInteger_posn_Z67CCE57D(BigNatModule_bitOr(BigInteger__get_V(x), BigInteger__get_V(y)));\r\n}\r\n\r\nexport function BigInteger_op_ExclusiveOr_56F059C0(x, y) {\r\n    return BigInteger_posn_Z67CCE57D(BigNatModule_bitXor(BigInteger__get_V(x), BigInteger__get_V(y)));\r\n}\r\n\r\nexport function BigInteger_GreatestCommonDivisor_56F059C0(x, y) {\r\n    const matchValue = [BigInteger__get_SignInt(x), BigInteger__get_SignInt(y)];\r\n    if (matchValue[0] === 0) {\r\n        if (matchValue[1] === 0) {\r\n            return BigInteger_get_Zero();\r\n        }\r\n        else {\r\n            return BigInteger_posn_Z67CCE57D(BigInteger__get_V(y));\r\n        }\r\n    }\r\n    else if (matchValue[1] === 0) {\r\n        return BigInteger_posn_Z67CCE57D(BigInteger__get_V(x));\r\n    }\r\n    else {\r\n        return BigInteger_posn_Z67CCE57D(BigNatModule_hcf(BigInteger__get_V(x), BigInteger__get_V(y)));\r\n    }\r\n}\r\n\r\nexport function BigInteger__get_IsNegative(x) {\r\n    if (BigInteger__get_SignInt(x) === -1) {\r\n        return !BigInteger__get_IsZero(x);\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function BigInteger__get_IsPositive(x) {\r\n    if (BigInteger__get_SignInt(x) === 1) {\r\n        return !BigInteger__get_IsZero(x);\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function BigInteger_Abs_Z665282C2(x) {\r\n    if (BigInteger__get_SignInt(x) === -1) {\r\n        return BigInteger_op_UnaryNegation_Z665282C2(x);\r\n    }\r\n    else {\r\n        return x;\r\n    }\r\n}\r\n\r\nexport function BigInteger_op_LessThanOrEqual_56F059C0(x, y) {\r\n    const matchValue = [BigInteger__get_SignInt(x), BigInteger__get_SignInt(y)];\r\n    let pattern_matching_result;\r\n    if (matchValue[0] === -1) {\r\n        if (matchValue[1] === -1) {\r\n            pattern_matching_result = 1;\r\n        }\r\n        else if (matchValue[1] === 0) {\r\n            pattern_matching_result = 6;\r\n        }\r\n        else if (matchValue[1] === 1) {\r\n            pattern_matching_result = 3;\r\n        }\r\n        else {\r\n            pattern_matching_result = 9;\r\n        }\r\n    }\r\n    else if (matchValue[0] === 0) {\r\n        if (matchValue[1] === -1) {\r\n            pattern_matching_result = 8;\r\n        }\r\n        else if (matchValue[1] === 0) {\r\n            pattern_matching_result = 4;\r\n        }\r\n        else if (matchValue[1] === 1) {\r\n            pattern_matching_result = 7;\r\n        }\r\n        else {\r\n            pattern_matching_result = 9;\r\n        }\r\n    }\r\n    else if (matchValue[0] === 1) {\r\n        if (matchValue[1] === -1) {\r\n            pattern_matching_result = 2;\r\n        }\r\n        else if (matchValue[1] === 0) {\r\n            pattern_matching_result = 5;\r\n        }\r\n        else if (matchValue[1] === 1) {\r\n            pattern_matching_result = 0;\r\n        }\r\n        else {\r\n            pattern_matching_result = 9;\r\n        }\r\n    }\r\n    else {\r\n        pattern_matching_result = 9;\r\n    }\r\n    switch (pattern_matching_result) {\r\n        case 0: {\r\n            return BigNatModule_lte(BigInteger__get_V(x), BigInteger__get_V(y));\r\n        }\r\n        case 1: {\r\n            return BigNatModule_lte(BigInteger__get_V(y), BigInteger__get_V(x));\r\n        }\r\n        case 2: {\r\n            if (BigNatModule_isZero(BigInteger__get_V(x))) {\r\n                return BigNatModule_isZero(BigInteger__get_V(y));\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        case 3: {\r\n            return true;\r\n        }\r\n        case 4: {\r\n            return true;\r\n        }\r\n        case 5: {\r\n            return BigNatModule_isZero(BigInteger__get_V(x));\r\n        }\r\n        case 6: {\r\n            return true;\r\n        }\r\n        case 7: {\r\n            return true;\r\n        }\r\n        case 8: {\r\n            return BigNatModule_isZero(BigInteger__get_V(y));\r\n        }\r\n        case 9: {\r\n            throw (new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\"));\r\n        }\r\n    }\r\n}\r\n\r\nexport function BigInteger_op_GreaterThanOrEqual_56F059C0(x, y) {\r\n    const matchValue = [BigInteger__get_SignInt(x), BigInteger__get_SignInt(y)];\r\n    let pattern_matching_result;\r\n    if (matchValue[0] === -1) {\r\n        if (matchValue[1] === -1) {\r\n            pattern_matching_result = 1;\r\n        }\r\n        else if (matchValue[1] === 0) {\r\n            pattern_matching_result = 6;\r\n        }\r\n        else if (matchValue[1] === 1) {\r\n            pattern_matching_result = 3;\r\n        }\r\n        else {\r\n            pattern_matching_result = 9;\r\n        }\r\n    }\r\n    else if (matchValue[0] === 0) {\r\n        if (matchValue[1] === -1) {\r\n            pattern_matching_result = 8;\r\n        }\r\n        else if (matchValue[1] === 0) {\r\n            pattern_matching_result = 4;\r\n        }\r\n        else if (matchValue[1] === 1) {\r\n            pattern_matching_result = 7;\r\n        }\r\n        else {\r\n            pattern_matching_result = 9;\r\n        }\r\n    }\r\n    else if (matchValue[0] === 1) {\r\n        if (matchValue[1] === -1) {\r\n            pattern_matching_result = 2;\r\n        }\r\n        else if (matchValue[1] === 0) {\r\n            pattern_matching_result = 5;\r\n        }\r\n        else if (matchValue[1] === 1) {\r\n            pattern_matching_result = 0;\r\n        }\r\n        else {\r\n            pattern_matching_result = 9;\r\n        }\r\n    }\r\n    else {\r\n        pattern_matching_result = 9;\r\n    }\r\n    switch (pattern_matching_result) {\r\n        case 0: {\r\n            return BigNatModule_gte(BigInteger__get_V(x), BigInteger__get_V(y));\r\n        }\r\n        case 1: {\r\n            return BigNatModule_gte(BigInteger__get_V(y), BigInteger__get_V(x));\r\n        }\r\n        case 2: {\r\n            return true;\r\n        }\r\n        case 3: {\r\n            if (BigNatModule_isZero(BigInteger__get_V(x))) {\r\n                return BigNatModule_isZero(BigInteger__get_V(y));\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        case 4: {\r\n            return true;\r\n        }\r\n        case 5: {\r\n            return true;\r\n        }\r\n        case 6: {\r\n            return BigNatModule_isZero(BigInteger__get_V(x));\r\n        }\r\n        case 7: {\r\n            return BigNatModule_isZero(BigInteger__get_V(y));\r\n        }\r\n        case 8: {\r\n            return true;\r\n        }\r\n        case 9: {\r\n            throw (new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\"));\r\n        }\r\n    }\r\n}\r\n\r\nexport function BigInteger_Pow_62E082A2(x, y) {\r\n    if (y < 0) {\r\n        throw (new Error(\"y\"));\r\n    }\r\n    const matchValue = [BigInteger__get_IsZero(x), y];\r\n    if (matchValue[0]) {\r\n        if (matchValue[1] === 0) {\r\n            return BigInteger_get_One();\r\n        }\r\n        else {\r\n            return BigInteger_get_Zero();\r\n        }\r\n    }\r\n    else {\r\n        const yval = BigInteger_$ctor_Z524259A4(y);\r\n        return BigInteger_create_Z2BE94A1(BigNatModule_isZero(BigNatModule_rem(BigInteger__get_V(yval), BigNatModule_two)) ? 1 : BigInteger__get_SignInt(x), BigNatModule_pow(BigInteger__get_V(x), BigInteger__get_V(yval)));\r\n    }\r\n}\r\n\r\nexport function BigInteger__get_ToInt32(x) {\r\n    if (BigInteger__get_IsZero(x)) {\r\n        return 0;\r\n    }\r\n    else {\r\n        const u = BigNatModule_toUInt32(BigInteger__get_V(x));\r\n        if (u <= (2147483647 >>> 0)) {\r\n            return (BigInteger__get_SignInt(x) * (~(~u))) | 0;\r\n        }\r\n        else if ((BigInteger__get_SignInt(x) === -1) ? (u === ((2147483647 + 1) >>> 0)) : false) {\r\n            return -2147483648;\r\n        }\r\n        else {\r\n            throw (new Error());\r\n        }\r\n    }\r\n}\r\n\r\nexport function BigInteger__get_ToUInt32(x) {\r\n    if (BigInteger__get_IsZero(x)) {\r\n        return 0;\r\n    }\r\n    else {\r\n        return BigNatModule_toUInt32(BigInteger__get_V(x));\r\n    }\r\n}\r\n\r\nexport function BigInteger__get_ToInt64(x) {\r\n    if (BigInteger__get_IsZero(x)) {\r\n        return fromBits(0, 0, false);\r\n    }\r\n    else {\r\n        const u = BigNatModule_toUInt64(BigInteger__get_V(x));\r\n        if (compare(u, fromValue(fromBits(4294967295, 2147483647, false), true)) <= 0) {\r\n            return op_Multiply(fromInteger(BigInteger__get_SignInt(x), false, 2), fromValue(u, false));\r\n        }\r\n        else if ((BigInteger__get_SignInt(x) === -1) ? equals(u, fromValue(op_Addition(fromBits(4294967295, 2147483647, false), fromBits(1, 0, false)), true)) : false) {\r\n            return fromBits(0, 2147483648, false);\r\n        }\r\n        else {\r\n            throw (new Error());\r\n        }\r\n    }\r\n}\r\n\r\nexport function BigInteger__get_ToUInt64(x) {\r\n    if (BigInteger__get_IsZero(x)) {\r\n        return fromBits(0, 0, true);\r\n    }\r\n    else {\r\n        return BigNatModule_toUInt64(BigInteger__get_V(x));\r\n    }\r\n}\r\n\r\nexport function BigInteger__get_ToDouble(x) {\r\n    const matchValue = BigInteger__get_SignInt(x) | 0;\r\n    switch (matchValue) {\r\n        case -1: {\r\n            return -BigNatModule_toFloat(BigInteger__get_V(x));\r\n        }\r\n        case 0: {\r\n            return 0;\r\n        }\r\n        case 1: {\r\n            return BigNatModule_toFloat(BigInteger__get_V(x));\r\n        }\r\n        default: {\r\n            throw (new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\"));\r\n        }\r\n    }\r\n}\r\n\r\nexport function BigInteger__get_ToSByte(x) {\r\n    return (BigInteger__get_ToInt32(x) + 0x80 & 0xFF) - 0x80;\r\n}\r\n\r\nexport function BigInteger__get_ToByte(x) {\r\n    return BigInteger__get_ToUInt32(x) & 0xFF;\r\n}\r\n\r\nexport function BigInteger__get_ToInt16(x) {\r\n    return (BigInteger__get_ToInt32(x) + 0x8000 & 0xFFFF) - 0x8000;\r\n}\r\n\r\nexport function BigInteger__get_ToUInt16(x) {\r\n    return BigInteger__get_ToUInt32(x) & 0xFFFF;\r\n}\r\n\r\nexport function BigInteger__get_ToSingle(x) {\r\n    return BigInteger__get_ToDouble(x);\r\n}\r\n\r\nexport function BigInteger__get_ToDecimal(x) {\r\n    return new Decimal(BigInteger__get_ToDouble(x));\r\n}\r\n\r\nexport function BigInteger_Parse_Z721C83C5(text) {\r\n    if (text == null) {\r\n        throw (new Error(\"text\"));\r\n    }\r\n    const text_1 = text.trim();\r\n    const len = text_1.length | 0;\r\n    if (len === 0) {\r\n        throw (new Error());\r\n    }\r\n    const matchValue = [text_1[0], len];\r\n    if (matchValue[0] === \"+\") {\r\n        if (matchValue[1] === 1) {\r\n            throw (new Error());\r\n        }\r\n        else {\r\n            return BigInteger_posn_Z67CCE57D(BigNatModule_ofString(text_1.slice(1, (len - 1) + 1)));\r\n        }\r\n    }\r\n    else if (matchValue[0] === \"-\") {\r\n        if (matchValue[1] === 1) {\r\n            throw (new Error());\r\n        }\r\n        else {\r\n            return BigInteger_negn_Z67CCE57D(BigNatModule_ofString(text_1.slice(1, (len - 1) + 1)));\r\n        }\r\n    }\r\n    else {\r\n        return BigInteger_posn_Z67CCE57D(BigNatModule_ofString(text_1));\r\n    }\r\n}\r\n\r\nexport function BigInteger__get_IsSmall(x) {\r\n    if (BigInteger__get_IsZero(x)) {\r\n        return true;\r\n    }\r\n    else {\r\n        return BigNatModule_isSmall(BigInteger__get_V(x));\r\n    }\r\n}\r\n\r\nexport function BigInteger_Factorial_Z665282C2(x) {\r\n    if (BigInteger__get_IsNegative(x)) {\r\n        throw (new Error(\"mustBeNonNegative\\\\nParameter name: x\"));\r\n    }\r\n    if (BigInteger__get_IsPositive(x)) {\r\n        return BigInteger_posn_Z67CCE57D(BigNatModule_factorial(BigInteger__get_V(x)));\r\n    }\r\n    else {\r\n        return BigInteger_get_One();\r\n    }\r\n}\r\n\r\nexport function BigInteger_op_UnaryPlus_Z665282C2(n1) {\r\n    return n1;\r\n}\r\n\r\nexport function BigInteger_FromInt64_Z524259C1(x) {\r\n    return BigInteger_$ctor_Z524259C1(x);\r\n}\r\n\r\nexport function BigInteger_FromInt32_Z524259A4(x) {\r\n    return BigInteger_$ctor_Z524259A4(x);\r\n}\r\n\r\n","import { BigInteger_op_Inequality_56F059C0, BigInteger_op_Equality_56F059C0, BigInteger_op_GreaterThanOrEqual_56F059C0, BigInteger_op_GreaterThan_56F059C0, BigInteger_op_LessThanOrEqual_56F059C0, BigInteger_op_LessThan_56F059C0, BigInteger_op_ExclusiveOr_56F059C0, BigInteger_op_BitwiseOr_56F059C0, BigInteger_op_BitwiseAnd_56F059C0, BigInteger_op_LeftShift_62E082A2, BigInteger_op_RightShift_62E082A2, BigInteger_op_UnaryPlus_Z665282C2, BigInteger_op_UnaryNegation_Z665282C2, BigInteger_op_Modulus_56F059C0, BigInteger_op_Division_56F059C0, BigInteger_op_Multiply_56F059C0, BigInteger_op_Subtraction_56F059C0, BigInteger_op_Addition_56F059C0, BigInteger__get_IsOne, BigInteger__get_IsZero, BigInteger__get_Sign, BigInteger__get_ToDecimal, BigInteger__get_ToDouble, BigInteger__get_ToSingle, BigInteger__get_ToUInt64, BigInteger__get_ToInt64, BigInteger__get_ToUInt32, BigInteger__get_ToInt32, BigInteger__get_ToUInt16, BigInteger__get_ToInt16, BigInteger__get_ToByte, BigInteger__get_ToSByte, BigInteger_$ctor_Z524259A4, BigInteger_$ctor_Z524259C1, BigInteger_get_Two, BigInteger_get_One, BigInteger_get_Zero, BigInteger_Abs_Z665282C2, BigInteger_Pow_62E082A2, BigInteger_GreatestCommonDivisor_56F059C0, BigInteger_DivRem_56F059C0, BigInteger_Parse_Z721C83C5, BigInteger } from \"./BigInt/z.js\";\r\nimport { fromInteger } from \"./Long.js\";\r\nimport { comparePrimitives, min, compare as compare_1, equals as equals_1, safeHash } from \"./Util.js\";\r\nimport { toString as toString_1 } from \"./Types.js\";\r\nimport { fold, empty, ofArrayWithTail, cons, toArray, head, skipWhile } from \"./List.js\";\r\nimport { fill, reverse } from \"./Array.js\";\r\n\r\nexport function isBigInt(x) {\r\n    return x instanceof BigInteger;\r\n}\r\n\r\nexport function tryParse(str, res) {\r\n    try {\r\n        res.contents = BigInteger_Parse_Z721C83C5(str);\r\n        return true;\r\n    }\r\n    catch (matchValue) {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function divRem(x, y, remainder) {\r\n    const patternInput = BigInteger_DivRem_56F059C0(x, y);\r\n    remainder.contents = patternInput[1];\r\n    return patternInput[0];\r\n}\r\n\r\nexport function parse(arg00) {\r\n    return BigInteger_Parse_Z721C83C5(arg00);\r\n}\r\n\r\nexport function greatestCommonDivisor(arg00, arg01) {\r\n    return BigInteger_GreatestCommonDivisor_56F059C0(arg00, arg01);\r\n}\r\n\r\nexport function pow(arg00, arg01) {\r\n    return BigInteger_Pow_62E082A2(arg00, arg01);\r\n}\r\n\r\nexport function abs(arg00) {\r\n    return BigInteger_Abs_Z665282C2(arg00);\r\n}\r\n\r\nexport const zero = BigInteger_get_Zero();\r\n\r\nexport const one = BigInteger_get_One();\r\n\r\nexport const two = BigInteger_get_Two();\r\n\r\nexport function fromString(s) {\r\n    return BigInteger_Parse_Z721C83C5(s);\r\n}\r\n\r\nexport function fromZero() {\r\n    return BigInteger_get_Zero();\r\n}\r\n\r\nexport function fromOne() {\r\n    return BigInteger_get_One();\r\n}\r\n\r\nexport function fromInt64(i) {\r\n    return BigInteger_$ctor_Z524259C1(i);\r\n}\r\n\r\nexport function fromInt32(i) {\r\n    if (i > 2147483647) {\r\n        return BigInteger_$ctor_Z524259C1(fromInteger(i, false, 6));\r\n    }\r\n    else {\r\n        return BigInteger_$ctor_Z524259A4(i);\r\n    }\r\n}\r\n\r\nexport function toSByte(x) {\r\n    return BigInteger__get_ToSByte(x);\r\n}\r\n\r\nexport function toByte(x) {\r\n    return BigInteger__get_ToByte(x);\r\n}\r\n\r\nexport function toInt16(x) {\r\n    return BigInteger__get_ToInt16(x);\r\n}\r\n\r\nexport function toUInt16(x) {\r\n    return BigInteger__get_ToUInt16(x);\r\n}\r\n\r\nexport function toInt32(x) {\r\n    return BigInteger__get_ToInt32(x);\r\n}\r\n\r\nexport function toUInt32(x) {\r\n    return BigInteger__get_ToUInt32(x);\r\n}\r\n\r\nexport function toInt64(x) {\r\n    return BigInteger__get_ToInt64(x);\r\n}\r\n\r\nexport function toUInt64(x) {\r\n    return BigInteger__get_ToUInt64(x);\r\n}\r\n\r\nexport function toSingle(x) {\r\n    return BigInteger__get_ToSingle(x);\r\n}\r\n\r\nexport function toDouble(x) {\r\n    return BigInteger__get_ToDouble(x);\r\n}\r\n\r\nexport function toDecimal(x) {\r\n    return BigInteger__get_ToDecimal(x);\r\n}\r\n\r\nexport function sign(x) {\r\n    return BigInteger__get_Sign(x);\r\n}\r\n\r\nexport function isZero(x) {\r\n    return BigInteger__get_IsZero(x);\r\n}\r\n\r\nexport function isOne(x) {\r\n    return BigInteger__get_IsOne(x);\r\n}\r\n\r\nexport function hash(x) {\r\n    return safeHash(x);\r\n}\r\n\r\nexport function compare(x, y) {\r\n    return x.CompareTo(y);\r\n}\r\n\r\nexport function equals(x, y) {\r\n    return equals_1(x, y);\r\n}\r\n\r\nexport function toString(x) {\r\n    return toString_1(x);\r\n}\r\n\r\nexport const get_Zero = BigInteger_get_Zero();\r\n\r\nexport const get_One = BigInteger_get_One();\r\n\r\nexport function op_Addition(arg00, arg01) {\r\n    return BigInteger_op_Addition_56F059C0(arg00, arg01);\r\n}\r\n\r\nexport function op_Subtraction(arg00, arg01) {\r\n    return BigInteger_op_Subtraction_56F059C0(arg00, arg01);\r\n}\r\n\r\nexport function op_Multiply(arg00, arg01) {\r\n    return BigInteger_op_Multiply_56F059C0(arg00, arg01);\r\n}\r\n\r\nexport function op_Division(arg00, arg01) {\r\n    return BigInteger_op_Division_56F059C0(arg00, arg01);\r\n}\r\n\r\nexport function op_Modulus(arg00, arg01) {\r\n    return BigInteger_op_Modulus_56F059C0(arg00, arg01);\r\n}\r\n\r\nexport function op_UnaryNegation(arg00) {\r\n    return BigInteger_op_UnaryNegation_Z665282C2(arg00);\r\n}\r\n\r\nexport function op_UnaryPlus(arg00) {\r\n    return BigInteger_op_UnaryPlus_Z665282C2(arg00);\r\n}\r\n\r\nexport function op_RightShift(arg00, arg01) {\r\n    return BigInteger_op_RightShift_62E082A2(arg00, arg01);\r\n}\r\n\r\nexport function op_LeftShift(arg00, arg01) {\r\n    return BigInteger_op_LeftShift_62E082A2(arg00, arg01);\r\n}\r\n\r\nexport function op_BitwiseAnd(arg00, arg01) {\r\n    return BigInteger_op_BitwiseAnd_56F059C0(arg00, arg01);\r\n}\r\n\r\nexport function op_BitwiseOr(arg00, arg01) {\r\n    return BigInteger_op_BitwiseOr_56F059C0(arg00, arg01);\r\n}\r\n\r\nexport function op_ExclusiveOr(arg00, arg01) {\r\n    return BigInteger_op_ExclusiveOr_56F059C0(arg00, arg01);\r\n}\r\n\r\nexport function op_LessThan(arg00, arg01) {\r\n    return BigInteger_op_LessThan_56F059C0(arg00, arg01);\r\n}\r\n\r\nexport function op_LessThanOrEqual(arg00, arg01) {\r\n    return BigInteger_op_LessThanOrEqual_56F059C0(arg00, arg01);\r\n}\r\n\r\nexport function op_GreaterThan(arg00, arg01) {\r\n    return BigInteger_op_GreaterThan_56F059C0(arg00, arg01);\r\n}\r\n\r\nexport function op_GreaterThanOrEqual(arg00, arg01) {\r\n    return BigInteger_op_GreaterThanOrEqual_56F059C0(arg00, arg01);\r\n}\r\n\r\nexport function op_Equality(arg00, arg01) {\r\n    return BigInteger_op_Equality_56F059C0(arg00, arg01);\r\n}\r\n\r\nexport function op_Inequality(arg00, arg01) {\r\n    return BigInteger_op_Inequality_56F059C0(arg00, arg01);\r\n}\r\n\r\nfunction flipTwosComplement(currByte, lowBitFound) {\r\n    const matchValue = [currByte, lowBitFound];\r\n    if (matchValue[1]) {\r\n        return [(currByte ^ 255) & 255, true];\r\n    }\r\n    else if (matchValue[0] === 0) {\r\n        return [0, false];\r\n    }\r\n    else {\r\n        return [(currByte ^ (254 << (new Int32Array([0, 1, 2, 3, 4, 5, 6, 7])).find((i) => ((currByte & (1 << i)) > 0)))) & 255, true];\r\n    }\r\n}\r\n\r\nexport function toByteArray(value) {\r\n    if (equals_1(value, zero)) {\r\n        return new Uint8Array([0]);\r\n    }\r\n    else {\r\n        const isPositive = compare_1(value, zero) > 0;\r\n        const value_1 = isPositive ? value : BigInteger_op_Multiply_56F059C0(BigInteger_$ctor_Z524259A4(-1), value);\r\n        const mask32 = fromInt64(fromInteger(4294967295, false, 6));\r\n        const loop = (accumBytes_mut, consumeValue_mut, lowBitFound_mut) => {\r\n            let value_6, value_8, value_9, value_10;\r\n            loop:\r\n            while (true) {\r\n                const accumBytes = accumBytes_mut, consumeValue = consumeValue_mut, lowBitFound = lowBitFound_mut;\r\n                if (compare_1(consumeValue, zero) <= 0) {\r\n                    const accumBytes_1 = isPositive ? skipWhile((b) => (b === 0), accumBytes) : skipWhile((b_1) => (b_1 === 255), accumBytes);\r\n                    const isHighBitOne = (head(accumBytes_1) & 128) !== 0;\r\n                    return reverse(toArray((isPositive ? isHighBitOne : false) ? cons(0, accumBytes_1) : (((!isPositive) ? (!isHighBitOne) : false) ? cons(255, accumBytes_1) : accumBytes_1)));\r\n                }\r\n                else {\r\n                    const currValue = toUInt32(BigInteger_op_BitwiseAnd_56F059C0(consumeValue, mask32));\r\n                    if (isPositive) {\r\n                        const b0 = currValue & 0xFF;\r\n                        let b1;\r\n                        const value_4 = currValue >>> 8;\r\n                        b1 = (value_4 & 0xFF);\r\n                        let b2;\r\n                        const value_5 = currValue >>> 16;\r\n                        b2 = (value_5 & 0xFF);\r\n                        accumBytes_mut = ofArrayWithTail([(value_6 = (currValue >>> 24), value_6 & 0xFF), b2, b1, b0], accumBytes);\r\n                        consumeValue_mut = BigInteger_op_RightShift_62E082A2(consumeValue, 32);\r\n                        lowBitFound_mut = false;\r\n                        continue loop;\r\n                    }\r\n                    else {\r\n                        const patternInput = flipTwosComplement(currValue & 0xFF, lowBitFound);\r\n                        const patternInput_1 = flipTwosComplement((value_8 = (currValue >>> 8), value_8 & 0xFF), patternInput[1]);\r\n                        const patternInput_2 = flipTwosComplement((value_9 = (currValue >>> 16), value_9 & 0xFF), patternInput_1[1]);\r\n                        const patternInput_3 = flipTwosComplement((value_10 = (currValue >>> 24), value_10 & 0xFF), patternInput_2[1]);\r\n                        accumBytes_mut = ofArrayWithTail([patternInput_3[0], patternInput_2[0], patternInput_1[0], patternInput[0]], accumBytes);\r\n                        consumeValue_mut = BigInteger_op_RightShift_62E082A2(consumeValue, 32);\r\n                        lowBitFound_mut = patternInput_3[1];\r\n                        continue loop;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return loop(empty(), value_1, false);\r\n    }\r\n}\r\n\r\nexport function fromByteArray(bytes) {\r\n    if (bytes == null) {\r\n        throw (new Error(\"bytes\"));\r\n    }\r\n    if (bytes.length === 0) {\r\n        return zero;\r\n    }\r\n    else {\r\n        const isPositive = (bytes[bytes.length - 1] & 128) === 0;\r\n        const buffer = fill(new Uint8Array(4), 0, 4, 0);\r\n        const loop = (accumUInt32_mut, currIndex_mut, bytesRemaining_mut, lowBitFound_mut) => {\r\n            loop:\r\n            while (true) {\r\n                const accumUInt32 = accumUInt32_mut, currIndex = currIndex_mut, bytesRemaining = bytesRemaining_mut, lowBitFound = lowBitFound_mut;\r\n                if (bytesRemaining === 0) {\r\n                    const value_2 = fold((acc, value) => BigInteger_op_Addition_56F059C0(BigInteger_op_LeftShift_62E082A2(acc, 32), fromInt64(fromInteger(value, false, 6))), zero, accumUInt32);\r\n                    if (isPositive) {\r\n                        return value_2;\r\n                    }\r\n                    else {\r\n                        return BigInteger_op_Multiply_56F059C0(BigInteger_$ctor_Z524259A4(-1), value_2);\r\n                    }\r\n                }\r\n                else {\r\n                    const bytesToProcess = min((x, y) => comparePrimitives(x, y), bytesRemaining, 4) | 0;\r\n                    for (let i_1 = 0; i_1 <= (bytesToProcess - 1); i_1++) {\r\n                        buffer[i_1] = bytes[currIndex + i_1];\r\n                    }\r\n                    if (isPositive) {\r\n                        fill(buffer, bytesToProcess, 4 - bytesToProcess, 0);\r\n                        accumUInt32_mut = cons((((((buffer[0] | ((buffer[1] << 8) >>> 0)) >>> 0) | ((buffer[2] << 16) >>> 0)) >>> 0) | ((buffer[3] << 24) >>> 0)) >>> 0, accumUInt32);\r\n                        currIndex_mut = (currIndex + bytesToProcess);\r\n                        bytesRemaining_mut = (bytesRemaining - bytesToProcess);\r\n                        lowBitFound_mut = false;\r\n                        continue loop;\r\n                    }\r\n                    else {\r\n                        fill(buffer, bytesToProcess, 4 - bytesToProcess, 255);\r\n                        const patternInput = flipTwosComplement(buffer[0], lowBitFound);\r\n                        const patternInput_1 = flipTwosComplement(buffer[1], patternInput[1]);\r\n                        const patternInput_2 = flipTwosComplement(buffer[2], patternInput_1[1]);\r\n                        const patternInput_3 = flipTwosComplement(buffer[3], patternInput_2[1]);\r\n                        accumUInt32_mut = cons((((((patternInput[0] | ((patternInput_1[0] << 8) >>> 0)) >>> 0) | ((patternInput_2[0] << 16) >>> 0)) >>> 0) | ((patternInput_3[0] << 24) >>> 0)) >>> 0, accumUInt32);\r\n                        currIndex_mut = (currIndex + bytesToProcess);\r\n                        bytesRemaining_mut = (bytesRemaining - bytesToProcess);\r\n                        lowBitFound_mut = patternInput_3[1];\r\n                        continue loop;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return loop(empty(), 0, bytes.length, false);\r\n    }\r\n}\r\n\r\n","import { compare } from \"./Util.js\";\r\nimport { unfold, delay } from \"./Seq.js\";\r\nimport { op_Addition, fromZero } from \"./BigInt.js\";\r\nimport { op_Addition as op_Addition_1, fromParts } from \"./Decimal.js\";\r\nimport { op_Addition as op_Addition_2, fromBits } from \"./Long.js\";\r\n\r\nexport function makeRangeStepFunction(step, stop, zero, add) {\r\n    const stepComparedWithZero = compare(step, zero) | 0;\r\n    if (stepComparedWithZero === 0) {\r\n        throw (new Error(\"The step of a range cannot be zero\"));\r\n    }\r\n    const stepGreaterThanZero = stepComparedWithZero > 0;\r\n    return (x) => {\r\n        const comparedWithLast = compare(x, stop) | 0;\r\n        return ((stepGreaterThanZero ? (comparedWithLast <= 0) : false) ? true : ((!stepGreaterThanZero) ? (comparedWithLast >= 0) : false)) ? [x, add(x, step)] : (void 0);\r\n    };\r\n}\r\n\r\nexport function integralRangeStep(start, step, stop, zero, add) {\r\n    const stepFn = makeRangeStepFunction(step, stop, zero, add);\r\n    return delay(() => unfold(stepFn, start));\r\n}\r\n\r\nexport function rangeBigInt(start, step, stop) {\r\n    return integralRangeStep(start, step, stop, fromZero(), (x, y) => op_Addition(x, y));\r\n}\r\n\r\nexport function rangeDecimal(start, step, stop) {\r\n    return integralRangeStep(start, step, stop, fromParts(0, 0, 0, false, 0), (x, y) => op_Addition_1(x, y));\r\n}\r\n\r\nexport function rangeDouble(start, step, stop) {\r\n    return integralRangeStep(start, step, stop, 0, (x, y) => (x + y));\r\n}\r\n\r\nexport function rangeInt64(start, step, stop) {\r\n    return integralRangeStep(start, step, stop, fromBits(0, 0, false), (x, y) => op_Addition_2(x, y));\r\n}\r\n\r\nexport function rangeUInt64(start, step, stop) {\r\n    return integralRangeStep(start, step, stop, fromBits(0, 0, true), (x, y) => op_Addition_2(x, y));\r\n}\r\n\r\nexport function rangeChar(start, stop) {\r\n    const intStop = stop.charCodeAt(0) | 0;\r\n    return delay(() => unfold((c) => {\r\n        if (c <= intStop) {\r\n            return [String.fromCharCode(c), c + 1];\r\n        }\r\n        else {\r\n            return void 0;\r\n        }\r\n    }, start.charCodeAt(0)));\r\n}\r\n\r\n","namespace Elmish\nopen System\n\n[<Struct>]\ntype internal RingState<'item> =\n    | Writable of wx:'item array * ix:int\n    | ReadWritable of rw:'item array * wix:int * rix:int\n\ntype internal RingBuffer<'item>(size) =\n    let doubleSize ix (items: 'item array) =\n        seq { yield! items |> Seq.skip ix\n              yield! items |> Seq.take ix\n              for _ in 0..items.Length do\n                yield Unchecked.defaultof<'item> }\n        |> Array.ofSeq\n\n    let mutable state : 'item RingState =\n        Writable (Array.zeroCreate (max size 10), 0)\n\n    member __.Pop() =\n        match state with\n        | ReadWritable (items, wix, rix) ->\n            let rix' = (rix + 1) % items.Length\n            match rix' = wix with\n            | true -> \n                state <- Writable(items, wix)\n            | _ ->\n                state <- ReadWritable(items, wix, rix')\n            Some items.[rix]\n        | _ ->\n            None\n\n    member __.Push (item:'item) =\n        match state with\n        | Writable (items, ix) ->\n            items.[ix] <- item\n            let wix = (ix + 1) % items.Length\n            state <- ReadWritable(items, wix, ix)\n        | ReadWritable (items, wix, rix) ->\n            items.[wix] <- item\n            let wix' = (wix + 1) % items.Length\n            match wix' = rix with\n            | true -> \n                state <- ReadWritable(items |> doubleSize rix, items.Length, 0)\n            | _ -> \n                state <- ReadWritable(items, wix', rix)","(**\nProgram\n---------\nCore abstractions for creating and running the dispatch loop.\n\n*)\n\nnamespace Elmish\n\n\n/// Program type captures various aspects of program behavior\ntype Program<'arg, 'model, 'msg, 'view> = private {\n    init : 'arg -> 'model * Cmd<'msg>\n    update : 'msg -> 'model -> 'model * Cmd<'msg>\n    subscribe : 'model -> Cmd<'msg>\n    view : 'model -> Dispatch<'msg> -> 'view\n    setState : 'model -> Dispatch<'msg> -> unit\n    onError : (string*exn) -> unit\n    syncDispatch: Dispatch<'msg> -> Dispatch<'msg>\n}\n\n/// Program module - functions to manipulate program instances\n[<RequireQualifiedAccess>]\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Program =\n    /// Typical program, new commands are produced by `init` and `update` along with the new state.\n    let mkProgram \n        (init : 'arg -> 'model * Cmd<'msg>) \n        (update : 'msg -> 'model -> 'model * Cmd<'msg>)\n        (view : 'model -> Dispatch<'msg> -> 'view) =\n        { init = init\n          update = update\n          view = view\n          setState = fun model -> view model >> ignore\n          subscribe = fun _ -> Cmd.none\n          onError = Log.onError\n          syncDispatch = id }\n\n    /// Simple program that produces only new state with `init` and `update`.\n    let mkSimple \n        (init : 'arg -> 'model) \n        (update : 'msg -> 'model -> 'model)\n        (view : 'model -> Dispatch<'msg> -> 'view) =\n        { init = init >> fun state -> state,Cmd.none\n          update = fun msg -> update msg >> fun state -> state,Cmd.none\n          view = view\n          setState = fun model -> view model >> ignore\n          subscribe = fun _ -> Cmd.none\n          onError = Log.onError\n          syncDispatch = id }\n\n    /// Subscribe to external source of events.\n    /// The subscription is called once - with the initial model, but can dispatch new messages at any time.\n    let withSubscription (subscribe : 'model -> Cmd<'msg>) (program: Program<'arg, 'model, 'msg, 'view>) =\n        let sub model =\n            Cmd.batch [ program.subscribe model\n                        subscribe model ]\n        { program with subscribe = sub }\n\n    /// Trace all the updates to the console\n    let withConsoleTrace (program: Program<'arg, 'model, 'msg, 'view>) =\n        let traceInit (arg:'arg) =\n            let initModel,cmd = program.init arg\n            Log.toConsole (\"Initial state:\", initModel)\n            initModel,cmd\n\n        let traceUpdate msg model =\n            Log.toConsole (\"New message:\", msg)\n            let newModel,cmd = program.update msg model\n            Log.toConsole (\"Updated state:\", newModel)\n            newModel,cmd\n\n        { program with\n            init = traceInit \n            update = traceUpdate }\n\n    /// Trace all the messages as they update the model\n    let withTrace trace (program: Program<'arg, 'model, 'msg, 'view>) =\n        let update msg model =\n            let state,cmd = program.update msg model\n            trace msg state\n            state,cmd\n        { program\n            with update = update }\n\n    /// Handle dispatch loop exceptions\n    let withErrorHandler onError (program: Program<'arg, 'model, 'msg, 'view>) =\n        { program\n            with onError = onError }\n\n    /// For library authors only: map existing error handler and return new `Program` \n    let mapErrorHandler map (program: Program<'arg, 'model, 'msg, 'view>) =\n        { program\n            with onError = map program.onError }\n\n    /// For library authors only: get the current error handler \n    let onError (program: Program<'arg, 'model, 'msg, 'view>) =\n        program.onError\n\n    /// For library authors only: function to render the view with the latest state \n    let withSetState (setState:'model -> Dispatch<'msg> -> unit)\n                     (program: Program<'arg, 'model, 'msg, 'view>) =        \n        { program\n            with setState = setState }\n\n    /// For library authors only: return the function to render the state \n    let setState (program: Program<'arg, 'model, 'msg, 'view>) =        \n        program.setState\n\n    /// For library authors only: return the view function \n    let view (program: Program<'arg, 'model, 'msg, 'view>) =        \n        program.view\n\n    /// For library authors only: function to synchronize the dispatch function\n    let withSyncDispatch (syncDispatch:Dispatch<'msg> -> Dispatch<'msg>)\n                         (program: Program<'arg, 'model, 'msg, 'view>) =        \n        { program\n            with syncDispatch = syncDispatch }\n\n    /// For library authors only: map the program type\n    let map mapInit mapUpdate mapView mapSetState mapSubscribe\n            (program: Program<'arg, 'model, 'msg, 'view>) =\n        { init = mapInit program.init\n          update = mapUpdate program.update\n          view = mapView program.view\n          setState = mapSetState program.setState\n          subscribe = mapSubscribe program.subscribe\n          onError = program.onError\n          syncDispatch = id }\n\n    /// Start the program loop.\n    /// arg: argument to pass to the init() function.\n    /// program: program created with 'mkSimple' or 'mkProgram'.\n    let runWith (arg: 'arg) (program: Program<'arg, 'model, 'msg, 'view>) =\n        let (model,cmd) = program.init arg\n        let rb = RingBuffer 10\n        let mutable reentered = false\n        let mutable state = model        \n        let rec dispatch msg = \n            if reentered then\n                rb.Push msg\n            else\n                reentered <- true\n                let mutable nextMsg = Some msg\n                while Option.isSome nextMsg do\n                    let msg = nextMsg.Value\n                    try\n                        let (model',cmd') = program.update msg state\n                        program.setState model' syncDispatch\n                        cmd' |> Cmd.exec (fun ex -> program.onError (sprintf \"Error in command while handling: %A\" msg, ex)) syncDispatch\n                        state <- model'\n                    with ex ->\n                        program.onError (sprintf \"Unable to process the message: %A\" msg, ex)\n                    nextMsg <- rb.Pop()\n                reentered <- false\n        and syncDispatch = program.syncDispatch dispatch            \n\n        program.setState model syncDispatch\n        let sub = \n            try \n                program.subscribe model \n            with ex ->\n                program.onError (\"Unable to subscribe:\", ex)\n                Cmd.none\n        Cmd.batch [sub; cmd]\n        |> Cmd.exec (fun ex -> program.onError (\"Error intitializing:\", ex)) syncDispatch\n\n    /// Start the dispatch loop with `unit` for the init() function.\n    let run (program: Program<unit, 'model, 'msg, 'view>) = runWith () program\n","namespace Elmish.React\n\nopen Fable.React\nopen Elmish\n\ntype LazyProps<'model> = {\n    model:'model\n    render:unit->ReactElement\n    equal:'model->'model->bool\n}\n\nmodule Components =\n    type LazyView<'model>(props) =\n        inherit Component<LazyProps<'model>,obj>(props)\n\n        override this.shouldComponentUpdate(nextProps, _nextState) =\n            not <| this.props.equal this.props.model nextProps.model\n\n        override this.render () =\n            this.props.render ()\n\n[<AutoOpen>]\nmodule Common =\n    /// Avoid rendering the view unless the model has changed.\n    /// equal: function to compare the previous and the new states\n    /// view: function to render the model\n    /// state: new state to render\n    let lazyViewWith (equal:'model->'model->bool)\n                     (view:'model->ReactElement)\n                     (state:'model) =\n        ofType<Components.LazyView<_>,_,_>\n            { render = fun () -> view state\n              equal = equal\n              model = state }\n            []\n\n    /// Avoid rendering the view unless the model has changed.\n    /// equal: function to compare the previous and the new states\n    /// view: function to render the model using the dispatch\n    /// state: new state to render\n    /// dispatch: dispatch function\n    let lazyView2With (equal:'model->'model->bool)\n                      (view:'model->'msg Dispatch->ReactElement)\n                      (state:'model)\n                      (dispatch:'msg Dispatch) =\n        ofType<Components.LazyView<_>,_,_>\n            { render = fun () -> view state dispatch\n              equal = equal\n              model = state }\n            []\n\n    /// Avoid rendering the view unless the model has changed.\n    /// equal: function to compare the previous and the new model (a tuple of two states)\n    /// view: function to render the model using the dispatch\n    /// state1: new state to render\n    /// state2: new state to render\n    /// dispatch: dispatch function\n    let lazyView3With (equal:_->_->bool) (view:_->_->_->ReactElement) state1 state2 (dispatch:'msg Dispatch) =\n        ofType<Components.LazyView<_>,_,_>\n            { render = fun () -> view state1 state2 dispatch\n              equal = equal\n              model = (state1,state2) }\n            []\n\n    /// Avoid rendering the view unless the model has changed.\n    /// view: function of model to render the view\n    let lazyView (view:'model->ReactElement) =\n        lazyViewWith (=) view\n\n    /// Avoid rendering the view unless the model has changed.\n    /// view: function of two arguments to render the model using the dispatch\n    let lazyView2 (view:'model->'msg Dispatch->ReactElement) =\n        lazyView2With (=) view\n\n    /// Avoid rendering the view unless the model has changed.\n    /// view: function of three arguments to render the model using the dispatch\n    let lazyView3 (view:_->_->_->ReactElement) =\n        lazyView3With (=) view\n\n\n","namespace Elmish.React\n\n[<AutoOpen>]\nmodule Helpers =\n    open Fable.React.Props\n    open Fable.Core.JsInterop\n\n    /// `Ref` callback that sets the value of an input textbox after DOM element is created.\n    /// Can be used instead of `DefaultValue` and `Value` props to override input box value.\n    let inline valueOrDefault value =\n        Ref <| (fun e -> if e |> isNull |> not && !!e?value <> !!value then e?value <- !!value)\n\n[<RequireQualifiedAccess>]\nmodule Program =\n\n    module Internal =\n\n        open Fable.React\n        open Browser\n        open Elmish\n\n        let withReactBatchedUsing lazyView2With placeholderId (program:Program<_,_,_,_>) =\n            let mutable lastRequest = None\n            let setState model dispatch =\n                match lastRequest with\n                | Some r -> window.cancelAnimationFrame r\n                | _ -> ()\n\n                lastRequest <- Some (window.requestAnimationFrame (fun _ ->\n                    ReactDom.render(\n                        lazyView2With (fun x y -> obj.ReferenceEquals(x,y)) (Program.view program) model dispatch,\n                        document.getElementById placeholderId\n                    )))\n\n            program\n            |> Program.withSetState setState\n\n        let withReactSynchronousUsing lazyView2With placeholderId (program:Elmish.Program<_,_,_,_>) =\n            let setState model dispatch =\n                ReactDom.render(\n                    lazyView2With (fun x y -> obj.ReferenceEquals(x,y)) (Program.view program) model dispatch,\n                    document.getElementById placeholderId\n                )\n\n            program\n            |> Program.withSetState setState\n\n        let withReactHydrateUsing lazyView2With placeholderId (program:Elmish.Program<_,_,_,_>) =\n            let setState model dispatch =\n                ReactDom.hydrate(\n                    lazyView2With (fun x y -> obj.ReferenceEquals(x,y)) (Program.view program) model dispatch,\n                    document.getElementById placeholderId\n                )\n\n            program\n            |> Program.withSetState setState\n\n\n    /// Renders React root component inside html element identified by placeholderId.\n    /// Uses `requestAnimationFrame` to batch updates to prevent drops in frame rate.\n    /// NOTE: This may have unexpected effects in React controlled inputs, see https://github.com/elmish/react/issues/12\n    let withReactBatched placeholderId (program:Elmish.Program<_,_,_,_>) =\n        Internal.withReactBatchedUsing lazyView2With placeholderId program\n\n    /// Renders React root component inside html element identified by placeholderId.\n    /// New renders are triggered immediately after an update.\n    let withReactSynchronous placeholderId (program:Elmish.Program<_,_,_,_>) =\n        Internal.withReactSynchronousUsing lazyView2With placeholderId program\n\n    [<System.Obsolete(\"Use withReactBatched\")>]\n    let withReact placeholderId (program:Elmish.Program<_,_,_,_>) =\n        Internal.withReactBatchedUsing lazyView2With placeholderId program\n\n    [<System.Obsolete(\"Use withReactSynchronous\")>]\n    let withReactUnoptimized placeholderId (program:Elmish.Program<_,_,_,_>) =\n        Internal.withReactSynchronousUsing lazyView2With placeholderId program\n\n    /// Renders React root component inside html element identified by placeholderId using `React.hydrate`.\n    let withReactHydrate placeholderId (program:Elmish.Program<_,_,_,_>) =\n        Internal.withReactHydrateUsing lazyView2With placeholderId program\n","import { equals } from \"./Util.js\";\nimport { Union } from \"./Types.js\";\nconst CaseRules = {\n    None: 0,\n    LowerFirst: 1,\n    SnakeCase: 2,\n    SnakeCaseAllCaps: 3,\n    KebabCase: 4,\n};\nfunction dashify(str, separator) {\n    return str.replace(/[a-z]?[A-Z]/g, (m) => m.length === 1\n        ? m.toLowerCase()\n        : m.charAt(0) + separator + m.charAt(1).toLowerCase());\n}\nfunction changeCase(str, caseRule) {\n    switch (caseRule) {\n        case CaseRules.LowerFirst:\n            return str.charAt(0).toLowerCase() + str.slice(1);\n        case CaseRules.SnakeCase:\n            return dashify(str, \"_\");\n        case CaseRules.SnakeCaseAllCaps:\n            return dashify(str, \"_\").toUpperCase();\n        case CaseRules.KebabCase:\n            return dashify(str, \"-\");\n        case CaseRules.None:\n        default:\n            return str;\n    }\n}\nexport function keyValueList(fields, caseRule = CaseRules.None) {\n    const obj = {};\n    const definedCaseRule = caseRule;\n    function fail(kvPair) {\n        throw new Error(\"Cannot infer key and value of \" + String(kvPair));\n    }\n    function assign(key, caseRule, value) {\n        key = changeCase(key, caseRule);\n        obj[key] = value;\n    }\n    for (let kvPair of fields) {\n        let caseRule = CaseRules.None;\n        if (kvPair == null) {\n            fail(kvPair);\n        }\n        // Deflate unions and use the defined case rule\n        if (kvPair instanceof Union) {\n            const name = kvPair.cases()[kvPair.tag];\n            kvPair = kvPair.fields.length === 0 ? name : [name].concat(kvPair.fields);\n            caseRule = definedCaseRule;\n        }\n        if (Array.isArray(kvPair)) {\n            switch (kvPair.length) {\n                case 0:\n                    fail(kvPair);\n                    break;\n                case 1:\n                    assign(kvPair[0], caseRule, true);\n                    break;\n                case 2:\n                    const value = kvPair[1];\n                    assign(kvPair[0], caseRule, value);\n                    break;\n                default:\n                    assign(kvPair[0], caseRule, kvPair.slice(1));\n            }\n        }\n        else if (typeof kvPair === \"string\") {\n            assign(kvPair, caseRule, true);\n        }\n        else {\n            fail(kvPair);\n        }\n    }\n    return obj;\n}\n// TODO: Move these methods to Map and Set modules\nexport function containsValue(v, map) {\n    for (const kv of map) {\n        if (equals(v, kv[1])) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function tryGetValue(map, key, defaultValue) {\n    if (map.has(key)) {\n        defaultValue.contents = map.get(key);\n        return true;\n    }\n    return false;\n}\nexport function addToSet(v, set) {\n    if (set.has(v)) {\n        return false;\n    }\n    set.add(v);\n    return true;\n}\nexport function addToDict(dict, k, v) {\n    if (dict.has(k)) {\n        throw new Error(\"An item with the same key has already been added. Key: \" + k);\n    }\n    dict.set(k, v);\n}\nexport function getItemFromDict(map, key) {\n    if (map.has(key)) {\n        return map.get(key);\n    }\n    else {\n        throw new Error(`The given key '${key}' was not present in the dictionary.`);\n    }\n}\n","namespace Feliz.DaisyUI\r\n\r\nopen Feliz\r\nopen Fable.Core\r\n\r\nmodule Helpers =\r\n    let [<Literal>] private ClassName = \"className\"\r\n\r\n    let inline internal getClasses (xs:IReactProperty list) =\r\n        xs\r\n        |> List.choose (unbox<string * obj> >> function\r\n            | (k, v) when k = ClassName -> Some (string v)\r\n            | _ -> None)\r\n\r\n    let extractClasses (xs:IReactProperty list) =\r\n        xs\r\n        |> List.rev\r\n        |> List.fold (fun (classes, props) x ->\r\n            match unbox<string * obj> x with\r\n            | (k, v) when k = ClassName -> string v :: classes, props\r\n            | _ -> classes, x :: props) ([], [])\r\n\r\n    let combineClasses cn (xs:IReactProperty list) =\r\n        xs\r\n        |> extractClasses\r\n        |> fun (classes, props) -> (cn :: classes |> prop.classes) :: props\r\n\r\n    module Elm =\r\n        let inline props buildFn (xs:IReactProperty list) (cn:string) = buildFn (combineClasses cn xs)\r\n        let inline children buildFn (children:seq<ReactElement>) (cn:string) = buildFn [ prop.className cn; prop.children children ]\r\n        let inline elm buildFn (child:ReactElement) (cn:string) = buildFn [ prop.className cn; prop.children [ child ] ]\r\n        let inline string buildFn (value:string) (cn:string) = buildFn [ prop.className cn; prop.text value ]\r\n        let inline int buildFn (value:int) (cn:string) = buildFn [ prop.className cn; prop.text value ]\r\n        let inline float buildFn (value:float) (cn:string) = buildFn [ prop.className cn; prop.text value ]\r\n\r\n[<Erase>]\r\ntype Daisy =\r\n    static member inline alert props = Helpers.Elm.props Html.div props \"alert\"\r\n    static member inline alert (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"alert\"\r\n    static member inline alert elm = Helpers.Elm.elm Html.div elm \"alert\"\r\n    static member inline alert string = Helpers.Elm.string Html.div string \"alert\"\r\n    static member inline alert int = Helpers.Elm.int Html.div int \"alert\"\r\n    static member inline alert float = Helpers.Elm.float Html.div float \"alert\"\r\n\r\n    static member inline artboard props = Helpers.Elm.props Html.div props \"artboard\"\r\n    static member inline artboard (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"artboard\"\r\n    static member inline artboard elm = Helpers.Elm.elm Html.div elm \"artboard\"\r\n    static member inline artboard string = Helpers.Elm.string Html.div string \"artboard\"\r\n    static member inline artboard int = Helpers.Elm.int Html.div int \"artboard\"\r\n    static member inline artboard float = Helpers.Elm.float Html.div float \"artboard\"\r\n\r\n    static member inline avatar props = Helpers.Elm.props Html.div props \"avatar\"\r\n    static member inline avatar (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"avatar\"\r\n    static member inline avatar elm = Helpers.Elm.elm Html.div elm \"avatar\"\r\n\r\n    static member inline avatarGroup props = Helpers.Elm.props Html.div props \"avatar-group\"\r\n    static member inline avatarGroup (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"avatar-group\"\r\n    static member inline avatarGroup elm = Helpers.Elm.elm Html.div elm \"avatar-group\"\r\n\r\n    static member inline badge props = Helpers.Elm.props Html.div props \"badge\"\r\n    static member inline badge (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"badge\"\r\n    static member inline badge elm = Helpers.Elm.elm Html.div elm \"badge\"\r\n    static member inline badge string = Helpers.Elm.string Html.div string \"badge\"\r\n    static member inline badge int = Helpers.Elm.int Html.div int \"badge\"\r\n    static member inline badge float = Helpers.Elm.float Html.div float \"badge\"\r\n\r\n    static member inline breadcrumbs props = Helpers.Elm.props Html.div props \"breadcrumbs\"\r\n    static member inline breadcrumbs (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"breadcrumbs\"\r\n    static member inline breadcrumbs elm = Helpers.Elm.elm Html.div elm \"breadcrumbs\"\r\n    static member inline breadcrumbs string = Helpers.Elm.string Html.div string \"breadcrumbs\"\r\n    static member inline breadcrumbs int = Helpers.Elm.int Html.div int \"breadcrumbs\"\r\n    static member inline breadcrumbs float = Helpers.Elm.float Html.div float \"breadcrumbs\"\r\n\r\n    static member inline buttonGroup props = Helpers.Elm.props Html.div props \"btn-group\"\r\n    static member inline buttonGroup (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"btn-group\"\r\n    static member inline buttonGroup elm = Helpers.Elm.elm Html.div elm \"btn-group\"\r\n    static member inline buttonGroup string = Helpers.Elm.string Html.div string \"btn-group\"\r\n    static member inline buttonGroup int = Helpers.Elm.int Html.div int \"btn-group\"\r\n    static member inline buttonGroup float = Helpers.Elm.float Html.div float \"btn-group\"\r\n\r\n    static member inline card props = Helpers.Elm.props Html.div props \"card\"\r\n    static member inline card (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"card\"\r\n    static member inline card elm = Helpers.Elm.elm Html.div elm \"card\"\r\n\r\n    static member inline cardTitle props = Helpers.Elm.props Html.h2 props \"card-title\"\r\n    static member inline cardTitle (children: #seq<ReactElement>) = Helpers.Elm.children Html.h2 children \"card-title\"\r\n    static member inline cardTitle elm = Helpers.Elm.elm Html.h2 elm \"card-title\"\r\n    static member inline cardTitle string = Helpers.Elm.string Html.h2 string \"card-title\"\r\n    static member inline cardTitle int = Helpers.Elm.int Html.h2 int \"card-title\"\r\n    static member inline cardTitle float = Helpers.Elm.float Html.h2 float \"card-title\"\r\n\r\n    static member inline cardBody props = Helpers.Elm.props Html.div props \"card-body\"\r\n    static member inline cardBody (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"card-body\"\r\n    static member inline cardBody elm = Helpers.Elm.elm Html.div elm \"card-body\"\r\n\r\n    static member inline cardActions props = Helpers.Elm.props Html.div props \"card-actions\"\r\n    static member inline cardActions (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"card-actions\"\r\n    static member inline cardActions elm = Helpers.Elm.elm Html.div elm \"card-actions\"\r\n\r\n    static member inline carousel props = Helpers.Elm.props Html.div props \"carousel\"\r\n    static member inline carousel (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"carousel\"\r\n    static member inline carousel elm = Helpers.Elm.elm Html.div elm \"carousel\"\r\n\r\n    static member inline carouselItem props = Helpers.Elm.props Html.div props \"carousel-item\"\r\n    static member inline carouselItem (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"carousel-item\"\r\n    static member inline carouselItem elm = Helpers.Elm.elm Html.div elm \"carousel-item\"\r\n\r\n    static member inline collapse props = Helpers.Elm.props Html.div props \"collapse\"\r\n    static member inline collapse (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"collapse\"\r\n    static member inline collapse elm = Helpers.Elm.elm Html.div elm \"collapse\"\r\n\r\n    static member inline collapseTitle props = Helpers.Elm.props Html.div props \"collapse-title\"\r\n    static member inline collapseTitle (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"collapse-title\"\r\n    static member inline collapseTitle elm = Helpers.Elm.elm Html.div elm \"collapse-title\"\r\n    static member inline collapseTitle string = Helpers.Elm.string Html.div string \"collapse-title\"\r\n    static member inline collapseTitle int = Helpers.Elm.int Html.div int \"collapse-title\"\r\n    static member inline collapseTitle float = Helpers.Elm.float Html.div float \"collapse-title\"\r\n\r\n    static member inline collapseContent props = Helpers.Elm.props Html.div props \"collapse-content\"\r\n    static member inline collapseContent (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"collapse-content\"\r\n    static member inline collapseContent elm = Helpers.Elm.elm Html.div elm \"collapse-content\"\r\n    static member inline collapseContent string = Helpers.Elm.string Html.div string \"collapse-content\"\r\n    static member inline collapseContent int = Helpers.Elm.int Html.div int \"collapse-content\"\r\n    static member inline collapseContent float = Helpers.Elm.float Html.div float \"collapse-content\"\r\n\r\n    static member inline countdown props = Helpers.Elm.props Html.span props \"countdown\"\r\n    static member inline countdown (children: #seq<ReactElement>) = Helpers.Elm.children Html.span children \"countdown\"\r\n    static member inline countdown elm = Helpers.Elm.elm Html.span elm \"countdown\"\r\n\r\n    static member inline countdownValue (value: int) = Html.span [prop.style [style.custom(\"--value\", value)]]\r\n\r\n    static member inline divider props = Helpers.Elm.props Html.div props \"divider\"\r\n    static member inline divider (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"divider\"\r\n    static member inline divider elm = Helpers.Elm.elm Html.div elm \"divider\"\r\n    static member inline divider string = Helpers.Elm.string Html.div string \"divider\"\r\n    static member inline divider int = Helpers.Elm.int Html.div int \"divider\"\r\n    static member inline divider float = Helpers.Elm.float Html.div float \"divider\"\r\n\r\n    static member inline drawer props = Helpers.Elm.props Html.div props \"drawer\"\r\n    static member inline drawer (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"drawer\"\r\n    static member inline drawer elm = Helpers.Elm.elm Html.div elm \"drawer\"\r\n\r\n    static member inline drawerToggle props = Helpers.Elm.props Html.input (prop.type'.checkbox :: props) \"drawer-toggle\"\r\n\r\n    static member inline drawerContent props = Helpers.Elm.props Html.div props \"drawer-content\"\r\n    static member inline drawerContent (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"drawer-content\"\r\n    static member inline drawerContent elm = Helpers.Elm.elm Html.div elm \"drawer-content\"\r\n\r\n    static member inline drawerSide props = Helpers.Elm.props Html.div props \"drawer-side\"\r\n    static member inline drawerSide (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"drawer-side\"\r\n    static member inline drawerSide elm = Helpers.Elm.elm Html.div elm \"drawer-side\"\r\n\r\n    static member inline drawerOverlay props = Helpers.Elm.props Html.label props \"drawer-overlay\"\r\n\r\n    static member inline dropdown props = Helpers.Elm.props Html.div props \"dropdown\"\r\n    static member inline dropdown (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"dropdown\"\r\n    static member inline dropdown elm = Helpers.Elm.elm Html.div elm \"dropdown\"\r\n\r\n    static member inline dropdownContent props = Helpers.Elm.props Html.ul props \"dropdown-content\"\r\n    static member inline dropdownContent (children: #seq<ReactElement>) = Helpers.Elm.children Html.ul children \"dropdown-content\"\r\n    static member inline dropdownContent elm = Helpers.Elm.elm Html.ul elm \"dropdown-content\"\r\n\r\n    static member inline footer props = Helpers.Elm.props Html.footer props \"footer\"\r\n    static member inline footer (children: #seq<ReactElement>) = Helpers.Elm.children Html.footer children \"footer\"\r\n    static member inline footer elm = Helpers.Elm.elm Html.footer elm \"footer\"\r\n\r\n    static member inline footerTitle props = Helpers.Elm.props Html.span props \"footer-title\"\r\n    static member inline footerTitle (children: #seq<ReactElement>) = Helpers.Elm.children Html.span children \"footer-title\"\r\n    static member inline footerTitle elm = Helpers.Elm.elm Html.span elm \"footer-title\"\r\n    static member inline footerTitle string = Helpers.Elm.string Html.span string \"footer-title\"\r\n    static member inline footerTitle int = Helpers.Elm.int Html.span int \"footer-title\"\r\n    static member inline footerTitle float = Helpers.Elm.float Html.span float \"footer-title\"\r\n\r\n    static member inline hero props = Helpers.Elm.props Html.div props \"hero\"\r\n    static member inline hero (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"hero\"\r\n    static member inline hero elm = Helpers.Elm.elm Html.div elm \"hero\"\r\n\r\n\r\n    static member inline heroContent props = Helpers.Elm.props Html.div props \"hero-content\"\r\n    static member inline heroContent (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"hero-content\"\r\n    static member inline heroContent elm = Helpers.Elm.elm Html.div elm \"hero-content\"\r\n\r\n    static member inline heroOverlay props = Helpers.Elm.props Html.div props \"hero-overlay\"\r\n    static member inline heroOverlay (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"hero-overlay\"\r\n    static member inline heroOverlay elm = Helpers.Elm.elm Html.div elm \"hero-overlay\"\r\n\r\n    static member inline indicator props = Helpers.Elm.props Html.div props \"indicator\"\r\n    static member inline indicator (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"indicator\"\r\n    static member inline indicator elm = Helpers.Elm.elm Html.div elm \"indicator\"\r\n\r\n    static member inline indicatorItem props = Helpers.Elm.props Html.div props \"indicator-item\"\r\n    static member inline indicatorItem (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"indicator-item\"\r\n    static member inline indicatorItem elm = Helpers.Elm.elm Html.div elm \"indicator-item\"\r\n    static member inline indicatorItem string = Helpers.Elm.string Html.div string \"indicator-item\"\r\n    static member inline indicatorItem int = Helpers.Elm.int Html.div int \"indicator-item\"\r\n    static member inline indicatorItem float = Helpers.Elm.float Html.div float \"indicator-item\"\r\n\r\n    static member inline kbd props = Helpers.Elm.props Html.kbd props \"kbd\"\r\n    static member inline kbd (children: #seq<ReactElement>) = Helpers.Elm.children Html.kbd children \"kbd\"\r\n    static member inline kbd elm = Helpers.Elm.elm Html.kbd elm \"kbd\"\r\n    static member inline kbd string = Helpers.Elm.string Html.kbd string \"kbd\"\r\n    static member inline kbd int = Helpers.Elm.int Html.kbd int \"kbd\"\r\n    static member inline kbd float = Helpers.Elm.float Html.kbd float \"kbd\"\r\n\r\n    static member inline link props = Helpers.Elm.props Html.a props \"link\"\r\n    static member inline link (children: #seq<ReactElement>) = Helpers.Elm.children Html.a children \"link\"\r\n    static member inline link elm = Helpers.Elm.elm Html.a elm \"link\"\r\n    static member inline link string = Helpers.Elm.string Html.a string \"link\"\r\n    static member inline link int = Helpers.Elm.int Html.a int \"link\"\r\n    static member inline link float = Helpers.Elm.float Html.a float \"link\"\r\n\r\n    static member inline menu props = Helpers.Elm.props Html.ul props \"menu\"\r\n    static member inline menu (children: #seq<ReactElement>) = Helpers.Elm.children Html.ul children \"menu\"\r\n    static member inline menu elm = Helpers.Elm.elm Html.ul elm \"menu\"\r\n\r\n    static member inline menuTitle props = Helpers.Elm.props Html.li props \"menu-title\"\r\n    static member inline menuTitle (children: #seq<ReactElement>) = Helpers.Elm.children Html.li children \"menu-title\"\r\n    static member inline menuTitle elm = Helpers.Elm.elm Html.li elm \"menu-title\"\r\n    static member inline menuTitle (title: string) = Helpers.Elm.children Html.li [Html.span title] \"menu-title\"\r\n\r\n    static member inline modal props = Helpers.Elm.props Html.div props \"modal\"\r\n    static member inline modal (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"modal\"\r\n    static member inline modal elm = Helpers.Elm.elm Html.div elm \"modal\"\r\n\r\n    static member inline modalBox props = Helpers.Elm.props Html.div props \"modal-box\"\r\n    static member inline modalBox (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"modal-box\"\r\n    static member inline modalBox elm = Helpers.Elm.elm Html.div elm \"modal-box\"\r\n\r\n    static member inline modalAction props = Helpers.Elm.props Html.div props \"modal-action\"\r\n    static member inline modalAction (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"modal-action\"\r\n    static member inline modalAction elm = Helpers.Elm.elm Html.div elm \"modal-action\"\r\n\r\n    static member inline modalToggle props = Helpers.Elm.props Html.input (prop.type'.checkbox :: props) \"modal-toggle\"\r\n\r\n    static member inline modalButton props = Helpers.Elm.props Html.label props \"btn modal-button\"\r\n    static member inline modalButton (children: #seq<ReactElement>) = Helpers.Elm.children Html.label children \"btn modal-button\"\r\n    static member inline modalButton elm = Helpers.Elm.elm Html.label elm \"btn modal-button\"\r\n    static member inline modalButton string = Helpers.Elm.string Html.label string \"btn modal-button\"\r\n    static member inline modalButton int = Helpers.Elm.int Html.label int \"btn modal-button\"\r\n    static member inline modalButton float = Helpers.Elm.float Html.label float \"btn modal-button\"\r\n\r\n    static member inline navbar props = Helpers.Elm.props Html.div props \"navbar\"\r\n    static member inline navbar (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"navbar\"\r\n    static member inline navbar elm = Helpers.Elm.elm Html.div elm \"navbar\"\r\n\r\n    static member inline navbarStart props = Helpers.Elm.props Html.div props \"navbar-start\"\r\n    static member inline navbarStart (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"navbar-start\"\r\n    static member inline navbarStart elm = Helpers.Elm.elm Html.div elm \"navbar-start\"\r\n\r\n    static member inline navbarCenter props = Helpers.Elm.props Html.div props \"navbar-center\"\r\n    static member inline navbarCenter (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"navbar-center\"\r\n    static member inline navbarCenter elm = Helpers.Elm.elm Html.div elm \"navbar-center\"\r\n\r\n    static member inline navbarEnd props = Helpers.Elm.props Html.div props \"navbar-end\"\r\n    static member inline navbarEnd (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"navbar-end\"\r\n    static member inline navbarEnd elm = Helpers.Elm.elm Html.div elm \"navbar-end\"\r\n\r\n    static member inline progress props = Helpers.Elm.props Html.progress props \"progress\"\r\n    static member inline progress (children: #seq<ReactElement>) = Helpers.Elm.children Html.progress children \"progress\"\r\n    static member inline progress elm = Helpers.Elm.elm Html.progress elm \"progress\"\r\n\r\n    static member inline stack props = Helpers.Elm.props Html.div props \"stack\"\r\n    static member inline stack (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"stack\"\r\n    static member inline stack elm = Helpers.Elm.elm Html.div elm \"stack\"\r\n\r\n    static member inline stats props = Helpers.Elm.props Html.div props \"stats\"\r\n    static member inline stats (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"stats\"\r\n    static member inline stats elm = Helpers.Elm.elm Html.div elm \"stats\"\r\n    static member inline stats string = Helpers.Elm.string Html.div string \"stats\"\r\n    static member inline stats int = Helpers.Elm.int Html.div int \"stats\"\r\n    static member inline stats float = Helpers.Elm.float Html.div float \"stats\"\r\n\r\n    static member inline stat props = Helpers.Elm.props Html.div props \"stat\"\r\n    static member inline stat (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"stat\"\r\n    static member inline stat elm = Helpers.Elm.elm Html.div elm \"stat\"\r\n    static member inline stat string = Helpers.Elm.string Html.div string \"stat\"\r\n    static member inline stat int = Helpers.Elm.int Html.div int \"stat\"\r\n    static member inline stat float = Helpers.Elm.float Html.div float \"stat\"\r\n\r\n    static member inline statTitle props = Helpers.Elm.props Html.div props \"stat-title\"\r\n    static member inline statTitle (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"stat-title\"\r\n    static member inline statTitle elm = Helpers.Elm.elm Html.div elm \"stat-title\"\r\n    static member inline statTitle string = Helpers.Elm.string Html.div string \"stat-title\"\r\n    static member inline statTitle int = Helpers.Elm.int Html.div int \"stat-title\"\r\n    static member inline statTitle float = Helpers.Elm.float Html.div float \"stat-title\"\r\n\r\n    static member inline statValue props = Helpers.Elm.props Html.div props \"stat-value\"\r\n    static member inline statValue (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"stat-value\"\r\n    static member inline statValue elm = Helpers.Elm.elm Html.div elm \"stat-value\"\r\n    static member inline statValue string = Helpers.Elm.string Html.div string \"stat-value\"\r\n    static member inline statValue int = Helpers.Elm.int Html.div int \"stat-value\"\r\n    static member inline statValue float = Helpers.Elm.float Html.div float \"stat-value\"\r\n\r\n    static member inline statDesc props = Helpers.Elm.props Html.div props \"stat-desc\"\r\n    static member inline statDesc (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"stat-desc\"\r\n    static member inline statDesc elm = Helpers.Elm.elm Html.div elm \"stat-desc\"\r\n    static member inline statDesc string = Helpers.Elm.string Html.div string \"stat-desc\"\r\n    static member inline statDesc int = Helpers.Elm.int Html.div int \"stat-desc\"\r\n    static member inline statDesc float = Helpers.Elm.float Html.div float \"stat-desc\"\r\n\r\n    static member inline statFigure props = Helpers.Elm.props Html.div props \"stat-figure\"\r\n    static member inline statFigure (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"stat-figure\"\r\n    static member inline statFigure elm = Helpers.Elm.elm Html.div elm \"stat-figure\"\r\n    static member inline statFigure string = Helpers.Elm.string Html.div string \"stat-figure\"\r\n    static member inline statFigure int = Helpers.Elm.int Html.div int \"stat-figure\"\r\n    static member inline statFigure float = Helpers.Elm.float Html.div float \"stat-figure\"\r\n\r\n    static member inline steps props = Helpers.Elm.props Html.ul props \"steps\"\r\n    static member inline steps (children: #seq<ReactElement>) = Helpers.Elm.children Html.ul children \"steps\"\r\n    static member inline steps elm = Helpers.Elm.elm Html.ul elm \"steps\"\r\n\r\n    static member inline step props = Helpers.Elm.props Html.li props \"step\"\r\n    static member inline step (children: #seq<ReactElement>) = Helpers.Elm.children Html.li children \"step\"\r\n    static member inline step elm = Helpers.Elm.elm Html.li elm \"step\"\r\n    static member inline step string = Helpers.Elm.string Html.li string \"step\"\r\n    static member inline step int = Helpers.Elm.int Html.li int \"step\"\r\n    static member inline step float = Helpers.Elm.float Html.li float \"step\"\r\n\r\n    static member inline tabs props = Helpers.Elm.props Html.div props \"tabs\"\r\n    static member inline tabs (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"tabs\"\r\n    static member inline tabs elm = Helpers.Elm.elm Html.div elm \"tabs\"\r\n\r\n    static member inline tab props = Helpers.Elm.props Html.a props \"tab\"\r\n    static member inline tab (children: #seq<ReactElement>) = Helpers.Elm.children Html.a children \"tab\"\r\n    static member inline tab elm = Helpers.Elm.elm Html.a elm \"tab\"\r\n    static member inline tab string = Helpers.Elm.string Html.a string \"tab\"\r\n    static member inline tab int = Helpers.Elm.int Html.a int \"tab\"\r\n    static member inline tab float = Helpers.Elm.float Html.a float \"tab\"\r\n\r\n    static member inline table props = Helpers.Elm.props Html.table props \"table\"\r\n    static member inline table (children: #seq<ReactElement>) = Helpers.Elm.children Html.table children \"table\"\r\n    static member inline table elm = Helpers.Elm.elm Html.table elm \"table\"\r\n\r\n    static member inline tooltip props = Helpers.Elm.props Html.div props \"tooltip\"\r\n    static member inline tooltip (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"tooltip\"\r\n    static member inline tooltip elm = Helpers.Elm.elm Html.div elm \"tooltip\"\r\n\r\n    static member inline formControl props = Helpers.Elm.props Html.div props \"form-control\"\r\n    static member inline formControl (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"form-control\"\r\n    static member inline formControl elm = Helpers.Elm.elm Html.div elm \"form-control\"\r\n\r\n    static member inline checkbox props = Helpers.Elm.props Html.input (prop.type'.checkbox :: props) \"checkbox\"\r\n\r\n    static member inline label props = Helpers.Elm.props Html.label props \"label\"\r\n    static member inline label (children: #seq<ReactElement>) = Helpers.Elm.children Html.label children \"label\"\r\n    static member inline label elm = Helpers.Elm.elm Html.label elm \"label\"\r\n\r\n    static member inline labelText props = Helpers.Elm.props Html.span props \"label-text\"\r\n    static member inline labelText (children: #seq<ReactElement>) = Helpers.Elm.children Html.span children \"label-text\"\r\n    static member inline labelText elm = Helpers.Elm.elm Html.span elm \"label-text\"\r\n    static member inline labelText string = Helpers.Elm.string Html.span string \"label-text\"\r\n    static member inline labelText int = Helpers.Elm.int Html.span int \"label-text\"\r\n    static member inline labelText float = Helpers.Elm.float Html.span float \"label-text\"\r\n\r\n    static member inline labelTextAlt props = Helpers.Elm.props Html.span props \"label-text-alt\"\r\n    static member inline labelTextAlt (children: #seq<ReactElement>) = Helpers.Elm.children Html.span children \"label-text-alt\"\r\n    static member inline labelTextAlt elm = Helpers.Elm.elm Html.span elm \"label-text-alt\"\r\n    static member inline labelTextAlt string = Helpers.Elm.string Html.span string \"label-text-alt\"\r\n    static member inline labelTextAlt int = Helpers.Elm.int Html.span int \"label-text-alt\"\r\n    static member inline labelTextAlt float = Helpers.Elm.float Html.span float \"label-text-alt\"\r\n\r\n    static member inline input props = Helpers.Elm.props Html.input (prop.type'.text :: props) \"input\"\r\n\r\n    static member inline inputGroup props = Helpers.Elm.props Html.div props \"input-group\"\r\n    static member inline inputGroup (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"input-group\"\r\n    static member inline inputGroup elm = Helpers.Elm.elm Html.div elm \"input-group\"\r\n\r\n    static member inline radio props = Helpers.Elm.props Html.input (prop.type'.radio :: props) \"radio\"\r\n\r\n    static member inline range props = Helpers.Elm.props Html.input (prop.type'.range :: props) \"range\"\r\n\r\n    static member inline select props = Helpers.Elm.props Html.select props \"select\"\r\n    static member inline select (children: #seq<ReactElement>) = Helpers.Elm.children Html.select children \"select\"\r\n    static member inline select elm = Helpers.Elm.elm Html.select elm \"select\"\r\n\r\n    static member inline textarea props = Helpers.Elm.props Html.textarea props \"textarea\"\r\n    static member inline textarea (children: #seq<ReactElement>) = Helpers.Elm.children Html.textarea children \"textarea\"\r\n    static member inline textarea elm = Helpers.Elm.elm Html.textarea elm \"textarea\"\r\n\r\n    static member inline toggle props = Helpers.Elm.props Html.input (prop.type'.checkbox :: props) \"toggle\"\r\n\r\n    static member inline mockupCode props = Helpers.Elm.props Html.div props \"mockup-code\"\r\n    static member inline mockupCode (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"mockup-code\"\r\n    static member inline mockupCode elm = Helpers.Elm.elm Html.div elm \"mockup-code\"\r\n\r\n    static member inline mockupPhone props = Helpers.Elm.props Html.div props \"mockup-phone\"\r\n    static member inline mockupPhone (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"mockup-phone\"\r\n    static member inline mockupPhone elm = Helpers.Elm.elm Html.div elm \"mockup-phone\"\r\n\r\n    static member inline mockupPhoneCamera props = Helpers.Elm.props Html.div props \"camera\"\r\n    static member inline mockupPhoneCamera (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"camera\"\r\n    static member inline mockupPhoneCamera elm = Helpers.Elm.elm Html.div elm \"camera\"\r\n\r\n    static member inline mockupPhoneDisplay props = Helpers.Elm.props Html.div props \"display\"\r\n    static member inline mockupPhoneDisplay (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"display\"\r\n    static member inline mockupPhoneDisplay elm = Helpers.Elm.elm Html.div elm \"display\"\r\n\r\n    static member inline mockupWindow props = Helpers.Elm.props Html.div props \"mockup-window\"\r\n    static member inline mockupWindow (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"mockup-window\"\r\n    static member inline mockupWindow elm = Helpers.Elm.elm Html.div elm \"mockup-window\"\r\n\r\n\r\nmodule Daisy =\r\n    [<Erase>]\r\n    type button =\r\n        static member inline div props = Helpers.Elm.props Html.div props \"btn\"\r\n        static member inline div (children: #seq<ReactElement>) = Helpers.Elm.children Html.div children \"btn\"\r\n        static member inline div elm = Helpers.Elm.elm Html.div elm \"btn\"\r\n        static member inline div string = Helpers.Elm.string Html.div string \"btn\"\r\n        static member inline div int = Helpers.Elm.int Html.div int \"btn\"\r\n        static member inline div float = Helpers.Elm.float Html.div float \"btn\"\r\n\r\n        static member inline button props = Helpers.Elm.props Html.button props \"btn\"\r\n        static member inline button (children: #seq<ReactElement>) = Helpers.Elm.children Html.button children \"btn\"\r\n        static member inline button elm = Helpers.Elm.elm Html.button elm \"btn\"\r\n        static member inline button string = Helpers.Elm.string Html.button string \"btn\"\r\n        static member inline button int = Helpers.Elm.int Html.button int \"btn\"\r\n        static member inline button float = Helpers.Elm.float Html.button float \"btn\"\r\n\r\n        static member inline label props = Helpers.Elm.props Html.label props \"btn\"\r\n        static member inline label (children: #seq<ReactElement>) = Helpers.Elm.children Html.label children \"btn\"\r\n        static member inline label elm = Helpers.Elm.elm Html.label elm \"btn\"\r\n        static member inline label string = Helpers.Elm.string Html.label string \"btn\"\r\n        static member inline label int = Helpers.Elm.int Html.label int \"btn\"\r\n        static member inline label float = Helpers.Elm.float Html.label float \"btn\"\r\n\r\n        static member inline a props = Helpers.Elm.props Html.a props \"btn\"\r\n        static member inline a (children: #seq<ReactElement>) = Helpers.Elm.children Html.a children \"btn\"\r\n        static member inline a elm = Helpers.Elm.elm Html.a elm \"btn\"\r\n        static member inline a string = Helpers.Elm.string Html.a string \"btn\"\r\n        static member inline a int = Helpers.Elm.int Html.a int \"btn\"\r\n        static member inline a float = Helpers.Elm.float Html.a float \"btn\"\r\n\r\n        static member inline submit props = Helpers.Elm.props Html.input (prop.type'.submit :: props) \"btn\"\r\n        static member inline reset props = Helpers.Elm.props Html.input (prop.type'.reset :: props) \"btn\"\r\n        static member inline inputButton props = Helpers.Elm.props Html.input (prop.type'.button :: props) \"btn\"\r\n","﻿module Feliz.DaisyUI.Operators\r\n\r\nopen Feliz\r\n\r\nlet (++) (prop1:IReactProperty) (prop2:IReactProperty) =\r\n    Helpers.getClasses [prop1; prop2]\r\n    |> fun classes -> prop.classes classes","module Shared\n\nopen Fable.Core\nopen Fable.Core.JsInterop\nopen Fable.React\nopen Feliz\n\nmodule Helpers =\n    let [<Literal>] private ClassName = \"className\"\n\n    let inline private getClasses (xs:IReactProperty list) =\n        xs\n        |> List.choose (unbox<string * obj> >> function\n            | (k, v) when k = ClassName -> Some (string v)\n            | _ -> None)\n\n    let private extractClasses (xs:IReactProperty list) =\n        xs\n        |> List.rev\n        |> List.fold (fun (classes, props) x ->\n            match unbox<string * obj> x with\n            | (k, v) when k = ClassName -> string v :: classes, props\n            | _ -> classes, x :: props) ([], [])\n\n    let combineClasses cn (xs:IReactProperty list) =\n        xs\n        |> extractClasses\n        |> fun (classes, props) -> (cn :: classes |> prop.classes) :: props\n\n    module Elm =\n        let inline props buildFn (xs:IReactProperty list) (cn:string) = buildFn (combineClasses cn xs)\n\n[<RequireQualifiedAccess>]\nmodule highlight =\n    [<Erase>]\n    type language =\n        static member inline bash = prop.className \"bash\"\n        static member inline fsharp = prop.className \"fsharp\"\n        static member inline javascript = prop.className \"javascript\"\n        static member inline xml = prop.className \"xml\"\n\nlet reactHighlight (props : IReactProperty list) : ReactElement =\n    let propsObject = keyValueList CaseRules.LowerFirst props\n    ofImport \"default\" \"react-highlight\" propsObject []\n\nopen Feliz.DaisyUI\nopen Feliz.DaisyUI.Operators\n\n[<Erase>]\ntype Highlight =\n    static member inline highlight props =\n        Helpers.Elm.props reactHighlight props \"highlight\"\n        |> Daisy.mockupCode\n\ntype Html =\n    static member inline codeBlock (text: string) =\n        Html.code [ prop.className \"md-block\"; prop.text text ]\n    static member a (text: string) (href: string) =\n        Daisy.link [ link.accent; link.hover; prop.href href; prop.target \"_blank\"; prop.text text ]\n    static member p (text: string) =\n        Html.div [ prop.className \"description\"; prop.text text ]\n    static member p (children :seq<ReactElement>) =\n        Html.div [ prop.className \"description\"; prop.children children ]\n    static member h1 (text: string) =\n        Html.div [ color.textPrimary ++ prop.className \"text-3xl font-bold\"; prop.text text ]\n    static member h2 (text: string) =\n        Html.div [ color.textPrimary ++ prop.className \"text-3xl font-bold\"; prop.text text ]\n    static member h3 (text: string) =\n        Html.div [ color.textPrimary ++ prop.className \"text-2xl font-bold\"; prop.text text ]\n\n[<ReactComponent>]\nlet Spinner () =\n    Html.div [\n        color.textPrimary ++ prop.className \"fa-3x\"\n        prop.children [\n            Html.i [ prop.className \"fas fa-spinner fa-spin\" ]\n        ]\n    ]","[<RequireQualifiedAccess>]\nmodule Pages.Usage\n\nopen Fable.Core\nopen Fable.Auth0.React\nopen Feliz\nopen Feliz.DaisyUI\n\ntype Snippet =\n    static member auth0App = \"\"\"open Fable.Auth0.React\n\n// JS equivalent: <Auth0Provider/>\nlet auth0App (children: seq<ReactElement>): ReactElement =\n    let opts =\n        unbox<Auth0ProviderOptions>\n            {| domain = \"YOUR_AUTH0_DOMAIN\"\n               clientId = \"YOUR_AUTO0_CLIENT_ID\"\n               redirectUri = \"YOUR_REDIRECT_URI_AFTER_LOGGED_IN\" |}\n    Auth0Provider opts children\n\"\"\"\n    static member useAuth0 = \"\"\"open Fable.Core\nopen Feliz\n\n// Note that the `useAuth0` hook has to be used in a ReactComponent\n[<ReactComponent>]\nlet AuthenticationBox () =\n    let ctxAuth0 = useAuth0 ()\n\n    // correspond to authentication method `loginWithRedirect()` in JS\n    let handleLoginWithRedirect _ =\n        let opts = unbox<RedirectLoginOptions> null\n        ctxAuth0.loginWithRedirect opts\n        |> Async.AwaitPromise\n        |> Async.StartImmediate\n\n    // correspond to authentication method `logout({ returnTo: window.location.href })` in JS\n    let handleLogoutWithRedirect _ =\n        let returnTo = Browser.Dom.window.location.href\n        let opts = unbox<LogoutOptions> {| returnTo = returnTo |}\n        ctxAuth0.logout opts\n\n    let loginButton =\n        Html.button [\n            prop.onClick handleLoginWithRedirect\n            prop.text \"Login\"\n        ]\n\n    let logoutButton =\n        Html.button [\n            prop.onClick handleLogoutWithRedirect\n            prop.text \"Logout\"\n        ]\n\n    if not isAuthenticated then\n        // if not signed in, show login button\n        loginButton\n    else\n        // if signed in, show user profile and logout button\n        let userProfile =\n            let username, picture =\n                match ctxAuth0.user with\n                | Some (u: User) ->\n                    sprintf \"%A\" u.name,\n                    sprintf \"%A\" u.picture\n                | None -> \"\", \"\"\n            Html.div [\n                Html.p username\n                Html.img [ prop.src picture ]\n            ]\n\n        Html.div [\n            userProfile\n            logoutButton\n        ]\n\"\"\"\n\nopen Feliz.DaisyUI.Operators\nopen Shared\n\n[<ReactComponent>]\nlet View () =\n    Html.div [\n        Html.p [\n            Html.span \"Before adjusting your F# codebase, configure Auth0 for your React application following the tutorial \"\n            Html.a \"Auth0 React SDK Quickstarts\" \"https://auth0.com/docs/quickstart/spa/react\"\n            Html.span \".\"\n        ]\n        Html.p [\n            Html.span \"For a working example, see \"\n            Html.a \"https://github.com/chengh42/Fable.Auth0.React/tree/main/docs\"\n                \"https://github.com/chengh42/Fable.Auth0.React/tree/main/docs\"\n            Html.span \".\"\n        ]\n        Html.h3 \"Integrate Auth0 in F# application\"\n        Html.p [\n            Html.span \"Configure the SDK by wrapping your application in \"\n            Html.codeBlock \"Auth0Provider\"\n            Html.span \":\"\n        ]\n        Highlight.highlight [\n            highlight.language.fsharp\n            prop.text Snippet.auth0App\n        ]\n        Html.p [\n            Html.span \"Use the \"\n            Html.codeBlock \"useAuth0\"\n            Html.span \" hook in your components to access authentication state (\"\n            Html.codeBlock \"isLoading\"\n            Html.span \", \"\n            Html.codeBlock \"isAuthenticated\"\n            Html.span \" and \"\n            Html.codeBlock \"user\"\n            Html.span \") and authentication methods (\"\n            Html.codeBlock \"loginWithRedirect\"\n            Html.span \" and \"\n            Html.codeBlock \"logout\"\n            Html.span \"):\"\n        ]\n        Highlight.highlight [\n            highlight.language.fsharp\n            prop.text Snippet.useAuth0\n        ]\n    ]","module Pages.CallApi\n\ntype Snippet =\n    static member auth0App = \"\"\"open Fable.Auth0.React\n\n// JS equivalent: <Auth0Provider/>\nlet auth0App (children: seq<ReactElement>) =\n    let opts =\n        unbox<Auth0ProviderOptions>\n            {| domain = \"YOUR_AUTH0_DOMAIN\"\n               clientId = \"YOUR_AUTO0_CLIENT_ID\"\n               redirectUri = \"YOUR_REDIRECT_URI_AFTER_LOGGED_IN\"\n               audience = \"https://{YOUR_AUTH0_DOMAIN}/api/v2/\"\n               scope = \"read:current_user update:current_user_metadata\" |}\n    Auth0Provider opts children\n\"\"\"\n    static member auth0AppRefreshToken = \"\"\"open Fable.Auth0.React\n\n// JS equivalent: <Auth0Provider/>\nlet auth0App (children: seq<ReactElement>) =\n    let opts =\n        unbox<Auth0ProviderOptions>\n            {| domain = \"YOUR_AUTH0_DOMAIN\"\n               clientId = \"YOUR_AUTO0_CLIENT_ID\"\n               redirectUri = \"YOUR_REDIRECT_URI_AFTER_LOGGED_IN\"\n               audience = \"https://{YOUR_AUTH0_DOMAIN}/api/v2/\"\n               scope = \"read:current_user update:current_user_metadata\"\n               useRefreshTokens = true |}\n    Auth0Provider opts children\n\"\"\"\n    static member useAuth0 = \"\"\"open Fable.Core\nopen Fable.SimpleHttp\nopen Feliz\n\n// Note that the `useAuth0` hook has to be used in a ReactComponent\n[<ReactComponent>]\nlet ProfileBox () =\n    let ctxAuth0 = useAuth0 ()\n    let userMetadata, setUserMetadata = React.useState \"\"\n\n    React.useEffect (fun () ->\n        let opts =\n            unbox<GetTokenSilentlyOptions>\n                {| audience = \"https://{YOUR_AUTH0_DOMAIN}/api/v2/\"\n                   scope = \"read:current_user\" |}\n        try\n            async {\n                let! accessToken =\n                    ctxAuth0.getAccessTokenSilently.Invoke opts\n                    |> Async.AwaitPromise\n                let tokenHeader =\n                    \"Bearer \" + accessToken\n                let userDetailsByIdUrl =\n                    sprintf \"https://{YOUR_AUTH0_DOMAIN}/api/v2/users/%s\" sub\n                let! metadataResponse =\n                    Http.request userDetailsByIdUrl\n                    |> Http.method GET\n                    |> Http.content (BodyContent.Text \"{ }\")\n                    |> Http.header (Headers.authorization tokenHeader)\n                    |> Http.send\n\n                // update component state\n                setUserMetaData metadataResponse.responseText\n            }\n            |> Async.StartImmediate\n\n        with ex ->\n            // error handling\n            JS.console.log(ex.Message)\n    , [| |])\n\n    // ...\n\"\"\"\n\nopen Feliz\nopen Shared\n\n[<ReactComponent>]\nlet View () =\n    Html.div [\n        Html.p [\n            Html.span \"This tutorial demonstrates how to make API calls to the \"\n            Html.a \"Auth0 Management API\" \"https://auth0.com/docs/api#management-api\"\n            Html.span \", following the tutorial \"\n            Html.a \"Auth0 React SDK Quickstarts: Call an API\" \"https://auth0.com/docs/quickstart/spa/react/02-calling-an-api\"\n            Html.span \".\"\n        ]\n        Html.p [\n            Html.span \"First, set up the Auth0 service. To request an access token in a format that the API can verify, passing the \"\n            Html.code \"audience\"\n            Html.span \" and \"\n            Html.code \"scope\"\n            Html.span \" props to \"\n            Html.code \"Auth0Provider\"\n            Html.span \".\"\n        ]\n        Html.p [\n            Html.span \"In the case of the Auth0 Management API, we use the \"\n            Html.code \"read:current_user\"\n            Html.span \" and \"\n            Html.code \"update:current_user_metadata\"\n            Html.span \" scopes to get an access token that can retrieve user details and update the user's information.\"\n        ]\n        Highlight.highlight [\n            highlight.language.fsharp\n            prop.text Snippet.auth0App\n        ]\n        Html.p [\n            Html.span \"Once you configure Auth0Provider, you can easily get the access token using the \"\n            Html.code \"getAccessTokenSilently()\"\n            Html.span \" method from the \"\n            Html.code \"useAuth0()\"\n            Html.span \" custom React Hook wherever you need it.\"\n        ]\n        Highlight.highlight [\n            highlight.language.fsharp\n            prop.text Snippet.useAuth0\n        ]\n        Html.p [\n            Html.span \"The \"\n            Html.code \"getAccessTokenSilently()\"\n            Html.span \" method can renew the access and ID token for you using refresh tokens. To get a refresh token when a user logs in, pass \"\n            Html.code \"useRefreshTokens={true}\"\n            Html.span \" as a prop to \"\n            Html.code \"Auth0Provider\"\n            Html.span \":\"\n        ]\n        Highlight.highlight [\n            highlight.language.fsharp\n            prop.text Snippet.auth0AppRefreshToken\n        ]\n    ]","module Pages.Contribution\n\nopen Feliz\nopen Shared\n\ntype Snippet =\n    static member devCmd = \"\"\"# docs\ndotnet run # development\ndotnet run build # production\n\n# package\ndotnet run pack\n\"\"\"\n    static member xmlFsproj = \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <Version>{ Package version }</Version>\n    <PackageReleaseNotes>\n      { Release note }\n    </PackageReleaseNotes>\n    <!-- other properties -->\n  </PropertyGroup>\n  <!-- other items -->\n</Project>\n\"\"\"\n\n[<ReactComponent>]\nlet View () =\n    Html.div [\n        Html.p [\n            Html.span \"Contribution is welcomed! You can find the source code on \"\n            Html.a \"GitHub repository\" \"https://github.com/chengh42/Fable.Auth0.React\"\n            Html.span \".\"\n        ]\n        Html.p \"For development, run\"\n        Highlight.highlight [\n            highlight.language.bash\n            prop.text Snippet.devCmd\n        ]\n        Html.p \"The packed NuGet package can be found under the src/Fable.Auth0.React/bin/Release directory.\"\n        Html.p \"Don't forget to, before packing, update NuGet package metadata. To do so, edit in the .fsproj file,\"\n        Highlight.highlight [\n            highlight.language.xml\n            prop.text Snippet.xmlFsproj\n        ]\n        Html.p [\n            Html.span \"Feel free to put up a pull request! Or if you wish to (jointly) maintain the site and library, get in touch via GitHub \"\n            Html.span [ Html.i [ prop.className \"far fa-smile-wink\" ] ]\n        ]\n    ]","import {\r\n    useEffect as useEffectReact,\r\n    useLayoutEffect as useLayoutEffectReact,\r\n    useDebugValue as useDebugValueReact } from 'react'\r\n\r\nexport const useEffect = getDisposable => {\r\n    useEffectReact(() => {\r\n        const disposable = getDisposable()\r\n        return () => {\r\n            disposable.Dispose();\r\n        }\r\n    })\r\n}\r\n\r\nexport const useEffectWithDeps = (getDisposable, deps) => {\r\n    useEffectReact(() => {\r\n        const disposable = getDisposable()\r\n        return () => {\r\n            disposable.Dispose();\r\n        }\r\n    }, deps)\r\n}\r\n\r\nexport const useLayoutEffect = getDisposable => {\r\n    useLayoutEffectReact(() => {\r\n        const disposable = getDisposable()\r\n        return () => {\r\n            disposable.Dispose();\r\n        }\r\n    })\r\n}\r\n\r\nexport const useLayoutEffectWithDeps = (getDisposable, deps) => {\r\n    useLayoutEffectReact(() => {\r\n        const disposable = getDisposable()\r\n        return () => {\r\n            disposable.Dispose();\r\n        }\r\n    }, deps)\r\n}\r\n\r\nexport const useDebugValue = (value, formatter) => useDebugValueReact(value, formatter)","namespace Feliz\r\n\r\nopen System\r\nopen System.ComponentModel\r\nopen Fable.Core\r\nopen Fable.Core.JsInterop\r\nopen Browser.Types\r\n\r\nmodule internal ReactInterop =\r\n    let useDebugValueWithFormatter<'t>(value: 't, formatter: 't -> string) : unit = import \"useDebugValue\" \"./ReactInterop.js\"\r\n    let useEffect (effect: obj) : unit =  import \"useEffect\" \"./ReactInterop.js\"\r\n    let useEffectWithDeps (effect:  obj) (deps: obj) : unit = import \"useEffectWithDeps\" \"./ReactInterop.js\"\r\n    let useLayoutEffect (effect: obj) : unit =  import \"useLayoutEffect\" \"./ReactInterop.js\"\r\n    let useLayoutEffectWithDeps (effect:  obj) (deps: obj) : unit = import \"useLayoutEffectWithDeps\" \"./ReactInterop.js\"\r\n\r\n[<EditorBrowsable(EditorBrowsableState.Never);Erase>]\r\n[<RequireQualifiedAccess>]\r\nmodule Helpers =\r\n    let inline optDispose (disposeOption: #IDisposable option) =\r\n        { new IDisposable with member _.Dispose () = disposeOption |> Option.iter (fun d -> d.Dispose()) }\r\n\r\ntype internal Internal() =\r\n    static let propsWithKey (withKey: ('props -> string) option) props =\r\n        match withKey with\r\n        | Some f ->\r\n            props?key <- f props\r\n            props\r\n        | None -> props\r\n    static member\r\n        functionComponent\r\n        (\r\n            renderElement: 'props -> ReactElement,\r\n            ?name: string,\r\n            ?withKey: 'props -> string\r\n        )\r\n        : 'props -> Fable.React.ReactElement =\r\n            name |> Option.iter (fun name -> renderElement?displayName <- name)\r\n            #if FABLE_COMPILER_3\r\n            Browser.Dom.console.warn(\"Feliz: using React.functionComponent in Fable 3 is obsolete, please consider using the [<ReactComponent>] attribute instead which makes Feliz output better Javascript code that is compatible with react-refresh\")\r\n            #endif\r\n            fun props ->\r\n                let props = props |> propsWithKey withKey\r\n                Interop.reactApi.createElement(renderElement, props)\r\n    static member\r\n        memo\r\n        (\r\n            renderElement: 'props -> ReactElement,\r\n            ?name: string,\r\n            ?areEqual: 'props -> 'props -> bool,\r\n            ?withKey: 'props -> string\r\n        )\r\n        : 'props -> Fable.React.ReactElement =\r\n            let memoElementType = Interop.reactApi.memo(renderElement, (defaultArg areEqual (unbox null)))\r\n            name |> Option.iter (fun name -> renderElement?displayName <- name)\r\n            fun props ->\r\n                let props = props |> propsWithKey withKey\r\n                Interop.reactApi.createElement(memoElementType, props)\r\n\r\ntype React =\r\n    /// Creates a disposable instance by providing the implementation of the dispose member.\r\n    static member createDisposable(dispose: unit -> unit) =\r\n        { new IDisposable with member _.Dispose() = dispose() }\r\n\r\n    /// The `React.fragment` component lets you return multiple elements in your `render()` method without creating an additional DOM element.\r\n    static member inline fragment xs = Fable.React.Helpers.fragment [] xs\r\n\r\n    /// The `React.fragment` component lets you return multiple elements in your `render()` method without creating an additional DOM element.\r\n    static member inline keyedFragment(key: int, xs) = Fable.React.Helpers.fragment [ !!(\"key\", key) ] xs\r\n    /// The `React.fragment` component lets you return multiple elements in your `render()` method without creating an additional DOM element.\r\n    static member inline keyedFragment(key: string, xs) = Fable.React.Helpers.fragment [ !!(\"key\", key) ] xs\r\n    /// The `React.fragment` component lets you return multiple elements in your `render()` method without creating an additional DOM element.\r\n    static member inline keyedFragment(key: System.Guid, xs) = Fable.React.Helpers.fragment [ !!(\"key\", string key) ] xs\r\n    /// Placeholder empty React element to be used when importing external React components with the [<ReactComponent>] attribute.\r\n    static member inline imported() = Html.none\r\n    /// The `useState` hook that creates a state variable for React function components from an initialization function.\r\n    [<Hook>]\r\n    static member useState<'t>(initializer: unit -> 't) = Interop.reactApi.useState<unit -> 't,'t>(initializer)\r\n\r\n    /// Accepts a reducer and returns the current state paired with a dispatch.\r\n    [<Hook>]\r\n    static member useReducer(update, initialState) = Interop.reactApi.useReducer update initialState\r\n\r\n    /// The `useEffect` hook that creates a disposable effect for React function components.\r\n    /// This effect has no dependencies which means the effect is re-executed on every re-render.\r\n    /// To make the effect run once (for example you subscribe once to web sockets) then provide an empty array\r\n    /// for the dependencies: `React.useEffect(disposableEffect, [| |])`.\r\n    [<Hook>]\r\n    static member useEffect(effect: unit -> #IDisposable) : unit = ReactInterop.useEffect(effect)\r\n    /// The `useEffect` hook that creates a disposable effect for React function components.\r\n    /// This effect has no dependencies which means the effect is re-executed on every re-render.\r\n    /// To make the effect run once (for example you subscribe once to web sockets) then provide an empty array\r\n    /// for the dependencies: `React.useEffect(disposableEffect, [| |])`.\r\n    [<Hook>]\r\n    static member inline useEffect(effect: unit -> #IDisposable option) = React.useEffect(effect >> Helpers.optDispose)\r\n    /// The `useEffect` hook that creates a disposable effect for React function components.\r\n    /// This effect takes an array of *dependencies*.\r\n    /// Whenever any of these dependencies change, the effect is re-executed. To execute the effect only once,\r\n    /// you have to explicitly provide an empty array for the dependencies: `React.useEffect(effect, [| |])`.\r\n    [<Hook>]\r\n    static member useEffect(effect: unit -> #IDisposable, dependencies: obj []) : unit = ReactInterop.useEffectWithDeps effect dependencies\r\n    /// The `useEffect` hook that creates a disposable effect for React function components.\r\n    /// This effect takes an array of *dependencies*.\r\n    /// Whenever any of these dependencies change, the effect is re-executed. To execute the effect only once,\r\n    /// you have to explicitly provide an empty array for the dependencies: `React.useEffect(effect, [| |])`.\r\n    [<Hook>]\r\n    static member inline useEffect(effect: unit -> #IDisposable option, dependencies: obj []) = React.useEffect(effect >> Helpers.optDispose, dependencies)\r\n\r\n    /// The `useLayoutEffect` hook that creates a disposable effect for React function components.\r\n    /// This effect has no dependencies which means the effect is re-executed on every re-render.\r\n    /// To make the effect run once (for example you subscribe once to web sockets) then provide an empty array\r\n    /// for the dependencies: `React.useLayoutEffect(disposableEffect, [| |])`.\r\n    /// The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.\r\n    [<Hook>]\r\n    static member useLayoutEffect(effect: unit -> #IDisposable) : unit = ReactInterop.useLayoutEffect(effect)\r\n    /// The `useLayoutEffect` hook that creates a disposable effect for React function components.\r\n    /// This effect has no dependencies which means the effect is re-executed on every re-render.\r\n    /// To make the effect run once (for example you subscribe once to web sockets) then provide an empty array\r\n    /// for the dependencies: `React.useLayoutEffect(disposableEffect, [| |])`.\r\n    /// The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.\r\n    [<Hook>]\r\n    static member inline useLayoutEffect(effect: unit -> #IDisposable option) = React.useLayoutEffect(effect >> Helpers.optDispose)\r\n    /// The `useLayoutEffect` hook that creates a disposable effect for React function components.\r\n    /// This effect takes an array of *dependencies*.\r\n    /// Whenever any of these dependencies change, the effect is re-executed. To execute the effect only once,\r\n    /// you have to explicitly provide an empty array for the dependencies: `React.useLayoutEffect(effect, [| |])`.\r\n    /// The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.\r\n    [<Hook>]\r\n    static member useLayoutEffect(effect: unit -> #IDisposable, dependencies: obj []) : unit = ReactInterop.useLayoutEffectWithDeps effect dependencies\r\n    /// The `useLayoutEffect` hook that creates a disposable effect for React function components.\r\n    /// This effect takes an array of *dependencies*.\r\n    /// Whenever any of these dependencies change, the effect is re-executed. To execute the effect only once,\r\n    /// you have to explicitly provide an empty array for the dependencies: `React.useLayoutEffect(effect, [| |])`.\r\n    /// The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.\r\n    [<Hook>]\r\n    static member inline useLayoutEffect(effect: unit -> #IDisposable option, dependencies: obj []) =\r\n        React.useLayoutEffect(effect >> Helpers.optDispose, dependencies)\r\n    /// The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.\r\n    /// This effect is executed on every (re)render\r\n    [<Hook>]\r\n    static member useLayoutEffect(effect: unit -> unit) =\r\n        ReactInterop.useLayoutEffect\r\n            (fun _ ->\r\n                effect()\r\n                React.createDisposable(ignore))\r\n\r\n    /// The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.\r\n    [<Hook>]\r\n    static member useLayoutEffect(effect: unit -> unit, dependencies: obj []) =\r\n        ReactInterop.useLayoutEffectWithDeps\r\n            (fun _ ->\r\n                effect()\r\n                React.createDisposable(ignore))\r\n            dependencies\r\n\r\n    [<Hook>]\r\n    static member inline useLayoutEffectOnce(effect: unit -> unit) =\r\n         React.useLayoutEffect(effect, [| |])\r\n\r\n    [<Hook>]\r\n    static member inline useLayoutEffectOnce(effect: unit -> #IDisposable) =\r\n        React.useLayoutEffect(effect, [| |])\r\n\r\n    [<Hook>]\r\n    static member inline useLayoutEffectOnce(effect: unit -> #IDisposable option) =\r\n        React.useLayoutEffect(effect, [| |])\r\n\r\n    /// React hook to define and use an effect only once when a function component renders for the first time.\r\n    /// This is an alias for `React.useEffect(effect, [| |])` which explicitly provides an empty array for the dependencies of the effect which means the effect will only run once.\r\n    [<Hook>]\r\n    static member useEffectOnce(effect: unit -> unit) =\r\n        React.useEffect(effect, [| |])\r\n\r\n    /// React hook to define and use a disposable effect only once when a function component renders for the first time.\r\n    /// This is an alias for `React.useEffect(effect, [| |])` which explicitly provides an empty array for the dependencies of the effect which means the effect will only run once.\r\n    [<Hook>]\r\n    static member useEffectOnce(effect: unit -> #IDisposable) =\r\n        React.useEffect(effect, [| |])\r\n    /// React hook to define and use a disposable effect only once when a function component renders for the first time.\r\n    /// This is an alias for `React.useEffect(effect, [| |])` which explicitly provide an empty array for the dependencies of the effect which means the effect will only run once.\r\n    [<Hook>]\r\n    static member useEffectOnce(effect: unit -> #IDisposable option) =\r\n        React.useEffect(effect >> Helpers.optDispose, [| |])\r\n\r\n    /// The `useEffect` hook that creates an effect for React function components.\r\n    /// This effect is executed *every time* the function component re-renders.\r\n    ///\r\n    /// To make the effect run only once, write: `React.useEffect(effect, [| |])` which explicitly states\r\n    /// that this effect has no dependencies and should only run once on initial render.\r\n    [<Hook>]\r\n    static member useEffect(effect: unit -> unit) : unit =\r\n        ReactInterop.useEffect\r\n            (fun _ ->\r\n                effect()\r\n                React.createDisposable(ignore))\r\n\r\n    /// The `useEffect` hook that creates an effect for React function components. This effect takes an array of *dependencies*.\r\n    /// Whenever any of these dependencies change, the effect is re-executed. To execute the effect only once,\r\n    /// you have to explicitly provide an empty array for the dependencies: `React.useEffect(effect, [| |])`.\r\n    [<Hook>]\r\n    static member useEffect(effect: unit -> unit, dependencies: obj []) : unit =\r\n        ReactInterop.useEffectWithDeps\r\n            (fun _ ->\r\n                effect()\r\n                React.createDisposable(ignore))\r\n            dependencies\r\n\r\n    /// Can be used to display a label for custom hooks in React DevTools.\r\n    [<Hook>]\r\n    static member useDebugValue(value: string) =\r\n        ReactInterop.useDebugValueWithFormatter(value, id)\r\n\r\n    /// Can be used to display a label for custom hooks in React DevTools.\r\n    [<Hook>]\r\n    static member useDebugValue(value: 't, formatter: 't -> string) =\r\n        ReactInterop.useDebugValueWithFormatter(value, formatter)\r\n\r\n    /// <summary>\r\n    /// The `useCallback` hook. Returns a memoized callback. Pass an inline callback and an array of dependencies.\r\n    /// `useCallback` will return a memoized version of the callback that only changes if one of the dependencies has changed.\r\n    /// </summary>\r\n    /// <param name='callbackFunction'>A callback function to be memoized.</param>\r\n    /// <param name='dependencies'>An array of dependencies upon which the callback function depends.\r\n    /// If not provided, defaults to empty array, representing dependencies that never change.</param>\r\n    [<Hook>]\r\n    static member useCallback(callbackFunction: 'a -> 'b, ?dependencies: obj array) =\r\n        Interop.reactApi.useCallback callbackFunction (defaultArg dependencies [||])\r\n\r\n    /// Returns a mutable ref object whose .current property is initialized to the passed argument (initialValue). The returned object will persist for the full lifetime of the component.\r\n    ///\r\n    /// Essentially, useRef is like a container that can hold a mutable value in its .current property.\r\n    [<Hook>]\r\n    static member useRef(initialValue) = Interop.reactApi.useRef(initialValue)\r\n\r\n    /// A specialized version of React.useRef() that creates a reference to an input element.\r\n    ///\r\n    /// Useful for controlling the internal properties and methods of that element, for example to enable focus().\r\n    [<Hook>]\r\n    static member useInputRef() : IRefValue<HTMLInputElement option> = React.useRef(None)\r\n\r\n    /// A specialized version of React.useRef() that creates a reference to a button element.\r\n    [<Hook>]\r\n    static member useButtonRef() : IRefValue<HTMLButtonElement option> = React.useRef(None)\r\n\r\n    /// A specialized version of React.useRef() that creates a reference to a generic HTML element.\r\n    ///\r\n    /// Useful for controlling the internal properties and methods of that element, for integration with third-party libraries that require a Html element.\r\n    [<Hook>]\r\n    static member useElementRef() : IRefValue<HTMLElement option> = React.useRef(None)\r\n\r\n    /// <summary>\r\n    /// The `useMemo` hook. Returns a memoized value. Pass a \"create\" function and an array of dependencies.\r\n    /// `useMemo` will only recompute the memoized value when one of the dependencies has changed.\r\n    /// </summary>\r\n    /// <param name='createFunction'>A create function returning a value to be memoized.</param>\r\n    /// <param name='dependencies'>An array of dependencies upon which the create function depends.\r\n    /// If not provided, defaults to empty array, representing dependencies that never change.</param>\r\n    [<Hook>]\r\n    static member useMemo(createFunction: unit -> 'a, ?dependencies: obj array) =\r\n        Interop.reactApi.useMemo createFunction (defaultArg dependencies [||])\r\n\r\n    //\r\n    // React.functionComponent\r\n    //\r\n\r\n    /// <summary>\r\n    /// Creates a React function component from a function that accepts a \"props\" object and renders a result.\r\n    /// A component key can be provided in the props object, or a custom `withKey` function can be provided.\r\n    /// </summary>\r\n    /// <param name='render'>A render function that returns an element.</param>\r\n    /// <param name='withKey'>A function to derive a component key from the props.</param>\r\n    static member functionComponent(render: 'props -> ReactElement, ?withKey: 'props -> string) =\r\n        Internal.functionComponent(render, ?withKey=withKey)\r\n\r\n    /// <summary>\r\n    /// Creates a React function component from a function that accepts a \"props\" object and renders a result.\r\n    /// A component key can be provided in the props object, or a custom `withKey` function can be provided.\r\n    /// </summary>\r\n    /// <param name='name'>The component name to display in the React dev tools.</param>\r\n    /// <param name='render'>A render function that returns an element.</param>\r\n    /// <param name='withKey'>A function to derive a component key from the props.</param>\r\n    static member functionComponent(name: string, render: 'props -> ReactElement, ?withKey: 'props -> string) =\r\n        Internal.functionComponent(render, name, ?withKey=withKey)\r\n\r\n    /// <summary>\r\n    /// Creates a React function component from a function that accepts a \"props\" object and renders a result.\r\n    /// A component key can be provided in the props object, or a custom `withKey` function can be provided.\r\n    /// </summary>\r\n    /// <param name='render'>A render function that returns a list of elements.</param>\r\n    /// <param name='withKey'>A function to derive a component key from the props.</param>\r\n    static member functionComponent(render: 'props -> #seq<ReactElement>, ?withKey: 'props -> string) =\r\n        Internal.functionComponent(render >> React.fragment, ?withKey=withKey)\r\n\r\n    /// <summary>\r\n    /// Creates a React function component from a function that accepts a \"props\" object and renders a result.\r\n    /// A component key can be provided in the props object, or a custom `withKey` function can be provided.\r\n    /// </summary>\r\n    /// <param name='render'>A render function that returns a list of elements.</param>\r\n    /// <param name='name'>The component name to display in the React dev tools.</param>\r\n    /// <param name='withKey'>A function to derive a component key from the props.</param>\r\n    static member functionComponent(name: string, render: 'props -> #seq<ReactElement>, ?withKey: 'props -> string) =\r\n        Internal.functionComponent(render >> React.fragment, name, ?withKey=withKey)\r\n\r\n    //\r\n    // React.memo\r\n    //\r\n\r\n    /// <summary>\r\n    /// `React.memo` memoizes the result of a function component. Given the same props, React will skip rendering the component, and reuse the last rendered result.\r\n    /// By default it will only shallowly compare complex objects in the props object. For more control, a custom `areEqual` function can be provided.\r\n    /// A component key can be provided in the props object, or a custom `withKey` function can be provided.\r\n    /// </summary>\r\n    /// <param name='render'>A render function or a React.functionComponent.</param>\r\n    /// <param name='areEqual'>A custom comparison function to use instead of React's default shallow compare.</param>\r\n    /// <param name='withKey'>A function to derive a component key from the props.</param>\r\n    static member memo(render: 'props -> ReactElement, ?withKey: 'props -> string, ?areEqual: 'props -> 'props -> bool) =\r\n        Internal.memo(render, ?areEqual=areEqual, ?withKey=withKey)\r\n\r\n    /// <summary>\r\n    /// `React.memo` memoizes the result of a function component. Given the same props, React will skip rendering the component, and reuse the last rendered result.\r\n    /// By default it will only shallowly compare complex objects in the props object. For more control, a custom `areEqual` function can be provided.\r\n    /// A component key can be provided in the props object, or a custom `withKey` function can be provided.\r\n    /// </summary>\r\n    /// <param name='name'>The component name to display in the React dev tools.</param>\r\n    /// <param name='render'>A render function or a React.functionComponent.</param>\r\n    /// <param name='areEqual'>A custom comparison function to use instead of React's default shallow compare.</param>\r\n    /// <param name='withKey'>A function to derive a component key from the props.</param>\r\n    static member memo(name: string, render: 'props -> ReactElement, ?withKey: 'props -> string, ?areEqual: 'props -> 'props -> bool) =\r\n        Internal.memo(render, name, ?areEqual=areEqual, ?withKey=withKey)\r\n\r\n    /// <summary>\r\n    /// `React.memo` memoizes the result of a function component. Given the same props, React will skip rendering the component, and reuse the last rendered result.\r\n    /// By default it will only shallowly compare complex objects in the props object. For more control, a custom `areEqual` function can be provided.\r\n    /// A component key can be provided in the props object, or a custom `withKey` function can be provided.\r\n    /// </summary>\r\n    /// <param name='render'>A render function that returns a list of elements.</param>\r\n    /// <param name='withKey'>A function to derive a component key from the props.</param>\r\n    /// <param name='areEqual'>A custom comparison function to use instead of React's default shallow compare.</param>\r\n    static member memo(render: 'props -> #seq<ReactElement>, ?withKey: 'props -> string, ?areEqual: 'props -> 'props -> bool) =\r\n        Internal.memo(render >> React.fragment, ?areEqual=areEqual, ?withKey=withKey)\r\n\r\n    /// <summary>\r\n    /// `React.memo` memoizes the result of a function component. Given the same props, React will skip rendering the component, and reuse the last rendered result.\r\n    /// By default it will only shallowly compare complex objects in the props object. For more control, a custom `areEqual` function can be provided.\r\n    /// A component key can be provided in the props object, or a custom `withKey` function can be provided.\r\n    /// </summary>\r\n    /// <param name='name'>The component name to display in the React dev tools.</param>\r\n    /// <param name='render'>A render function that returns a list of elements.</param>\r\n    /// <param name='withKey'>A function to derive a component key from the props.</param>\r\n    /// <param name='areEqual'>A custom comparison function to use instead of React's default shallow compare.</param>\r\n    static member memo(name: string, render: 'props -> #seq<ReactElement>, ?withKey: 'props -> string, ?areEqual: 'props -> 'props -> bool) =\r\n        Internal.memo(render >> React.fragment, name, ?areEqual=areEqual, ?withKey=withKey)\r\n\r\n    //\r\n    // React.useContext\r\n    //\r\n\r\n    /// <summary>\r\n    /// Creates a Context object. When React renders a component that subscribes to this Context object\r\n    /// it will read the current context value from the closest matching Provider above it in the tree.\r\n    /// </summary>\r\n    /// <param name='name'>The component name to display in the React dev tools.</param>\r\n    /// <param name='defaultValue'>A default value that is only used when a component does not have a matching Provider above it in the tree.</param>\r\n    static member createContext<'a>(?name: string, ?defaultValue: 'a) =\r\n        let contextObject = Interop.reactApi.createContext (defaultArg defaultValue Fable.Core.JS.undefined<'a>)\r\n        name |> Option.iter (fun name -> contextObject?displayName <- name)\r\n        contextObject\r\n\r\n    /// <summary>\r\n    /// A Provider component that allows consuming components to subscribe to context changes.\r\n    /// </summary>\r\n    /// <param name='contextObject'>A context object returned from a previous React.createContext call.</param>\r\n    /// <param name='contextValue'>The context value to be provided to descendant components.</param>\r\n    /// <param name='child'>A child element.</param>\r\n    static member contextProvider(contextObject: Fable.React.IContext<'a>, contextValue: 'a, child: ReactElement) : ReactElement =\r\n        Interop.reactApi.createElement(contextObject?Provider, createObj [\"value\" ==> contextValue], [child])\r\n    /// <summary>\r\n    /// A Provider component that allows consuming components to subscribe to context changes.\r\n    /// </summary>\r\n    /// <param name='contextObject'>A context object returned from a previous React.createContext call.</param>\r\n    /// <param name='contextValue'>The context value to be provided to descendant components.</param>\r\n    /// <param name='children'>A sequence of child elements.</param>\r\n    static member contextProvider(contextObject: Fable.React.IContext<'a>, contextValue: 'a, children: #seq<ReactElement>) : ReactElement =\r\n        Interop.reactApi.createElement(contextObject?Provider, createObj [\"value\" ==> contextValue], children)\r\n\r\n    /// <summary>\r\n    /// A Consumer component that subscribes to context changes.\r\n    /// </summary>\r\n    /// <param name='contextObject'>A context object returned from a previous React.createContext call.</param>\r\n    /// <param name='render'>A render function that returns an element.</param>\r\n    static member contextConsumer(contextObject: Fable.React.IContext<'a>, render: 'a -> ReactElement) : ReactElement =\r\n        Interop.reactApi.createElement(contextObject?Consumer, null, [!!render])\r\n    /// <summary>\r\n    /// A Consumer component that subscribes to context changes.\r\n    /// </summary>\r\n    /// <param name='contextObject'>A context object returned from a previous React.createContext call.</param>\r\n    /// <param name='render'>A render function that returns a sequence of elements.</param>\r\n    static member contextConsumer(contextObject: Fable.React.IContext<'a>, render: 'a -> #seq<ReactElement>) : ReactElement =\r\n        Interop.reactApi.createElement(contextObject?Consumer, null, [!!(render >> React.fragment)])\r\n\r\n    /// <summary>\r\n    /// The `useContext` hook. Accepts a context object (the value returned from React.createContext) and returns the current context value for that context.\r\n    /// The current context value is determined by the value prop of the nearest Provider component above the calling component in the tree.\r\n    /// </summary>\r\n    /// <param name='contextObject'>A context object returned from a previous React.createContext call.</param>\r\n    [<Hook>]\r\n    static member useContext(contextObject: Fable.React.IContext<'a>) = Interop.reactApi.useContext contextObject\r\n\r\n    /// <summary>\r\n    /// Creates a callback that keeps the same reference during the entire lifecycle of the component while having access to\r\n    /// the current value of the dependencies on every call.\r\n    ///\r\n    /// This hook should only be used for (like a dispatch) functions that are not used to provide information during render.\r\n    ///\r\n    /// This is not a complete replacement for the `useCallback` hook. It returns a callback that does not need explicit\r\n    /// dependency declarations and never causes a re-render.\r\n    /// </summary>\r\n    /// <param name='callback'>The function call.</param>\r\n    [<Hook>]\r\n    static member useCallbackRef(callback: ('a -> 'b)) =\r\n        let lastRenderCallbackRef = React.useRef(callback)\r\n\r\n        let callbackRef =\r\n            React.useCallback((fun (arg: 'a) ->\r\n                lastRenderCallbackRef.current(arg)\r\n            ), [||])\r\n\r\n        React.useLayoutEffect(fun () ->\r\n            // render is commited - it's safe to update the callback\r\n            lastRenderCallbackRef.current <- callback\r\n        )\r\n\r\n        callbackRef\r\n\r\n    /// <summary>\r\n    /// Just like React.useState except that the updater function uses the previous state of the state variable as input and allows you to compute the next value using it.\r\n    /// This is useful in cases where defining helpers functions inside the definition of a React function component would actually cache the initial value (because they become closures) during first render as opposed to using the current value after multiple render cycles.\r\n    ///\r\n    /// Use this instead of React.useState when your state variable is a list, an array, a dictionary, a map or other complex structures.\r\n    /// </summary>\r\n    static member useStateWithUpdater (initial: 't) : ('t * (('t -> 't) -> unit)) = import \"useState\" \"react\"\r\n\r\n    /// <summary>\r\n    /// Forwards a given ref, allowing you to pass it further down to a child.\r\n    /// </summary>\r\n    /// <param name='render'>A render function that returns an element.</param>\r\n    static member forwardRef(render: ('props * IRefValue<'t> -> ReactElement)) : ('props * IRefValue<'t> -> ReactElement) =\r\n        let forwardRefType = Interop.reactApi.forwardRef(Func<'props,IRefValue<'t>,ReactElement> (fun props ref -> render(props,ref)))\r\n        fun (props, ref) ->\r\n            let propsObj = props |> JsInterop.toPlainJsObj\r\n            propsObj?ref <- ref\r\n            Interop.reactApi.createElement(forwardRefType, propsObj)\r\n\r\n    /// <summary>\r\n    /// Forwards a given ref, allowing you to pass it further down to a child.\r\n    /// </summary>\r\n    /// <param name='name'>The component name to display in the React dev tools.</param>\r\n    /// <param name='render'>A render function that returns an element.</param>\r\n    static member forwardRef(name: string, render: ('props * IRefValue<'t> -> ReactElement)) : ('props * IRefValue<'t> -> ReactElement) =\r\n        let forwardRefType = Interop.reactApi.forwardRef(Func<'props,IRefValue<'t>,ReactElement> (fun props ref -> render(props,ref)))\r\n        render?displayName <- name\r\n        fun (props, ref) ->\r\n            let propsObj = props |> JsInterop.toPlainJsObj\r\n            propsObj?ref <- ref\r\n            Interop.reactApi.createElement(forwardRefType, propsObj)\r\n\r\n    /// <summary>\r\n    /// Highlights potential problems in an application by enabling additional checks\r\n    /// and warnings for descendants. As well as double rendering function components.\r\n    ///\r\n    /// This *does not do anything* in production mode. You do not need to hide it\r\n    /// with compiler directives.\r\n    /// </summary>\r\n    /// <param name='children'>The elements that will be rendered with additional\r\n    /// checks and warnings.</param>\r\n    static member strictMode(children: ReactElement list) =\r\n        Interop.reactApi.createElement(Interop.reactApi.StrictMode, None, children)\r\n\r\n    /// <summary>\r\n    /// Lets you define a component that is loaded dynamically. Which helps with code splitting.\r\n    /// </summary>\r\n    /// <param name='dynamicImport'>\r\n    ///  The dynamicImport of the component.\r\n    ///\r\n    ///  Such as `let asyncComponent : JS.Promise[unit -> ReactElement] = JsInterop.importDynamic \"./CodeSplitting.fs\"`.\r\n    ///\r\n    ///  Where you would then pass in `asyncComponent`.\r\n    /// </param>\r\n    /// <param name=\"props\">The props to be passed to the component.</param>\r\n    static member lazy'<'t,'props>(dynamicImport: JS.Promise<'t>, props: 'props) =\r\n        Interop.reactApi.createElement(Interop.reactApi.lazy'(fun () -> dynamicImport),props)\r\n    /// <summary>\r\n    /// Lets you define a component that is loaded dynamically. Which helps with code\r\n    /// splitting.\r\n    /// </summary>\r\n    /// <param name='dynamicImport'>\r\n    /// The dynamicImport of the component.\r\n    ///\r\n    /// Such as `let asyncComponent : JS.Promise[unit -> ReactElement] = JsInterop.importDynamic \"./CodeSplitting.fs\"`.\r\n    ///\r\n    /// Where you would then pass in `fun () -> asyncComponent`.\r\n    /// </param>\r\n    /// <param name=\"props\">The props to be passed to the component.</param>\r\n    static member lazy'<'t,'props>(dynamicImport: unit -> JS.Promise<'t>, props: 'props) =\r\n        Interop.reactApi.createElement(Interop.reactApi.lazy'(dynamicImport),props)\r\n\r\n    /// <summary>\r\n    /// Lets you specify a loading indicator whenever a child element is not yet ready\r\n    /// to render.\r\n    ///\r\n    /// Currently this is only usable with `React.lazy'`.\r\n    /// </summary>\r\n    /// <param name='children'>The elements that will be rendered within the suspense block.</param>\r\n    static member suspense(children: ReactElement list) =\r\n        Interop.reactApi.createElement(Interop.reactApi.Suspense, {| fallback = Html.none |} |> JsInterop.toPlainJsObj, children)\r\n    /// <summary>\r\n    /// Lets you specify a loading indicator whenever a child element is not yet ready\r\n    /// to render.\r\n    ///\r\n    /// Currently this is only usable with `React.lazy'`.\r\n    /// </summary>\r\n    /// <param name='children'>The elements that will be rendered within the suspense block.</param>\r\n    /// <param name='fallback'>The element that will be rendered while the children are loading.</param>\r\n    static member suspense(children: ReactElement list, fallback: ReactElement) =\r\n        Interop.reactApi.createElement(Interop.reactApi.Suspense, {| fallback = fallback |} |> JsInterop.toPlainJsObj, children)\r\n\r\n    /// <summary>\r\n    /// Allows you to override the behavior of a given ref.\r\n    ///\r\n    /// </summary>\r\n    /// <param name='ref'>The ref you want to override.</param>\r\n    /// <param name='createHandle'>A function that returns a new ref with changed behavior.</param>\r\n    [<Hook>]\r\n    static member useImperativeHandle(ref: IRefValue<'t>, createHandle: unit -> 't) =\r\n        Interop.reactApi.useImperativeHandleNoDeps ref createHandle\r\n\r\n    /// <summary>\r\n    /// Lets you specify a loading indicator whenever a child element is not yet ready\r\n    /// to render.\r\n    ///\r\n    /// Currently this is only usable with `React.lazy'`.\r\n    /// </summary>\r\n    /// <param name='ref'>The ref you want to override.</param>\r\n    /// <param name='createHandle'>A function that returns a new ref with changed behavior.</param>\r\n    /// <param name='dependencies'>An array of dependencies upon which the imperative handle function depends.</param>\r\n    [<Hook>]\r\n    static member useImperativeHandle(ref: IRefValue<'t>, createHandle: unit -> 't, dependencies: obj []) =\r\n        Interop.reactApi.useImperativeHandle ref createHandle dependencies\r\n\r\n    /// <summary>\r\n    /// Creates a CancellationToken that is cancelled when a component is unmounted.\r\n    /// </summary>\r\n    [<Hook>]\r\n    static member inline useCancellationToken () =\r\n        let cts = React.useRef(new System.Threading.CancellationTokenSource())\r\n        let token = React.useRef(cts.current.Token)\r\n\r\n        React.useEffectOnce(fun () ->\r\n            React.createDisposable(fun () ->\r\n                cts.current.Cancel()\r\n                cts.current.Dispose()\r\n            )\r\n        )\r\n\r\n        token\r\n\r\n[<AutoOpen>]\r\nmodule ReactOverloadMagic =\r\n    type React with\r\n        /// Creates a disposable instance by merging multiple IDisposables.\r\n        static member inline createDisposable([<ParamArray>] disposables: #IDisposable []) =\r\n            React.createDisposable(fun () ->\r\n                disposables\r\n                |> Array.iter (fun d -> d.Dispose())\r\n            )\r\n        /// Creates a disposable instance by merging multiple IDisposable options.\r\n        static member inline createDisposable([<ParamArray>] disposables: #IDisposable option []) =\r\n            React.createDisposable(fun () ->\r\n                disposables\r\n                |> Array.iter (Option.iter (fun d -> d.Dispose()))\r\n            )\r\n        /// Creates a disposable instance by merging multiple IDisposable refs.\r\n        static member inline createDisposable([<ParamArray>] disposables: IRefValue<#IDisposable> []) =\r\n            React.createDisposable(fun () ->\r\n                disposables\r\n                |> Array.iter (fun d -> d.current.Dispose())\r\n            )\r\n\r\n        /// Creates a disposable instance by merging multiple IDisposable refs.\r\n        static member inline createDisposable([<ParamArray>] disposables: IRefValue<#IDisposable option> []) =\r\n            React.createDisposable(fun () ->\r\n                disposables\r\n                |> Array.iter (fun d -> d.current |> Option.iter (fun d -> d.Dispose()))\r\n            )\r\n\r\n        /// The `useState` hook that creates a state variable for React function components.\r\n        [<Hook>]\r\n        static member useState<'t>(initial: 't) = Interop.reactApi.useState<'t,'t>(initial)\r\n\r\n\r\n        [<Hook>]\r\n        static member useStateWithUpdater<'t>(initializer: unit -> 't): ('t * (('t -> 't) -> unit)) = import \"useState\" \"react\"\r\n","namespace Feliz.UseListener\n\nopen Browser.Types\nopen Browser.Dom\nopen Fable.Core\nopen Fable.Core.JsInterop\nopen Feliz\nopen System.ComponentModel\n\n[<EditorBrowsable(EditorBrowsableState.Never)>]\nmodule Impl =\n    [<Emit(\"typeof window !== 'undefined'\")>]\n    let isWindowDefined () : bool = jsNative\n\n    [<Emit(\"typeof window.addEventListener === 'function'\")>]\n    let isWindowListenerFunction () : bool = jsNative\n\n    [<Emit(\"Object.defineProperty({}, 'passive', {get () { $0() }})\")>]\n    let definePassive (updater: unit -> unit) : JS.PropertyDescriptor = jsNative\n\n    let allowsPassiveEvents =\n        let mutable passive = false\n\n        try\n            if isWindowDefined() && isWindowListenerFunction() then\n                let options = \n                    jsOptions<AddEventListenerOptions>(fun o ->\n                        o.passive <- true\n                    )\n                \n                window.addEventListener(\"testPassiveEventSupport\", ignore, options)\n                window.removeEventListener(\"testPassiveEventSupport\", ignore)\n        with _ -> ()\n\n        passive\n\n    let defaultPassive = jsOptions<AddEventListenerOptions>(fun o -> o.passive <- true)\n\n    let adjustPassive (maybeOptions: AddEventListenerOptions option) =\n        maybeOptions\n        |> Option.map (fun options ->\n            if options.passive && not allowsPassiveEvents then\n                jsOptions<AddEventListenerOptions>(fun o ->\n                    o.capture <- options.capture\n                    o.once <- options.once\n                    o.passive <- false\n                )\n            else options)\n\n    let createRemoveOptions (maybeOptions: AddEventListenerOptions option) =\n        maybeOptions\n        |> Option.bind (fun options ->\n            if options.capture then \n                Some (jsOptions<RemoveEventListenerOptions>(fun o -> o.capture <- true))\n            else None)\n\n[<Erase;RequireQualifiedAccess>]\nmodule React =\n    [<Erase>]\n    type useListener =\n        static member inline on (eventType: string, action: #Event -> unit, ?options: AddEventListenerOptions) =\n            let addOptions = React.useMemo((fun () -> Impl.adjustPassive options), [| options |])\n            let removeOptions = React.useMemo((fun () -> Impl.createRemoveOptions options), [| options |])\n            let fn = React.useMemo((fun () -> unbox<#Event> >> action), [| action |])\n\n            let listener = React.useCallbackRef(fun () ->\n                match addOptions with\n                | Some options -> document.addEventListener(eventType, fn, options)\n                | None -> document.addEventListener(eventType, fn)\n\n                React.createDisposable(fun () ->\n                    match removeOptions with\n                    | Some options -> document.removeEventListener(eventType, fn, options)\n                    | None -> document.removeEventListener(eventType, fn)\n                )\n            )\n            \n            React.useEffect(listener)\n\n        static member inline onAbort (action: ProgressEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"abort\", action, ?options = options)\n        static member inline onAbort (action: UIEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"abort\", action, ?options = options)\n        static member inline onAnimationCancel (action: AnimationEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"animationcancel\", action, ?options = options)\n        static member inline onAnimationEnd (action: AnimationEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"animationend\", action, ?options = options)\n        static member inline onAnimationIteration (action: AnimationEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"animationiteration\", action, ?options = options)\n        static member inline onAnimationStart (action: AnimationEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"animationstart\", action, ?options = options)\n        static member inline onAuxClick (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"onauxclick\", action, ?options = options)\n        static member inline onBlur (action: FocusEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"blur\", action, ?options = options)\n        static member inline onCancel (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"oncancel\", action, ?options = options)\n        static member inline onCanPlay (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"canplay\", action, ?options = options)\n        static member inline onCanPlayThrough (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"canplaythrough\", action, ?options = options)\n        static member inline onChange (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"change\", action, ?options = options)\n        static member inline onClick (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"click\", action, ?options = options)\n        static member inline onClose (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"onclose\", action, ?options = options)\n        static member inline onContextMenu (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"contextmenu\", action, ?options = options)\n        static member inline onCopy (action: ClipboardEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"copy\", action, ?options = options)\n        static member inline onCueChange (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"oncuechange\", action, ?options = options)\n        static member inline onCut (action: ClipboardEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"cut\", action, ?options = options)\n        static member inline onDblClick (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"dblClick\", action, ?options = options)\n        static member inline onDOMContentLoaded (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"DOMContentLoaded\", action, ?options = options)\n        static member inline onDrag (action: DragEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"drag\", action, ?options = options)\n        static member inline onDragEnd (action: DragEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"dragend\", action, ?options = options)\n        static member inline onDragEnter (action: DragEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"dragenter\", action, ?options = options)\n        static member inline onDragExit (action: DragEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"dragexit\", action, ?options = options)\n        static member inline onDragLeave (action: DragEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"dragleave\", action, ?options = options)\n        static member inline onDragOver (action: DragEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"dragover\", action, ?options = options)\n        static member inline onDragStart (action: DragEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"dragstart\", action, ?options = options)\n        static member inline onDrop (action: DragEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"drop\", action, ?options = options)\n        static member inline onDurationChange (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"durationchange\", action, ?options = options)\n        static member inline onEmptied (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"emptied\", action, ?options = options)\n        static member inline onEnded (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"ended\", action, ?options = options)\n        static member inline onError (action: ProgressEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"error\", action, ?options = options)\n        static member inline onError (action: UIEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"error\", action, ?options = options)\n        static member inline onFocus (action: FocusEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"focus\", action, ?options = options)\n        static member inline onFormData (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"formdata\", action, ?options = options)\n        static member inline onFullscreenChange (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"fullscreenchange\", action, ?options = options)\n        static member inline onFullscreenError (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"fullscreenerror\", action, ?options = options)\n        static member inline onGotPointerCapture (action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"gotPointercapture\", action, ?options = options)\n        static member inline onInput (action: UIEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"input\", action, ?options = options)\n        static member inline onInvalid (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"invalid\", action, ?options = options)\n        static member inline onKeyDown (action: KeyboardEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"keydown\", action, ?options = options)\n        static member inline onKeyPress (action: KeyboardEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"keypress\", action, ?options = options)\n        static member inline onKeyUp (action: KeyboardEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"keyup\", action, ?options = options)\n        static member inline onLoad (action: ProgressEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"load\", action, ?options = options)\n        static member inline onLoad (action: UIEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"load\", action, ?options = options)\n        static member inline onLoadedData (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"loadeddata\", action, ?options = options)\n        static member inline onLoadedMetadata (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"loadedmetadata\", action, ?options = options)\n        static member inline onLoadEnd (action: ProgressEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"loadend\", action, ?options = options)\n        static member inline onLoadStart (action: ProgressEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"loadstart\", action, ?options = options)\n        static member inline onLostPointerCapture (action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"lostpointercapture\", action, ?options = options)\n        static member inline onMouseDown (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"mousedown\", action, ?options = options)\n        static member inline onMouseEnter (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"mouseenter\", action, ?options = options)\n        static member inline onMouseLeave (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"mouseleave\", action, ?options = options)\n        static member inline onMouseMove (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"mousemove\", action, ?options = options)\n        static member inline onMouseOut (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"mouseout\", action, ?options = options)\n        static member inline onMouseOver (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"mouseover\", action, ?options = options)\n        static member inline onMouseUp (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"mouseup\", action, ?options = options)\n        static member inline onPaste (action: ClipboardEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"paste\", action, ?options = options)\n        static member inline onPause (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"pause\", action, ?options = options)\n        static member inline onPlay (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"play\", action, ?options = options)\n        static member inline onPlaying (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"playing\", action, ?options = options)\n        static member inline onPointerCancel (action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"pointercancel\", action, ?options = options)\n        static member inline onPointerDown (action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"pointerdown\", action, ?options = options)\n        static member inline onPointerEnter (action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"pointerenter\", action, ?options = options)\n        static member inline onPointerLeave (action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"pointerleave\", action, ?options = options)\n        static member inline onPointerMove (action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"pointermove\", action, ?options = options)\n        static member inline onPointerOut (action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"pointerout\", action, ?options = options)\n        static member inline onPointerOver (action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"pointerover\", action, ?options = options)\n        static member inline onPointerUp (action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"pointerup\", action, ?options = options)\n        static member inline onProgress (action: ProgressEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"progress\", action, ?options = options)\n        static member inline onRateChange (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"ratechange\", action, ?options = options)\n        static member inline onReadyStateChange (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"readystatechange\", action, ?options = options)\n        static member inline onReset (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"reset\", action, ?options = options)\n        static member inline onResize (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"resize\", action, ?options = options)\n        static member inline onScroll (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"scroll\", action, ?options = options)\n        static member inline onSeeked (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"seeked\", action, ?options = options)\n        static member inline onSeeking (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"seeking\", action, ?options = options)\n        static member inline onSelect (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"select\", action, ?options = options)\n        static member inline onSelectionChange (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"selectionchange\", action, ?options = options)\n        static member inline onSelectStart (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"selectstart\", action, ?options = options)\n        static member inline onStalled (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"stalled\", action, ?options = options)\n        static member inline onSubmit (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"submit\", action, ?options = options)\n        static member inline onSuspend (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"suspend\", action, ?options = options)\n        static member inline onTimeUpdate (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"timeupdate\", action, ?options = options)\n        static member inline onTouchCancel (action: TouchEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"touchcancel\", action, ?options = options)\n        static member inline onTouchEnd (action: TouchEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"touchend\", action, ?options = options)\n        static member inline onTouchMove (action: TouchEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"touchmove\", action, ?options = options)\n        static member inline onTouchStart (action: TouchEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"touchstart\", action, ?options = options)\n        static member inline onTransitionCancel (action: TransitionEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"transitioncancel\", action, ?options = options)\n        static member inline onTransitionEnd (action: TransitionEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"transitionend\", action, ?options = options)\n        static member inline onTransitionRun (action: TransitionEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"transitionrun\", action, ?options = options)\n        static member inline onTransitionStart (action: TransitionEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"transitionstart\", action, ?options = options)\n        static member inline onVisibilityChange (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"visibilitychange\", action, ?options = options)\n        static member inline onVolumeChange (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"volumechange\", action, ?options = options)\n        static member inline onWaiting (action: Event -> unit, ?options: AddEventListenerOptions) = useListener.on(\"waiting\", action, ?options = options)\n        static member inline onWheel (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useListener.on(\"wheel\", action, ?options = options)\n\n        /// Invokes the callback when a click event is not within the given element.\n        ///\n        /// Uses separate handlers for touch and mouse events.\n        ///\n        /// This listener is passive by default.\n        static member inline onClickAway (elemRef: IRefValue<#HTMLElement option>, callback: MouseEvent -> unit, touchCallback: TouchEvent -> unit, ?options: AddEventListenerOptions) =\n            let options = Option.defaultValue Impl.defaultPassive options\n\n            useListener.onMouseDown((fun ev ->\n                match elemRef.current with\n                | Some elem when not (elem.contains(unbox ev.target)) ->\n                    callback ev\n                | _ -> ()\n            ), options)\n\n            useListener.onTouchStart((fun ev ->\n                match elemRef.current with\n                | Some elem when not (elem.contains(unbox ev.target)) ->\n                    touchCallback ev\n                | _ -> ()\n            ), options)\n        \n        /// Invokes the callback when a click event is not within the given element.\n        ///\n        /// Shares a common callback for both touch and mouse events.\n        ///\n        /// This listener is passive by default.\n        static member inline onClickAway (elemRef: IRefValue<#HTMLElement option>, callback: UIEvent -> unit, ?options: AddEventListenerOptions) =\n            let options = Option.defaultValue Impl.defaultPassive options\n\n            useListener.onMouseDown((fun ev ->\n                match elemRef.current with\n                | Some elem when not (elem.contains(unbox ev.target)) ->\n                    callback ev\n                | _ -> ()\n            ), options)\n\n            useListener.onTouchStart((fun ev ->\n                match elemRef.current with\n                | Some elem when not (elem.contains(unbox ev.target)) ->\n                    callback ev\n                | _ -> ()\n            ), options)\n\n    [<Erase>]\n    type useElementListener =\n        static member inline on (elemRef: IRefValue<#HTMLElement option>, eventType: string, action: #Event -> unit, ?options: AddEventListenerOptions) =\n            let addOptions = React.useMemo((fun () -> Impl.adjustPassive options), [| options |])\n            let removeOptions = React.useMemo((fun () -> Impl.createRemoveOptions options), [| options |])\n            let fn = React.useMemo((fun () -> unbox<#Event> >> action), [| action |])\n\n            let listener = React.useCallbackRef(fun () ->\n                elemRef.current |> Option.iter(fun elem ->\n                    match addOptions with\n                    | Some options -> elem.addEventListener(eventType, fn, options)\n                    | None -> elem.addEventListener(eventType, fn)\n                )\n                \n                React.createDisposable(fun () -> \n                    elemRef.current |> Option.iter(fun elem ->\n                        match removeOptions with\n                        | Some options -> elem.removeEventListener(eventType, fn, options)\n                        | None -> elem.removeEventListener(eventType, fn)\n                ))\n            )\n\n            React.useEffect(listener)\n\n        static member inline onAbort (elemRef: IRefValue<#HTMLElement option>, action: ProgressEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"abort\", action, ?options = options)\n        static member inline onAbort (elemRef: IRefValue<#HTMLElement option>, action: UIEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"abort\", action, ?options = options)\n        static member inline onAnimationCancel (elemRef: IRefValue<#HTMLElement option>, action: AnimationEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"animationcancel\", action, ?options = options)\n        static member inline onAnimationEnd (elemRef: IRefValue<#HTMLElement option>, action: AnimationEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"animationend\", action, ?options = options)\n        static member inline onAnimationIteration (elemRef: IRefValue<#HTMLElement option>, action: AnimationEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"animationiteration\", action, ?options = options)\n        static member inline onAnimationStart (elemRef: IRefValue<#HTMLElement option>, action: AnimationEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"animationstart\", action, ?options = options)\n        static member inline onAuxClick (elemRef: IRefValue<#HTMLElement option>, action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"onauxclick\", action, ?options = options)\n        static member inline onBlur (elemRef: IRefValue<#HTMLElement option>, action: FocusEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"blur\", action, ?options = options)\n        static member inline onCancel (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"oncancel\", action, ?options = options)\n        static member inline onCanPlay (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"canplay\", action, ?options = options)\n        static member inline onCanPlayThrough (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"canplaythrough\", action, ?options = options)\n        static member inline onChange (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"change\", action, ?options = options)\n        static member inline onClick (elemRef: IRefValue<#HTMLElement option>, action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"click\", action, ?options = options)\n        static member inline onClose (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"onclose\", action, ?options = options)\n        static member inline onContextMenu (elemRef: IRefValue<#HTMLElement option>, action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"contextmenu\", action, ?options = options)\n        static member inline onCopy (elemRef: IRefValue<#HTMLElement option>, action: ClipboardEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"copy\", action, ?options = options)\n        static member inline onCueChange (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"oncuechange\", action, ?options = options)\n        static member inline onCut (elemRef: IRefValue<#HTMLElement option>, action: ClipboardEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"cut\", action, ?options = options)\n        static member inline onDblClick (elemRef: IRefValue<#HTMLElement option>, action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"dblClick\", action, ?options = options)\n        static member inline onDOMContentLoaded (elemRef: IRefValue<#HTMLElement option>, action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"DOMContentLoaded\", action, ?options = options)\n        static member inline onDrag (elemRef: IRefValue<#HTMLElement option>, action: DragEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"drag\", action, ?options = options)\n        static member inline onDragEnd (elemRef: IRefValue<#HTMLElement option>, action: DragEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"dragend\", action, ?options = options)\n        static member inline onDragEnter (elemRef: IRefValue<#HTMLElement option>, action: DragEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"dragenter\", action, ?options = options)\n        static member inline onDragExit (elemRef: IRefValue<#HTMLElement option>, action: DragEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"dragexit\", action, ?options = options)\n        static member inline onDragLeave (elemRef: IRefValue<#HTMLElement option>, action: DragEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"dragleave\", action, ?options = options)\n        static member inline onDragOver (elemRef: IRefValue<#HTMLElement option>, action: DragEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"dragover\", action, ?options = options)\n        static member inline onDragStart (elemRef: IRefValue<#HTMLElement option>, action: DragEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"dragstart\", action, ?options = options)\n        static member inline onDrop (elemRef: IRefValue<#HTMLElement option>, action: DragEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"drop\", action, ?options = options)\n        static member inline onDurationChange (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"durationchange\", action, ?options = options)\n        static member inline onEmptied (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"emptied\", action, ?options = options)\n        static member inline onEnded (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"ended\", action, ?options = options)\n        static member inline onError (elemRef: IRefValue<#HTMLElement option>, action: ProgressEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"error\", action, ?options = options)\n        static member inline onError (elemRef: IRefValue<#HTMLElement option>, action: UIEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"error\", action, ?options = options)\n        static member inline onFocus (elemRef: IRefValue<#HTMLElement option>, action: FocusEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"focus\", action, ?options = options)\n        static member inline onFocusIn (elemRef: IRefValue<#HTMLElement option>, action: FocusEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"focusin\", action, ?options = options)\n        static member inline onFocusOut (elemRef: IRefValue<#HTMLElement option>, action: FocusEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"focusout\", action, ?options = options)\n        static member inline onFormData (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"formdata\", action, ?options = options)\n        static member inline onFullscreenChange (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"fullscreenchange\", action, ?options = options)\n        static member inline onFullscreenError (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"fullscreenerror\", action, ?options = options)\n        static member inline onGotPointerCapture (elemRef: IRefValue<#HTMLElement option>, action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"gotPointercapture\", action, ?options = options)\n        static member inline onInput (elemRef: IRefValue<#HTMLElement option>, action: UIEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"input\", action, ?options = options)\n        static member inline onInvalid (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"invalid\", action, ?options = options)\n        static member inline onKeyDown (elemRef: IRefValue<#HTMLElement option>, action: KeyboardEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"keydown\", action, ?options = options)\n        static member inline onKeyPress (elemRef: IRefValue<#HTMLElement option>, action: KeyboardEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"keypress\", action, ?options = options)\n        static member inline onKeyUp (elemRef: IRefValue<#HTMLElement option>, action: KeyboardEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"keyup\", action, ?options = options)\n        static member inline onLoad (elemRef: IRefValue<#HTMLElement option>, action: ProgressEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"load\", action, ?options = options)\n        static member inline onLoad (elemRef: IRefValue<#HTMLElement option>, action: UIEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"load\", action, ?options = options)\n        static member inline onLoadedData (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"loadeddata\", action, ?options = options)\n        static member inline onLoadedMetadata (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"loadedmetadata\", action, ?options = options)\n        static member inline onLoadEnd (elemRef: IRefValue<#HTMLElement option>, action: ProgressEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"loadend\", action, ?options = options)\n        static member inline onLoadStart (elemRef: IRefValue<#HTMLElement option>, action: ProgressEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"loadstart\", action, ?options = options)\n        static member inline onLostPointerCapture (elemRef: IRefValue<#HTMLElement option>, action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"lostpointercapture\", action, ?options = options)\n        static member inline onMouseDown (elemRef: IRefValue<#HTMLElement option>, action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"mousedown\", action, ?options = options)\n        static member inline onMouseEnter (elemRef: IRefValue<#HTMLElement option>, action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"mouseenter\", action, ?options = options)\n        static member inline onMouseLeave (elemRef: IRefValue<#HTMLElement option>, action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"mouseleave\", action, ?options = options)\n        static member inline onMouseMove (elemRef: IRefValue<#HTMLElement option>, action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"mousemove\", action, ?options = options)\n        static member inline onMouseOut (elemRef: IRefValue<#HTMLElement option>, action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"mouseout\", action, ?options = options)\n        static member inline onMouseOver (elemRef: IRefValue<#HTMLElement option>, action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"mouseover\", action, ?options = options)\n        static member inline onMouseUp (elemRef: IRefValue<#HTMLElement option>, action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"mouseup\", action, ?options = options)\n        static member inline onPaste (elemRef: IRefValue<#HTMLElement option>, action: ClipboardEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"paste\", action, ?options = options)\n        static member inline onPause (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"pause\", action, ?options = options)\n        static member inline onPlay (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"play\", action, ?options = options)\n        static member inline onPlaying (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"playing\", action, ?options = options)\n        static member inline onPointerCancel (elemRef: IRefValue<#HTMLElement option>, action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"pointercancel\", action, ?options = options)\n        static member inline onPointerDown (elemRef: IRefValue<#HTMLElement option>, action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"pointerdown\", action, ?options = options)\n        static member inline onPointerEnter (elemRef: IRefValue<#HTMLElement option>, action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"pointerenter\", action, ?options = options)\n        static member inline onPointerLeave (elemRef: IRefValue<#HTMLElement option>, action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"pointerleave\", action, ?options = options)\n        static member inline onPointerMove (elemRef: IRefValue<#HTMLElement option>, action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"pointermove\", action, ?options = options)\n        static member inline onPointerOut (elemRef: IRefValue<#HTMLElement option>, action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"pointerout\", action, ?options = options)\n        static member inline onPointerOver (elemRef: IRefValue<#HTMLElement option>, action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"pointerover\", action, ?options = options)\n        static member inline onPointerUp (elemRef: IRefValue<#HTMLElement option>, action: PointerEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"pointerup\", action, ?options = options)\n        static member inline onProgress (elemRef: IRefValue<#HTMLElement option>, action: ProgressEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"progress\", action, ?options = options)\n        static member inline onRateChange (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"ratechange\", action, ?options = options)\n        static member inline onReadyStateChange (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"readystatechange\", action, ?options = options)\n        static member inline onReset (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"reset\", action, ?options = options)\n        static member inline onResize (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"resize\", action, ?options = options)\n        static member inline onScroll (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"scroll\", action, ?options = options)\n        static member inline onSeeked (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"seeked\", action, ?options = options)\n        static member inline onSeeking (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"seeking\", action, ?options = options)\n        static member inline onSelect (elemRef: IRefValue<#HTMLElement option>, action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"select\", action, ?options = options)\n        static member inline onSelectionChange (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"selectionchange\", action, ?options = options)\n        static member inline onSelectStart (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"selectstart\", action, ?options = options)\n        static member inline onStalled (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"stalled\", action, ?options = options)\n        static member inline onSubmit (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"submit\", action, ?options = options)\n        static member inline onSuspend (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"suspend\", action, ?options = options)\n        static member inline onTimeUpdate (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"timeupdate\", action, ?options = options)\n        static member inline onTouchCancel (elemRef: IRefValue<#HTMLElement option>, action: TouchEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"touchcancel\", action, ?options = options)\n        static member inline onTouchEnd (elemRef: IRefValue<#HTMLElement option>, action: TouchEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"touchend\", action, ?options = options)\n        static member inline onTouchMove (elemRef: IRefValue<#HTMLElement option>, action: TouchEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"touchmove\", action, ?options = options)\n        static member inline onTouchStart (elemRef: IRefValue<#HTMLElement option>, action: TouchEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"touchstart\", action, ?options = options)\n        static member inline onTransitionCancel (elemRef: IRefValue<#HTMLElement option>, action: TransitionEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"transitioncancel\", action, ?options = options)\n        static member inline onTransitionEnd (elemRef: IRefValue<#HTMLElement option>, action: TransitionEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"transitionend\", action, ?options = options)\n        static member inline onTransitionRun (elemRef: IRefValue<#HTMLElement option>, action: TransitionEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"transitionrun\", action, ?options = options)\n        static member inline onTransitionStart (elemRef: IRefValue<#HTMLElement option>, action: TransitionEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"transitionstart\", action, ?options = options)\n        static member inline onVisibilityChange (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"visibilitychange\", action, ?options = options)\n        static member inline onVolumeChange (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"volumechange\", action, ?options = options)\n        static member inline onWaiting (elemRef: IRefValue<#HTMLElement option>, action: Event -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"waiting\", action, ?options = options)\n        static member inline onWheel (elemRef: IRefValue<#HTMLElement option>, action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useElementListener.on(elemRef, \"wheel\", action, ?options = options)\n\n    [<Erase>]\n    type useStyle =\n        static member inline onCustom (elemRef: IRefValue<#HTMLElement option>) (styles: IStyleAttribute list) (resolver: #HTMLElement option -> bool) =\n            let isTrue,setIsTrue = React.useState false\n            \n            useElementListener.onChange(elemRef, (fun _ ->\n                elemRef.current\n                |> resolver\n                |> setIsTrue\n            ), Impl.defaultPassive)\n\n            React.useMemo((fun () -> \n                if isTrue then styles\n                else []\n            ), [| isTrue :> obj; styles :> obj |])\n\n        static member inline onClick (elemRef: IRefValue<#HTMLElement option>) (styles: IStyleAttribute list) =\n            let isClicked,setIsClicked = React.useState false\n            \n            useElementListener.onClick(elemRef, (fun _ -> setIsClicked (not isClicked)), Impl.defaultPassive)\n            \n            React.useMemo((fun () -> \n                if isClicked then styles\n                else []\n            ), [| isClicked :> obj; styles :> obj |])\n\n        static member inline onDisabled< ^elem when ^elem :> HTMLElement and ^elem : (member disabled : bool)> (elemRef: IRefValue< ^elem option>) (styles: IStyleAttribute list) =\n            useStyle.onCustom elemRef styles (fun elem ->\n                elem\n                |> Option.map (fun e -> e?disabled)\n                |> Option.defaultValue false\n            )\n\n        static member inline onFocus (elemRef: IRefValue<#HTMLElement option>) (styles: IStyleAttribute list) =\n            let isFocused,setIsFocused = React.useState false\n            \n            useElementListener.onFocusIn(elemRef, (fun _ -> setIsFocused true), Impl.defaultPassive)\n            useElementListener.onFocusOut(elemRef, (fun _ -> setIsFocused false), Impl.defaultPassive)\n\n            React.useMemo((fun () -> \n                if isFocused then styles\n                else []\n            ), [| isFocused :> obj; styles :> obj |])\n\n        static member inline onHover (elemRef: IRefValue<#HTMLElement option>) (styles: IStyleAttribute list) =\n            let isHovered,setIsHovered = React.useState false\n            \n            useElementListener.onMouseEnter(elemRef, (fun _ -> setIsHovered true), Impl.defaultPassive)\n            useElementListener.onMouseLeave(elemRef, (fun _ -> setIsHovered false), Impl.defaultPassive)\n\n            React.useMemo((fun () -> \n                if isHovered then styles\n                else []\n            ), [| isHovered :> obj; styles :> obj |])\n\n        static member inline onInvalid< ^elem when ^elem :> HTMLElement and ^elem : (member validity : ValidityState)> (elemRef: IRefValue< ^elem option>) (styles: IStyleAttribute list) =\n            useStyle.onCustom elemRef styles (fun elem ->\n                elem\n                |> Option.map (fun e -> \n                    JS.console.log(e?validity?valid)\n                    not e?validity?valid)\n                |> Option.defaultValue false\n            )\n\n        static member inline onValid< ^elem when ^elem :> HTMLElement and ^elem : (member validity : ValidityState)> (elemRef: IRefValue< ^elem option>) (styles: IStyleAttribute list) =\n            useStyle.onCustom elemRef styles (fun elem ->\n                elem\n                |> Option.map (fun e -> \n                    JS.console.log(e?validity?valid)\n                    e?validity?valid)\n                |> Option.defaultValue false\n            )\n\n    [<Erase>]\n    type useWindowListener =\n        static member inline on (eventType: string, action: #Event -> unit, ?options: AddEventListenerOptions) =\n            let addOptions = React.useMemo((fun () -> Impl.adjustPassive options), [| options |])\n            let removeOptions = React.useMemo((fun () -> Impl.createRemoveOptions options), [| options |])\n            let fn = React.useMemo((fun () -> unbox<#Event> >> action), [| action |])\n\n            let listener = React.useCallbackRef(fun () ->\n                match addOptions with\n                | Some options -> window.addEventListener(eventType, fn, options)\n                | None -> window.addEventListener(eventType, fn)\n\n                React.createDisposable(fun () ->\n                    match removeOptions with\n                    | Some options -> window.removeEventListener(eventType, fn, options)\n                    | None -> window.removeEventListener(eventType, fn)\n                )\n            )\n            \n            React.useEffect(listener)\n        \n        static member inline onAbort (action: ProgressEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"abort\", action, ?options = options)\n        static member inline onAbort (action: UIEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"abort\", action, ?options = options)\n        static member inline onAnimationCancel (action: AnimationEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"animationcancel\", action, ?options = options)\n        static member inline onAnimationEnd (action: AnimationEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"animationend\", action, ?options = options)\n        static member inline onAnimationIteration (action: AnimationEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"animationiteration\", action, ?options = options)\n        static member inline onAnimationStart (action: AnimationEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"animationstart\", action, ?options = options)\n        static member inline onAuxClick (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"onauxclick\", action, ?options = options)\n        static member inline onAfterPrint (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"afterprint\", action, ?options = options)\n        static member inline onBeforeInstallPrompt (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"beforeinstallprompt\", action, ?options = options)\n        static member inline onBeforePrint (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"beforeprint\", action, ?options = options)\n        static member inline onBeforeUnload (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"beforeunload\", action, ?options = options)\n        static member inline onBlur (action: FocusEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"blur\", action, ?options = options)\n        static member inline onChange (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"change\", action, ?options = options)\n        static member inline onClick (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"click\", action, ?options = options)\n        static member inline onClipboardChange (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"clipboardchange\", action, ?options = options)\n        static member inline onClose (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"onclose\", action, ?options = options)\n        static member inline onContextMenu (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"contextmenu\", action, ?options = options)\n        static member inline onCopy (action: ClipboardEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"copy\", action, ?options = options)\n        static member inline onCut (action: ClipboardEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"cut\", action, ?options = options)\n        static member inline onDblClick (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"dblClick\", action, ?options = options)\n        static member inline onDeviceMotion (action: DeviceMotionEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"devicemotion\", action, ?options = options)\n        static member inline onDeviceOrientation (action: DeviceOrientationEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"deviceorientation\", action, ?options = options)\n        static member inline onDOMContentLoaded (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"DOMContentLoaded\", action, ?options = options)\n        static member inline onDurationChange (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"durationchange\", action, ?options = options)\n        static member inline onError (action: ProgressEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"error\", action, ?options = options)\n        static member inline onError (action: UIEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"error\", action, ?options = options)\n        static member inline onFocus (action: FocusEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"focus\", action, ?options = options)\n        static member inline onHashChange (action: HashChangeEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"hashchange\", action, ?options = options)\n        static member inline onInput (action: UIEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"input\", action, ?options = options)\n        static member inline onInvalid (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"invalid\", action, ?options = options)\n        static member inline onKeyDown (action: KeyboardEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"keydown\", action, ?options = options)\n        static member inline onKeyPress (action: KeyboardEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"keypress\", action, ?options = options)\n        static member inline onKeyUp (action: KeyboardEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"keyup\", action, ?options = options)\n        static member inline onLanguageChange (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"languagechange\", action, ?options = options)\n        static member inline onLoad (action: ProgressEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"load\", action, ?options = options)\n        static member inline onLoad (action: UIEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"load\", action, ?options = options)\n        static member inline onMessage (action: MessageEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"message\", action, ?options = options)\n        static member inline onMessageError (action: MessageEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"message\", action, ?options = options)\n        static member inline onMouseDown (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"mousedown\", action, ?options = options)\n        static member inline onMouseEnter (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"mouseenter\", action, ?options = options)\n        static member inline onMouseLeave (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"mouseleave\", action, ?options = options)\n        static member inline onMouseMove (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"mousemove\", action, ?options = options)\n        static member inline onMouseOut (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"mouseout\", action, ?options = options)\n        static member inline onMouseOver (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"mouseover\", action, ?options = options)\n        static member inline onMouseUp (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"mouseup\", action, ?options = options)\n        static member inline onOffline (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"offline\", action, ?options = options)\n        static member inline onOnline (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"online\", action, ?options = options)\n        static member inline onOrientationChange (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"orientationchange\", action, ?options = options)\n        static member inline onPageHide (action: PageTransitionEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"onPageHide\", action, ?options = options)\n        static member inline onPageShow (action: PageTransitionEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"onPageShow\", action, ?options = options)\n        static member inline onPaste (action: ClipboardEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"paste\", action, ?options = options)\n        static member inline onPopState (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"popstate\", action, ?options = options)\n        static member inline onRejectionHandled (action: PromiseRejectionEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"rejectionhandled\", action, ?options = options)\n        static member inline onReset (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"reset\", action, ?options = options)\n        static member inline onResize (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"resize\", action, ?options = options)\n        static member inline onScroll (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"scroll\", action, ?options = options)\n        static member inline onSelect (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"select\", action, ?options = options)\n        static member inline onSelectionChange (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"selectionchange\", action, ?options = options)\n        static member inline onSelectStart (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"selectstart\", action, ?options = options)\n        static member inline onStorage (action: StorageEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"storage\", action, ?options = options)\n        static member inline onSubmit (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"submit\", action, ?options = options)\n        static member inline onTransitionCancel (action: TransitionEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"transitioncancel\", action, ?options = options)\n        static member inline onTransitionEnd (action: TransitionEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"transitionend\", action, ?options = options)\n        static member inline onTransitionRun (action: TransitionEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"transitionrun\", action, ?options = options)\n        static member inline onTransitionStart (action: TransitionEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"transitionstart\", action, ?options = options)\n        static member inline onUnhandledRejection (action: PromiseRejectionEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"unhandledrejection\", action, ?options = options)\n        static member inline onUnload (action: Event -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"unload\", action, ?options = options)\n        static member inline onWheel (action: MouseEvent -> unit, ?options: AddEventListenerOptions) = useWindowListener.on(\"wheel\", action, ?options = options)\n","namespace Feliz.Router\r\n\r\nopen Browser.Dom\r\nopen Browser.Types\r\nopen Elmish\r\nopen Fable.Core\r\nopen Fable.Core.JsInterop\r\nopen Feliz\r\nopen Feliz.UseListener\r\nopen System\r\n\r\ntype IUrlSearchParameters =\r\n    abstract entries : unit -> seq<string array>\r\n\r\n/// Determines whether the router will push a new entry to the history of modify the current one.\r\n[<RequireQualifiedAccess>]\r\ntype HistoryMode =\r\n    /// A new history will be added to the entries such that if the user clicks the back button,\r\n    /// the previous page will be shown, this is the default bahavior of the router.\r\n    | PushState = 1\r\n    /// Only modifies the current history entry and does not add a new one to the history stack. Clicking the back button will *not* have the effect of retuning to the previous page.\r\n    | ReplaceState = 2\r\n\r\n/// Determines whether the router will use path or hash based routes\r\n[<RequireQualifiedAccess>]\r\ntype RouteMode =\r\n    | Hash = 1\r\n    | Path = 2\r\n\r\n[<RequireQualifiedAccess; System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)>]\r\nmodule Router =\r\n    [<RequireQualifiedAccess>]\r\n    module String =\r\n        let (|Prefix|) (prefix: string) (str: string) =\r\n            if str.StartsWith prefix then Some str\r\n            else None\r\n\r\n        let (|Suffix|) (suffix: string) (str: string) =\r\n            if str.EndsWith suffix then Some str\r\n            else None\r\n\r\n        let inline split (sep: char) (str: string) =\r\n            str.Split(sep)\r\n\r\n    let [<Literal>] customNavigationEvent = \"CUSTOM_NAVIGATION_EVENT\"\r\n    let inline hashPrefix str = \"#/\" + str\r\n    let inline combine xs = String.concat \"/\" xs\r\n\r\n    type RouterProps =\r\n        abstract onUrlChanged: (string list -> unit) option\r\n        abstract application: ReactElement option\r\n        abstract hashMode: RouteMode option\r\n\r\n    [<Emit(\"encodeURIComponent($0)\")>]\r\n    let encodeURIComponent (value: string) : string = jsNative\r\n    [<Emit(\"decodeURIComponent($0)\")>]\r\n    let decodeURIComponent (value: string) : string = jsNative\r\n\r\n    let encodeQueryString queryStringPairs =\r\n        queryStringPairs\r\n        |> List.map (fun (key, value) ->\r\n            String.concat \"=\" [ encodeURIComponent key; encodeURIComponent value ])\r\n        |> String.concat \"&\"\r\n        |> function\r\n            | \"\" -> \"\"\r\n            | pairs -> \"?\" + pairs\r\n\r\n    let encodeQueryStringInts queryStringIntPairs =\r\n        queryStringIntPairs\r\n        |> List.map (fun (key, value: int) ->\r\n            String.concat \"=\" [ encodeURIComponent key; unbox<string> value ])\r\n        |> String.concat \"&\"\r\n        |> function\r\n            | \"\" -> \"\"\r\n            | pairs -> \"?\" + pairs\r\n\r\n    let private normalizeRoute routeMode =\r\n        if routeMode = RouteMode.Hash then\r\n            function\r\n            | String.Prefix \"/\" (Some path) -> \"#\" + path\r\n            | String.Prefix \"#/\" (Some path) -> path\r\n            | String.Prefix \"#\" (Some path) -> \"#/\" + path.Substring(1, path.Length - 1)\r\n            | path -> \"#/\" + path\r\n        else\r\n            function\r\n            | String.Prefix \"/\" (Some path) -> path\r\n            | path -> \"/\" + path\r\n\r\n    let encodeParts xs routeMode =\r\n        xs\r\n        |> List.map (fun (part: string) ->\r\n            if part.Contains \"?\" || part.StartsWith \"#\" || part.StartsWith \"/\" then part\r\n            else encodeURIComponent part)\r\n        |> combine\r\n        |> normalizeRoute routeMode\r\n\r\n    /// Safely returns tuple of list items without last one and last item\r\n    let trySeparateLast xs =\r\n        match xs |> List.rev with\r\n        | [] -> None\r\n        | [ single ] -> Some([], single)\r\n        | list -> Some (list |> List.tail |> List.rev, list.Head)\r\n\r\n    let nav xs (mode: HistoryMode) (routeMode: RouteMode) =\r\n        if mode = HistoryMode.PushState\r\n        then history.pushState ((), \"\", encodeParts xs routeMode)\r\n        else history.replaceState((), \"\", encodeParts xs routeMode)\r\n\r\n        let ev = document.createEvent(\"CustomEvent\")\r\n\r\n        ev.initEvent (customNavigationEvent, true, true)\r\n        window.dispatchEvent ev |> ignore\r\n\r\n    /// Parses the URL into multiple path segments\r\n    let urlSegments (path: string) (mode: RouteMode) =\r\n        match path with\r\n        | String.Prefix \"#\" (Some _) ->\r\n            // remove the hash sign\r\n            path.Substring(1, path.Length - 1)\r\n        | _ when mode = RouteMode.Hash ->\r\n            match path with\r\n            | String.Suffix \"#\" (Some _)\r\n            | String.Suffix \"#/\" (Some _) -> \"\"\r\n            | _ -> path\r\n        | _ -> path\r\n        |> String.split '/'\r\n        |> List.ofArray\r\n        |> List.collect (fun segment ->\r\n            if String.IsNullOrWhiteSpace segment then []\r\n            else\r\n                let segment = segment.TrimEnd '#'\r\n\r\n                match segment with\r\n                | \"?\" -> []\r\n                | String.Prefix \"?\" (Some _) -> [ segment ]\r\n                | _ ->\r\n                    match segment.Split [| '?' |] with\r\n                    | [| value |] -> [ decodeURIComponent value ]\r\n                    | [| value; \"\" |] -> [ decodeURIComponent value ]\r\n                    | [| value; query |] -> [ decodeURIComponent value; \"?\" + query ]\r\n                    | _ -> [])\r\n\r\n    [<Emit(\"new URLSearchParams($0)\")>]\r\n    let createUrlSearchParams (queryString: string) : IUrlSearchParameters = jsNative\r\n\r\n    [<Emit(\"window.navigator.userAgent\")>]\r\n    let navigatorUserAgent : string = jsNative\r\n\r\n    let onUrlChange routeMode urlChanged (ev: _) =\r\n        match routeMode with\r\n        | RouteMode.Path -> window.location.pathname + window.location.search\r\n        | _ -> window.location.hash\r\n        |> fun path -> urlSegments path routeMode\r\n        |> urlChanged\r\n\r\n    let router = React.memo(fun (input: RouterProps) ->\r\n        let onChange = React.useCallbackRef(fun (ev: Event) ->\r\n            let urlChanged = Option.defaultValue ignore input.onUrlChanged\r\n            let routeMode = Option.defaultValue RouteMode.Hash input.hashMode\r\n\r\n            onUrlChange routeMode urlChanged ev)\r\n\r\n        if navigatorUserAgent.Contains \"Trident\" || navigatorUserAgent.Contains \"MSIE\"\r\n        then React.useWindowListener.onHashChange(onChange)\r\n        else React.useWindowListener.onPopState(onChange)\r\n\r\n        React.useWindowListener.on(customNavigationEvent, onChange)\r\n\r\n        match input.application with\r\n        | Some elem -> elem\r\n        | None -> Html.none)\r\n\r\n/// Defines a property for the `router` element\r\ntype IRouterProperty = interface end\r\n\r\n[<AutoOpen>]\r\nmodule ReactExtension =\r\n    type React with\r\n        /// Initializes the router as an element of the page and starts listening to URL changes.\r\n        static member inline router (props: IRouterProperty list) =\r\n            Router.router (unbox<Router.RouterProps> (createObj !!props))\r\n\r\n[<Erase>]\r\ntype router =\r\n    /// An event that is triggered when the URL in the address bar changes, whether by hand or programmatically using `Router.navigate(...)`.\r\n    /// The event arguments are the parts of the URL, segmented into strings:\r\n    ///\r\n    /// `segment \"#/\" => [ ]`\r\n    ///\r\n    /// `segment \"#/home\" => [ \"home\" ]`\r\n    ///\r\n    /// `segment \"#/home/settings\" => [ \"home\"; \"settings\" ]`\r\n    ///\r\n    /// `segment \"#/users/1\" => [ \"users\"; \"1\" ]`\r\n    ///\r\n    /// `segment \"#/users/1/details\" => [ \"users\"; \"1\"; \"details\" ]`\r\n    ///\r\n    /// with query string parameters\r\n    ///\r\n    /// `segment \"#/users?id=1\" => [ \"users\"; \"?id=1\" ]`\r\n    ///\r\n    /// `segment \"#/home/users?id=1\" => [ \"home\"; \"users\"; \"?id=1\" ]`\r\n    ///\r\n    /// `segment \"#/users?id=1&format=json\" => [ \"users\"; \"?id=1&format=json\" ]`\r\n    static member inline onUrlChanged (eventHandler: string list -> unit) : IRouterProperty = unbox (\"onUrlChanged\", eventHandler)\r\n\r\n    /// The element that is rendered inside where the `router` is placed. Usually this contains the root application but it could also be part of another root element.\r\n    ///\r\n    /// It will keep listening for URL changes as long as the `router` is rendered on screen somewhere.\r\n    static member inline children (element: ReactElement) : IRouterProperty = unbox (\"application\", element)\r\n\r\n    /// The content that is rendered inside where the `router` is placed. Usually this contains the root application but it could also be part of another root element.\r\n    ///\r\n    /// It will keep listening for URL changes as long as the `router` is rendered on screen somewhere.\r\n    static member inline children (elements: ReactElement list) : IRouterProperty = unbox (\"application\", React.fragment elements)\r\n\r\n    /// Use # based routes (default)\r\n    static member inline hashMode : IRouterProperty = unbox (\"hashMode\", RouteMode.Hash)\r\n\r\n    /// Use full (HTML 5) based routes instead of # based.\r\n    /// You have to be careful about which requests you want forwarded to the server and which ones should be handled locally.\r\n    /// To keep the request local, you have to use the 'Router.navigate' function for all the URL transitions.\r\n    static member inline pathMode : IRouterProperty = unbox (\"hashMode\", RouteMode.Path)\r\n\r\n[<Erase>]\r\ntype Router =\r\n    /// Parses the current URL of the page and returns the cleaned URL segments. This is default when working with hash URLs. When working with path-based URLs, use Router.currentPath() instead.\r\n    static member inline currentUrl () =\r\n        Router.urlSegments window.location.hash RouteMode.Hash\r\n\r\n    /// Parses the current URL of the page and returns the cleaned URL segments. This is default when working with path URLs. When working with hash-based (#) URLs, use Router.currentUrl() instead.\r\n    static member inline currentPath () =\r\n        let fullPath = window.location.pathname + window.location.search\r\n        Router.urlSegments fullPath RouteMode.Path\r\n\r\n    static member inline format([<ParamArray>] xs: string array) =\r\n        Router.encodeParts (List.ofArray xs) RouteMode.Hash\r\n\r\n    static member inline format(xs: string list, queryString: (string * string) list) : string =\r\n        xs\r\n        |> Router.trySeparateLast\r\n        |> Option.map (fun (r, l) -> Router.encodeParts (r @ [ l + Router.encodeQueryString queryString ]) RouteMode.Hash)\r\n        |> Option.defaultWith (fun _ -> Router.encodeParts [ Router.encodeQueryString queryString ] RouteMode.Hash)\r\n\r\n    static member inline format(segment: string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment + Router.encodeQueryString queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment: string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment + Router.encodeQueryStringInts queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; segment2 + Router.encodeQueryString queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; segment2 + Router.encodeQueryStringInts queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: string, segment3:int, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; segment2; unbox<string> segment3 + Router.encodeQueryString queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: string, segment3:int, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; segment2; unbox<string> segment3 + Router.encodeQueryStringInts queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: string, segment3:string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; segment2; segment3 + Router.encodeQueryString queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: string, segment3:string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; segment2; segment3 + Router.encodeQueryStringInts queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: int, segment3:string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; segment3 + Router.encodeQueryString queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: int, segment3:string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; segment3 + Router.encodeQueryStringInts queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; segment2; segment3; segment4 + Router.encodeQueryString queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; segment2; segment3; segment4 + Router.encodeQueryStringInts queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; segment2; segment3; segment4; segment5 + Router.encodeQueryString queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; segment2; segment3; segment4; segment5 + Router.encodeQueryStringInts queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; segment3; segment4 + Router.encodeQueryString queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; segment3; segment4 + Router.encodeQueryStringInts queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; unbox<string> segment3; segment4 + Router.encodeQueryString queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; unbox<string> segment3; segment4 + Router.encodeQueryStringInts queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; unbox<string> segment3; segment4; segment5; segment6 + Router.encodeQueryString queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; unbox<string> segment3; segment4; segment5; segment6 + Router.encodeQueryStringInts queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; unbox<string> segment3; unbox<string> segment4; segment5 + Router.encodeQueryString queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; unbox<string> segment3; unbox<string> segment4; segment5 + Router.encodeQueryStringInts queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; segment3; unbox<string> segment4; segment5 + Router.encodeQueryString queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; segment3; unbox<string> segment4; segment5 + Router.encodeQueryStringInts queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; segment3; segment4; segment5 + Router.encodeQueryString queryString ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; segment3; segment4; segment5 + Router.encodeQueryStringInts queryString ] RouteMode.Hash\r\n\r\n    static member inline format(fullPath: string) : string =\r\n        Router.encodeParts [ fullPath ] RouteMode.Hash\r\n\r\n    static member inline format(fullPath: string list) : string =\r\n        Router.encodeParts fullPath RouteMode.Hash\r\n\r\n    static member inline format(segment: string, value: int) : string =\r\n        Router.encodeParts [ segment; string value ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, value1: int, value2: int) : string =\r\n        Router.encodeParts [ segment1; string value1; string value2 ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, segment2: string, value1: int) : string =\r\n        Router.encodeParts [ segment1; segment2; string value1 ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, value1: int, segment2: string) : string =\r\n        Router.encodeParts [ segment1; string value1; segment2 ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, value1: int, segment2: string, value2: int) : string =\r\n        Router.encodeParts [ segment1; string value1; segment2; string value2 ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, value1: int, segment2: string, value2: int, segment3: string) : string =\r\n        Router.encodeParts [ segment1; string value1; segment2; string value2; segment3 ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, value1: int, segment2: string, value2: int, segment3: string, segment4: string) : string =\r\n        Router.encodeParts [ segment1; string value1; segment2; string value2; segment3; segment4 ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, value1: int, segment2: string, value2: int, segment3: string, value3: int) : string =\r\n        Router.encodeParts [ segment1; string value1; segment2; string value2; segment3; string value3 ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, value1: int, value2: int, value3: int) : string =\r\n        Router.encodeParts [ segment1; string value1; string value2; string value3 ] RouteMode.Hash\r\n\r\n    static member inline format(segment1: string, value1: int, value2: int, segment2: string) : string =\r\n        Router.encodeParts [ segment1; string value1; string value2; segment2 ] RouteMode.Hash\r\n\r\n\r\n    static member inline navigate([<ParamArray>] xs: string array) =\r\n        Router.nav (List.ofArray xs) HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate (xs: string list, queryString:(string * string) list) =\r\n        xs\r\n        |> Router.trySeparateLast\r\n        |> Option.map (fun (r, l) -> Router.nav (r @ [ l + Router.encodeQueryString queryString ]) HistoryMode.PushState RouteMode.Hash)\r\n        |> Option.defaultWith (fun _ -> Router.nav [ Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Hash)\r\n\r\n    static member inline navigate(segment: string, queryString: (string * string) list) =\r\n        Router.nav [ segment + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment: string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment + Router.encodeQueryString queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment: string, queryString: (string * int) list) =\r\n        Router.nav [ segment + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment: string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment + Router.encodeQueryStringInts queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; segment2 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2 + Router.encodeQueryString queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; segment2 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2 + Router.encodeQueryStringInts queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:int, queryString: (string * string) list) =\r\n        Router.nav [ segment1; segment2; unbox<string> segment3 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:int, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2;string  segment3 + Router.encodeQueryString queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:int, queryString: (string * int) list) =\r\n        Router.nav [ segment1; segment2; unbox<string> segment3 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:int, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2; unbox<string> segment3 + Router.encodeQueryStringInts queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; segment2; segment3 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2; segment3 + Router.encodeQueryString queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; segment2; segment3 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2; segment3 + Router.encodeQueryStringInts queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3 + Router.encodeQueryString queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3 + Router.encodeQueryStringInts queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; segment2; segment3; segment4 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2; segment3; segment4 + Router.encodeQueryString queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; segment2; segment3; segment4 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2; segment3; segment4 + Router.encodeQueryStringInts queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * string) list) =\r\n        Router.nav [ segment1; segment2; segment3; segment4; segment5 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2; segment3; segment4; segment5 + Router.encodeQueryString queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * int) list) =\r\n        Router.nav [ segment1; segment2; segment3; segment4; segment5 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2; segment3; segment4; segment5 + Router.encodeQueryStringInts queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; segment4 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; segment4 + Router.encodeQueryString queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; segment4 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; segment4 + Router.encodeQueryStringInts queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; segment4 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; segment4 + Router.encodeQueryString queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; segment4 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; segment4 + Router.encodeQueryStringInts queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; segment4; segment5; segment6 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; segment4; segment5; segment6 + Router.encodeQueryString queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; segment4; segment5; segment6 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; segment4; segment5; segment6 + Router.encodeQueryStringInts queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; unbox<string> segment4; segment5 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; unbox<string> segment4; segment5 + Router.encodeQueryString queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; unbox<string> segment4; segment5 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; unbox<string> segment4; segment5 + Router.encodeQueryStringInts queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; unbox<string> segment4; segment5 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; unbox<string> segment4; segment5 + Router.encodeQueryString queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; unbox<string> segment4; segment5 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; unbox<string> segment4; segment5 + Router.encodeQueryStringInts queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * string) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; segment4; segment5 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; segment4; segment5 + Router.encodeQueryString queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * int) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; segment4; segment5 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; segment4; segment5 + Router.encodeQueryStringInts queryString ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(fullPath: string) =\r\n        Router.nav [ fullPath ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(fullPath: string, mode: HistoryMode) =\r\n        Router.nav [ fullPath ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment: string, value: int) =\r\n        Router.nav [ segment; string value ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment: string, value: int, mode: HistoryMode) =\r\n        Router.nav [ segment; string value ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, value1: int, value2: int) =\r\n        Router.nav [ segment1; string value1; string value2 ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, value1: int, value2: int, mode: HistoryMode) =\r\n        Router.nav [ segment1; string value1; string value2 ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, value1: int) =\r\n        Router.nav [ segment1; segment2; string value1 ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, segment2: string, value1: int, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2; string value1 ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string) =\r\n        Router.nav [ segment1; string value1; segment2 ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, mode: HistoryMode) =\r\n        Router.nav [ segment1; string value1; segment2 ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, value2: int) =\r\n        Router.nav [ segment1; string value1; segment2; string value2 ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, value2: int, mode: HistoryMode) =\r\n        Router.nav [ segment1; string value1; segment2; string value2 ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, value2: int, segment3: string) =\r\n        Router.nav [ segment1; string value1; segment2; string value2; segment3 ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, value2: int, segment3: string, mode: HistoryMode) =\r\n        Router.nav [ segment1; string value1; segment2; string value2; segment3 ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, value2: int, segment3: string, segment4: string) =\r\n        Router.nav [ segment1; string value1; segment2; string value2; segment3; segment4 ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, value2: int, segment3: string, segment4: string, mode: HistoryMode) =\r\n        Router.nav [ segment1; string value1; segment2; string value2; segment3; segment4 ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, value2: int, segment3: string, value3: int) =\r\n        Router.nav [ segment1; string value1; segment2; string value2; segment3; string value3 ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, value2: int, segment3: string, value3: int, mode: HistoryMode) =\r\n        Router.nav [ segment1; string value1; segment2; string value2; segment3; string value3 ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, value1: int, value2: int, value3: int) =\r\n        Router.nav [ segment1; string value1; string value2; string value3 ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, value1: int, value2: int, value3: int, mode: HistoryMode) =\r\n        Router.nav [ segment1; string value1; string value2; string value3 ] mode RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, value1: int, value2: int, segment2: string) =\r\n        Router.nav [ segment1; string value1; string value2; segment2 ] HistoryMode.PushState RouteMode.Hash\r\n\r\n    static member inline navigate(segment1: string, value1: int, value2: int, segment2: string, mode: HistoryMode) =\r\n        Router.nav [ segment1; string value1; string value2; segment2 ] mode RouteMode.Hash\r\n\r\n    static member inline navigateBack() = Browser.Dom.history.back()\r\n    static member inline navigateBack(n: int) = Browser.Dom.history.go(-n)\r\n    static member inline navigateForward(n: int) = Browser.Dom.history.go(n)\r\n    static member inline navigatePath([<ParamArray>] xs: string array) =\r\n        Router.nav (List.ofArray xs) HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath (xs: string list, queryString:(string * string) list) =\r\n        xs\r\n        |> Router.trySeparateLast\r\n        |> Option.map (fun (r, l) -> Router.nav (r @ [ l + Router.encodeQueryString queryString ]) HistoryMode.PushState RouteMode.Path)\r\n        |> Option.defaultWith (fun _ -> Router.nav [ Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Path)\r\n\r\n    static member inline navigatePath(segment: string, queryString: (string * string) list) =\r\n        Router.nav [ segment + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment: string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment + Router.encodeQueryString queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment: string, queryString: (string * int) list) =\r\n        Router.nav [ segment + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment: string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment + Router.encodeQueryStringInts queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; segment2 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2 + Router.encodeQueryString queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; segment2 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2 + Router.encodeQueryStringInts queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:int, queryString: (string * string) list) =\r\n        Router.nav [ segment1; segment2; unbox<string> segment3 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:int, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2;string  segment3 + Router.encodeQueryString queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:int, queryString: (string * int) list) =\r\n        Router.nav [ segment1; segment2; unbox<string> segment3 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:int, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2; unbox<string> segment3 + Router.encodeQueryStringInts queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; segment2; segment3 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2; segment3 + Router.encodeQueryString queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; segment2; segment3 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2; segment3 + Router.encodeQueryStringInts queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3 + Router.encodeQueryString queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3 + Router.encodeQueryStringInts queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; segment2; segment3; segment4 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2; segment3; segment4 + Router.encodeQueryString queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; segment2; segment3; segment4 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2; segment3; segment4 + Router.encodeQueryStringInts queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * string) list) =\r\n        Router.nav [ segment1; segment2; segment3; segment4; segment5 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2; segment3; segment4; segment5 + Router.encodeQueryString queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * int) list) =\r\n        Router.nav [ segment1; segment2; segment3; segment4; segment5 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2; segment3; segment4; segment5 + Router.encodeQueryStringInts queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; segment4 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; segment4 + Router.encodeQueryString queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; segment4 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; segment4 + Router.encodeQueryStringInts queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; segment4 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; segment4 + Router.encodeQueryString queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; segment4 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; segment4 + Router.encodeQueryStringInts queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; segment4; segment5; segment6 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; segment4; segment5; segment6 + Router.encodeQueryString queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; segment4; segment5; segment6 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; segment4; segment5; segment6 + Router.encodeQueryStringInts queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; unbox<string> segment4; segment5 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; unbox<string> segment4; segment5 + Router.encodeQueryString queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; unbox<string> segment4; segment5 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; unbox<string> segment3; unbox<string> segment4; segment5 + Router.encodeQueryStringInts queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * string) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; unbox<string> segment4; segment5 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; unbox<string> segment4; segment5 + Router.encodeQueryString queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * int) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; unbox<string> segment4; segment5 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; unbox<string> segment4; segment5 + Router.encodeQueryStringInts queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * string) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; segment4; segment5 + Router.encodeQueryString queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * string) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; segment4; segment5 + Router.encodeQueryString queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * int) list) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; segment4; segment5 + Router.encodeQueryStringInts queryString ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * int) list, mode: HistoryMode) =\r\n        Router.nav [ segment1; unbox<string> segment2; segment3; segment4; segment5 + Router.encodeQueryStringInts queryString ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(fullPath: string) =\r\n        Router.nav [ fullPath ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(fullPath: string, mode: HistoryMode) =\r\n        Router.nav [ fullPath ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment: string, value: int) =\r\n        Router.nav [ segment; string value ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment: string, value: int, mode: HistoryMode) =\r\n        Router.nav [ segment; string value ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, value2: int) =\r\n        Router.nav [ segment1; string value1; string value2 ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, value2: int, mode: HistoryMode) =\r\n        Router.nav [ segment1; string value1; string value2 ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, value1: int) =\r\n        Router.nav [ segment1; segment2; string value1 ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, value1: int, mode: HistoryMode) =\r\n        Router.nav [ segment1; segment2; string value1 ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string) =\r\n        Router.nav [ segment1; string value1; segment2 ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, mode: HistoryMode) =\r\n        Router.nav [ segment1; string value1; segment2 ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, value2: int) =\r\n        Router.nav [ segment1; string value1; segment2; string value2 ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, value2: int, mode: HistoryMode) =\r\n        Router.nav [ segment1; string value1; segment2; string value2 ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, value2: int, segment3: string) =\r\n        Router.nav [ segment1; string value1; segment2; string value2; segment3 ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, value2: int, segment3: string, mode: HistoryMode) =\r\n        Router.nav [ segment1; string value1; segment2; string value2; segment3 ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, value2: int, segment3: string, segment4: string) =\r\n        Router.nav [ segment1; string value1; segment2; string value2; segment3; segment4 ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, value2: int, segment3: string, segment4: string, mode: HistoryMode) =\r\n        Router.nav [ segment1; string value1; segment2; string value2; segment3; segment4 ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, value2: int, segment3: string, value3: int) =\r\n        Router.nav [ segment1; string value1; segment2; string value2; segment3; string value3 ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, value2: int, segment3: string, value3: int, mode: HistoryMode) =\r\n        Router.nav [ segment1; string value1; segment2; string value2; segment3; string value3 ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, value2: int, value3: int) =\r\n        Router.nav [ segment1; string value1; string value2; string value3 ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, value2: int, value3: int, mode: HistoryMode) =\r\n        Router.nav [ segment1; string value1; string value2; string value3 ] mode RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, value2: int, segment2: string) =\r\n        Router.nav [ segment1; string value1; string value2; segment2 ] HistoryMode.PushState RouteMode.Path\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, value2: int, segment2: string, mode: HistoryMode) =\r\n        Router.nav [ segment1; string value1; string value2; segment2 ] mode RouteMode.Path\r\n\r\n\r\n    static member inline formatPath([<ParamArray>] xs: string array) =\r\n        Router.encodeParts (List.ofArray xs) RouteMode.Path\r\n\r\n    static member inline formatPath(xs: string list, queryString: (string * string) list) : string =\r\n        xs\r\n        |> Router.trySeparateLast\r\n        |> Option.map (fun (r, l) -> Router.encodeParts (r @ [ l + Router.encodeQueryString queryString ]) RouteMode.Path)\r\n        |> Option.defaultWith (fun _ -> Router.encodeParts [ Router.encodeQueryString queryString ] RouteMode.Path)\r\n\r\n    static member inline formatPath(segment: string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment + Router.encodeQueryString queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment: string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment + Router.encodeQueryStringInts queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; segment2 + Router.encodeQueryString queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; segment2 + Router.encodeQueryStringInts queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: string, segment3:int, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; segment2; unbox<string> segment3 + Router.encodeQueryString queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: string, segment3:int, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; segment2; unbox<string> segment3 + Router.encodeQueryStringInts queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: string, segment3:string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; segment2; segment3 + Router.encodeQueryString queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: string, segment3:string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; segment2; segment3 + Router.encodeQueryStringInts queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: int, segment3:string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; segment3 + Router.encodeQueryString queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: int, segment3:string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; segment3 + Router.encodeQueryStringInts queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; segment2; segment3; segment4 + Router.encodeQueryString queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; segment2; segment3; segment4 + Router.encodeQueryStringInts queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; segment2; segment3; segment4; segment5 + Router.encodeQueryString queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; segment2; segment3; segment4; segment5 + Router.encodeQueryStringInts queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; segment3; segment4 + Router.encodeQueryString queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; segment3; segment4 + Router.encodeQueryStringInts queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; unbox<string> segment3; segment4 + Router.encodeQueryString queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; unbox<string> segment3; segment4 + Router.encodeQueryStringInts queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; unbox<string> segment3; segment4; segment5; segment6 + Router.encodeQueryString queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; unbox<string> segment3; segment4; segment5; segment6 + Router.encodeQueryStringInts queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; unbox<string> segment3; unbox<string> segment4; segment5 + Router.encodeQueryString queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; unbox<string> segment3; unbox<string> segment4; segment5 + Router.encodeQueryStringInts queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; segment3; unbox<string> segment4; segment5 + Router.encodeQueryString queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; segment3; unbox<string> segment4; segment5 + Router.encodeQueryStringInts queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * string) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; segment3; segment4; segment5 + Router.encodeQueryString queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * int) list) : string =\r\n        Router.encodeParts [ segment1; unbox<string> segment2; segment3; segment4; segment5 + Router.encodeQueryStringInts queryString ] RouteMode.Path\r\n\r\n    static member inline formatPath(fullPath: string) : string =\r\n        Router.encodeParts [ fullPath ] RouteMode.Path\r\n\r\n    static member inline formatPath(fullPath: string list) : string =\r\n        Router.encodeParts fullPath RouteMode.Path\r\n\r\n    static member inline formatPath(segment: string, value: int) : string =\r\n        Router.encodeParts [ segment; string value ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, value1: int, value2: int) : string =\r\n        Router.encodeParts [ segment1; string value1; string value2 ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, segment2: string, value1: int) : string =\r\n        Router.encodeParts [ segment1; segment2; string value1 ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, value1: int, segment2: string) : string =\r\n        Router.encodeParts [ segment1; string value1; segment2 ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, value1: int, segment2: string, value2: int) : string =\r\n        Router.encodeParts [ segment1; string value1; segment2; string value2 ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, value1: int, segment2: string, value2: int, segment3: string) : string =\r\n        Router.encodeParts [ segment1; string value1; segment2; string value2; segment3 ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, value1: int, segment2: string, value2: int, segment3: string, segment4: string) : string =\r\n        Router.encodeParts [ segment1; string value1; segment2; string value2; segment3; segment4 ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, value1: int, segment2: string, value2: int, segment3: string, value3: int) : string =\r\n        Router.encodeParts [ segment1; string value1; segment2; string value2; segment3; string value3 ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, value1: int, value2: int, value3: int) : string =\r\n        Router.encodeParts [ segment1; string value1; string value2; string value3 ] RouteMode.Path\r\n\r\n    static member inline formatPath(segment1: string, value1: int, value2: int, segment2: string) : string =\r\n        Router.encodeParts [ segment1; string value1; string value2; segment2 ] RouteMode.Path\r\n\r\n[<Erase>]\r\ntype Cmd =\r\n    static member inline navigateBack() : Cmd<_> =\r\n        Cmd.ofSub (fun _ -> Browser.Dom.history.back())\r\n    static member inline navigateBack(n: int) : Cmd<_> =\r\n        Cmd.ofSub (fun _ -> Browser.Dom.history.go(-n))\r\n    static member inline navigateForward(n: int) : Cmd<_> =\r\n        Cmd.ofSub (fun _ -> Browser.Dom.history.go(n))\r\n    static member inline navigate([<ParamArray>] xs: string array) : Cmd<_> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(xs))\r\n\r\n    static member inline navigate(xs: string list, queryString: (string * string) list) : Cmd<_> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(xs, queryString))\r\n\r\n    static member inline navigate(segment: string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment, queryString))\r\n\r\n    static member inline navigate(segment: string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment, queryString, mode))\r\n\r\n    static member inline navigate(segment: string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment, queryString))\r\n\r\n    static member inline navigate(segment: string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment, queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:int, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, unbox<string> segment3 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:int, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2,string  segment3 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:int, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, unbox<string> segment3 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:int, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, unbox<string> segment3 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, unbox<string> segment2, segment3 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, unbox<string> segment2, segment3 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, unbox<string> segment2, segment3 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, unbox<string> segment2, segment3 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5, segment6, queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5, segment6, queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5, segment6, queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5, segment6, queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5 , queryString, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5 , queryString))\r\n\r\n    static member inline navigate(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, segment3, segment4, segment5 , queryString, mode))\r\n\r\n    static member inline navigate(fullPath: string) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(fullPath))\r\n\r\n    static member inline navigate(fullPath: string, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(fullPath, mode))\r\n\r\n    static member inline navigate(segment: string, value: int) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment, value))\r\n\r\n    static member inline navigate(segment: string, value: int, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment, value, mode))\r\n\r\n    static member inline navigate(segment1: string, value1: int, value2: int) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, value1, value2))\r\n\r\n    static member inline navigate(segment1: string, value1: int, value2: int, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, value1, value2, mode))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, value1: int) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, value1))\r\n\r\n    static member inline navigate(segment1: string, segment2: string, value1: int, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, segment2, value1, mode))\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, value1, segment2))\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, value1, segment2, mode))\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, value2: int) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, value1, segment2, value2))\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, value2: int, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, value1, segment2, value2, mode))\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, value2: int, segment3: string) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, value1, segment2, value2, segment3))\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, value2: int, segment3: string, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, value1, segment2, value2, segment3, mode))\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, value2: int, segment3: string, segment4: string) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, value1, segment2, value2, segment3, segment4))\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, value2: int, segment3: string, segment4: string, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, value1, segment2, value2, segment3, segment4, mode))\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, value2: int, segment3: string, value3: int) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, value1, segment2, value2, segment3, value3))\r\n\r\n    static member inline navigate(segment1: string, value1: int, segment2: string, value2: int, segment3: string, value3: int, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, value1, segment2, value2, segment3, value3, mode))\r\n\r\n    static member inline navigate(segment1: string, value1: int, value2: int, value3: int) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, value1, value2, value3))\r\n\r\n    static member inline navigate(segment1: string, value1: int, value2: int, value3: int, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, value1, value2, value3, mode))\r\n\r\n    static member inline navigate(segment1: string, value1: int, value2: int, segment2: string) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, value1, value2, segment2))\r\n\r\n    static member inline navigate(segment1: string, value1: int, value2: int, segment2: string, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigate(segment1, value1, value2, segment2, mode))\r\n\r\n    static member inline navigatePath([<ParamArray>] xs: string array) =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(xs))\r\n\r\n    static member inline navigatePath(xs: string list, queryString: (string * string) list) =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(xs, queryString))\r\n\r\n    static member inline navigatePath(segment: string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment, queryString))\r\n\r\n    static member inline navigatePath(segment: string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment, queryString, mode))\r\n\r\n    static member inline navigatePath(segment: string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment, queryString))\r\n\r\n    static member inline navigatePath(segment: string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:int, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:int, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2,string  segment3, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:int, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:int, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, segment4: string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, segment3:string, segment4: string, segment5, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, segment6, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, segment6, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, segment6, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: string, segment5: string, segment6: string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, segment6, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:int, segment4: int, segment5: string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: int, segment5: string, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * string) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * string) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, queryString, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * int) list) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, queryString))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: int, segment3:string, segment4: string, segment5, queryString: (string * int) list, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, segment3, segment4, segment5, queryString, mode))\r\n\r\n    static member inline navigatePath(fullPath: string) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(fullPath))\r\n\r\n    static member inline navigatePath(fullPath: string, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(fullPath, mode))\r\n\r\n    static member inline navigatePath(segment: string, value: int) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment, value))\r\n\r\n    static member inline navigatePath(segment: string, value: int, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment, value, mode))\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, value2: int) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, value1, value2))\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, value2: int, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, value1, value2, mode))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, value1: int) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, value1))\r\n\r\n    static member inline navigatePath(segment1: string, segment2: string, value1: int, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, segment2, value1, mode))\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, value1, segment2))\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, value1, segment2, mode))\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, value2: int) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, value1, segment2, value2))\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, value2: int, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, value1, segment2, value2, mode))\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, value2: int, segment3: string) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, value1, segment2, value2, segment3))\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, value2: int, segment3: string, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, value1, segment2, value2, segment3, mode))\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, value2: int, segment3: string, segment4: string) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, value1, segment2, value2, segment3, segment4))\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, value2: int, segment3: string, segment4: string, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, value1, segment2, value2, segment3, segment4, mode))\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, value2: int, segment3: string, value3: int) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, value1, segment2, value2, segment3, value3))\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, segment2: string, value2: int, segment3: string, value3: int, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, value1, segment2, value2, segment3, value3, mode))\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, value2: int, value3: int) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, value1, value2, value3))\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, value2: int, value3: int, mode: HistoryMode) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, value1, value2, value3, mode))\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, value2: int, segment2: string) : Cmd<'Msg> =\r\n        Cmd.ofSub (fun _ -> Router.navigatePath(segment1, value1, value2, segment2))\r\n\r\n    static member inline navigatePath(segment1: string, value1: int, value2: int, segment2: string, mode: HistoryMode) : Cmd<'Msg> =\r\n            Cmd.ofSub (fun _ -> Router.navigatePath(segment1, value1, value2, segment2, mode))\r\n\r\nmodule Route =\r\n    let (|Int|_|) (input: string) =\r\n        match Int32.TryParse input with\r\n        | true, value -> Some value\r\n        | _ -> None\r\n\r\n    let (|Int64|_|) (input: string) =\r\n        match Int64.TryParse input with\r\n        | true, value -> Some value\r\n        | _ -> None\r\n\r\n    let (|Guid|_|) (input: string) =\r\n        match Guid.TryParse input with\r\n        | true, value -> Some value\r\n        | _ -> None\r\n\r\n    let (|Number|_|) (input: string) =\r\n        match Double.TryParse input with\r\n        | true, value -> Some value\r\n        | _ -> None\r\n\r\n    let (|Decimal|_|) (input: string) =\r\n        match Decimal.TryParse input with\r\n        | true, value -> Some value\r\n        | _ -> None\r\n\r\n    let (|Bool|_|) (input: string) =\r\n        match input.ToLower() with\r\n        | (\"1\"|\"true\")  -> Some true\r\n        | (\"0\"|\"false\") -> Some false\r\n        | \"\" -> Some true\r\n        | _ -> None\r\n\r\n    /// Used to parse the query string parameter of the route.\r\n    ///\r\n    /// For example to match against\r\n    ///\r\n    /// `/users?id={value}`\r\n    ///\r\n    /// You can pattern match:\r\n    ///\r\n    /// `[ \"users\"; Route.Query [ \"id\", value ] ] -> value`\r\n    ///\r\n    /// When `{value}` is an integer then you can pattern match:\r\n    ///\r\n    /// `[ \"users\"; Route.Query [ \"id\", Route.Int userId ] ] -> userId`\r\n    let (|Query|_|) (input: string) =\r\n        try\r\n            let urlParams = Router.createUrlSearchParams input\r\n            Some [ for entry in urlParams.entries() -> entry.[0], entry.[1] ]\r\n        with\r\n        | _ -> None","module Pages.Acknowledgement\n\nopen Feliz\nopen Feliz.DaisyUI\nopen Feliz.Router\nopen Shared\n\nlet View () =\n    Html.div [\n        Html.p [\n            Html.span \"The library was (initially) created using the amazing \"\n            Html.a \"ts2fable\" \"https://github.com/fable-compiler/ts2fable\"\n            Html.span \" tool and, of course, is built upon the powerful \"\n            Html.a \"Fable\" \"https://fable.io/\"\n            Html.span \" engine.\"\n        ]\n        Html.p [\n            Html.span \"Furthermore, the docs site relies on \"\n            Html.a \"Feliz\" \"https://zaid-ajaj.github.io/Feliz/\"\n            Html.span \" and \"\n            Html.a \"Feliz.DaisyUI\" \"https://dzoukr.github.io/Feliz.DaisyUI/\"\n            Html.span \" – the wonderful work that makes building React application in F# enjoyable.\"\n        ]\n        Html.p [\n            Html.span \"This library was originally created by the author for their (personal) need of using \"\n            Html.a \"Auth0\" \"https://auth0.com/\"\n            Html.span \" for authentication in \"\n            Html.a \"SAFE stack\" \"https://safe-stack.github.io/\"\n            Html.span \". As it might be useful for anyone of similar needs, the library was published to the NuGet package directory and this documentation site was built based on the Auth0 tutorials in JavaScript. \"\n            Html.span \"As a F# beginner, the author does wish to acknowledge that, although the author has done their best to ensure that the library is well transpiled from JavaScript,\"\n            Html.span \" the library could contain mistakes and/or further improvements can be made. \"\n            Html.span \"Therefore, contributions are welcomed! If you wish to submit changes, have a look at the \"\n            Daisy.link [\n                link.accent\n                link.hover\n                prop.href (Router.format(\"contribution\"))\n                prop.text \"Contribution\"\n            ]\n            Html.span \" section.\"\n        ]\n        Html.p [\n            Html.span \"The work is distributed under the \"\n            Html.a \"MIT license\" \"https://github.com/chengh42/Fable.Auth0.React/blob/main/LICENSE\"\n            Html.span \".\"\n        ]\n    ]","[<RequireQualifiedAccess>]\nmodule Pages.Installation\n\nopen Feliz\nopen Shared\n\n[<ReactComponent>]\nlet View () =\n    Html.div [\n        Html.p \"Install npm dependencies with npm or yarn:\"\n        Highlight.highlight [\n            highlight.language.bash\n            prop.text \"\"\"# using npm\nnpm install @auth0/auth0-react\n\n# using yarn\nyarn add @auth0/auth0-react\n\"\"\"\n        ]\n        Html.p \"And install nuget package with nuget or paket:\"\n        Highlight.highlight [\n            highlight.language.bash\n            prop.text \"\"\"# using nuget\nInstall-Package Fable.Auth0.React\n\n# using paket\npaket add Fable.Auth0.React\n\"\"\"\n        ]\n    ]","namespace Fable.Auth0.React\n\n[<AutoOpen>]\nmodule Core =\n    /// The state of the application before the user was redirected to the login page.\n    type AppState = Auth0Provider.AppState\n    /// The main configuration to instantiate the `Auth0Provider`.\n    type Auth0ProviderOptions = Auth0Provider.Auth0ProviderOptions\n    /// Components wrapped in `withAuth0` will have an additional `auth0` prop\n    type WithAuth0Props = WithAuth0.WithAuth0Props\n    /// Options for the withAuthenticationRequired Higher Order Component\n    type WithAuthenticationRequiredOptions = WithAuthenticationRequired.WithAuthenticationRequiredOptions\n    /// Contains the authenticated state and authentication methods provided by the `useAuth0` hook.\n    type Auth0ContextInterface = Auth0Context.Auth0ContextInterface\n    type RedirectLoginOptions = Auth0Context.RedirectLoginOptions\n    type PopupLoginOptions = Global.PopupLoginOptions\n    type PopupConfigOptions = Global.PopupConfigOptions\n    type GetIdTokenClaimsOptions = Global.GetIdTokenClaimsOptions\n    type GetTokenWithPopupOptions = Global.GetTokenWithPopupOptions\n    type LogoutOptions = Global.LogoutOptions\n    type LogoutUrlOptions = Global.LogoutUrlOptions\n    type CacheLocation = Global.CacheLocation\n    type GetTokenSilentlyOptions = Global.GetTokenSilentlyOptions\n    type IdToken = Global.IdToken\n    type User = Global.User\n    type OAuthError = Errors.OAuthError\n\n    // @TODO\n    // type ICache = Global.ICache\n    // type InMemoryCache = Global.InMemoryCache\n    // type LocalStorageCache = Global.LocalStorageCache\n    // type Cacheable = Global.Cacheable\n\n    /// ```jsx\n    /// <Auth0Provider\n    ///   domain={domain}\n    ///   clientId={clientId}\n    ///   redirectUri={window.location.origin}>\n    ///   <MyApp />\n    /// </Auth0Provider>\n    /// ```\n    ///\n    /// Provides the Auth0Context to its child components.\n    let Auth0Provider opts = Auth0Provider.Auth0Provider opts\n\n    /// ```js\n    /// const {\n    ///   // Auth state:\n    ///   error,\n    ///   isAuthenticated,\n    ///   isLoading,\n    ///   user,\n    ///   // Auth methods:\n    ///   getAccessTokenSilently,\n    ///   getAccessTokenWithPopup,\n    ///   getIdTokenClaims,\n    ///   loginWithRedirect,\n    ///   loginWithPopup,\n    ///   logout,\n    /// } = useAuth0<TUser>();\n    /// ```\n    /// Use the `useAuth0` hook in your components to access the auth state and methods.\n    /// \n    /// TUser is an optional type param to provide a type to the `user` field.\n    let useAuth0 () = UseAuth0.useAuth0 ()\n\n    /// ```jsx\n    /// class MyComponent extends Component {\n    ///   render() {\n    ///     // Access the auth context from the `auth0` prop\n    ///     const { user } = this.props.auth0;\n    ///     return <div>Hello {user.name}!</div>\n    ///   }\n    /// }\n    /// // Wrap your class component in withAuth0\n    /// export default withAuth0(MyComponent);\n    /// ```\n    /// \n    /// Wrap your class components in this Higher Order Component to give them access to the Auth0Context\n    let withAuth0 = WithAuth0.withAuth0\n\n    /// ```js\n    /// const MyProtectedComponent = withAuthenticationRequired(MyComponent);\n    /// ```\n    ///\n    /// When you wrap your components in this Higher Order Component and an anonymous user visits your component\n    /// they will be redirected to the login page and returned to the page they we're redirected from after login.\n    let withAuthenticationRequired = WithAuthenticationRequired.withAuthenticationRequired\n\n    /// The Auth0 Context\n    let Auth0Context = Auth0Context.Auth0Context","// Generated using ts2fable 0.7.1\nmodule rec Auth0Provider\n\nopen Fable.Core\nopen Fable.Core.JS\nopen Fable.React\nopen Fable.Core.JsInterop\n\n// @TODO\n// type CacheLocation = @auth0_auth0_spa_js.CacheLocation\n// type ICache = @auth0_auth0_spa_js.ICache\n\n/// ```jsx\n/// <Auth0Provider\n///   domain={domain}\n///   clientId={clientId}\n///   redirectUri={window.location.origin}>\n///   <MyApp />\n/// </Auth0Provider>\n/// ```\n///\n/// Provides the Auth0Context to its child components.\nlet Auth0Provider (opts : Auth0ProviderOptions) children : ReactElement =\n    let propsObject = opts |> JS.Constructors.Object.entries |> createObj\n    ofImport \"Auth0Provider\" \"@auth0/auth0-react\" propsObject children\n\n/// The state of the application before the user was redirected to the login page.\ntype [<AllowNullLiteral>] AppState =\n    abstract returnTo: string option with get, set\n    [<Emit \"$0[$1]{{=$2}}\">] abstract Item: key: string -> obj option with get, set\n\n/// The main configuration to instantiate the `Auth0Provider`.\ntype [<AllowNullLiteral>] Auth0ProviderOptions =\n    /// The child nodes your Provider has wrapped\n    abstract children: ReactElement option with get, set\n    /// By default this removes the code and state parameters from the url when you are redirected from the authorize page.\n    /// It uses `window.history` but you might want to overwrite this if you are using a custom router, like `react-router-dom`\n    /// See the EXAMPLES.md for more info.\n    abstract onRedirectCallback: (AppState -> unit) option with get, set\n    /// By default, if the page url has code/state params, the SDK will treat them as Auth0's and attempt to exchange the\n    /// code for a token. In some cases the code might be for something else (another OAuth SDK perhaps). In these\n    /// instances you can instruct the client to ignore them eg\n    /// \n    /// ```jsx\n    /// <Auth0Provider\n    ///    clientId={clientId}\n    ///    domain={domain}\n    ///    skipRedirectCallback={window.location.pathname === '/stripe-oauth-callback'}\n    /// >\n    /// ```\n    abstract skipRedirectCallback: bool option with get, set\n    /// Your Auth0 account domain such as `'example.auth0.com'`,\n    /// `'example.eu.auth0.com'` or , `'example.mycompany.com'`\n    /// (when using [custom domains](https://auth0.com/docs/custom-domains))\n    abstract domain: string with get, set\n    /// The issuer to be used for validation of JWTs, optionally defaults to the domain above\n    abstract issuer: string option with get, set\n    /// The Client ID found on your Application settings page\n    abstract clientId: string with get, set\n    /// The default URL where Auth0 will redirect your browser to with\n    /// the authentication result. It must be whitelisted in\n    /// the \"Allowed Callback URLs\" field in your Auth0 Application's\n    /// settings. If not provided here, it should be provided in the other\n    /// methods that provide authentication.\n    abstract redirectUri: string option with get, set\n    /// The value in seconds used to account for clock skew in JWT expirations.\n    /// Typically, this value is no more than a minute or two at maximum.\n    /// Defaults to 60s.\n    abstract leeway: float option with get, set\n    \n    // @TODO\n    // /// The location to use when storing cache data. Valid values are `memory` or `localstorage`.\n    // /// The default setting is `memory`.\n    // /// \n    // /// Read more about [changing storage options in the Auth0 docs](https://auth0.com/docs/libraries/auth0-single-page-app-sdk#change-storage-options)\n    // abstract cacheLocation: CacheLocation option with get, set\n    \n    // @TODO\n    // /// Specify a custom cache implementation to use for token storage and retrieval. This setting takes precedence over `cacheLocation` if they are both specified.\n    // /// \n    // /// Read more about [creating a custom cache](https://github.com/auth0/auth0-spa-js#creating-a-custom-cache)\n    // abstract cache: ICache option with get, set\n    /// If true, refresh tokens are used to fetch new access tokens from the Auth0 server. If false, the legacy technique of using a hidden iframe and the `authorization_code` grant with `prompt=none` is used.\n    /// The default setting is `false`.\n    /// \n    /// **Note**: Use of refresh tokens must be enabled by an administrator on your Auth0 client application.\n    abstract useRefreshTokens: bool option with get, set\n    /// A maximum number of seconds to wait before declaring background calls to /authorize as failed for timeout\n    /// Defaults to 60s.\n    abstract authorizeTimeoutInSeconds: float option with get, set\n    /// Changes to recommended defaults, like defaultScope\n    abstract advancedOptions: Auth0ProviderOptionsAdvancedOptions option with get, set\n    /// Maximum allowable elapsed time (in seconds) since authentication.\n    /// If the last time the user authenticated is greater than this value,\n    /// the user must be reauthenticated.\n    abstract maxAge: U2<string, float> option with get, set\n    /// The default scope to be used on authentication requests.\n    /// The defaultScope defined in the Auth0Client is included\n    /// along with this scope\n    abstract scope: string option with get, set\n    /// The default audience to be used for requesting API access.\n    abstract audience: string option with get, set\n    /// The Id of an organization to log in to.\n    /// \n    /// This will specify an `organization` parameter in your user's login request and will add a step to validate\n    /// the `org_id` claim in your user's ID Token.\n    abstract organization: string option with get, set\n    /// The Id of an invitation to accept. This is available from the user invitation URL that is given when participating in a user invitation flow.\n    abstract invitation: string option with get, set\n    /// The name of the connection configured for your application.\n    /// If null, it will redirect to the Auth0 Login Page and show\n    /// the Login Widget.\n    abstract connection: string option with get, set\n    /// If you need to send custom parameters to the Authorization Server,\n    /// make sure to use the original parameter name.\n    [<Emit \"$0[$1]{{=$2}}\">] abstract Item: key: string -> obj option with get, set\n\ntype [<AllowNullLiteral>] Auth0ProviderOptionsAdvancedOptions =\n    /// The default scope to be included with all requests.\n    /// If not provided, 'openid profile email' is used. This can be set to `null` in order to effectively remove the default scopes.\n    /// \n    /// Note: The `openid` scope is **always applied** regardless of this setting.\n    abstract defaultScope: string option with get, set\n","module Index\n\nopen Elmish\nopen Feliz.Router\n\ntype Url = Url of string with member this.UrlSegment = this |> function Url v -> [v]\n\n[<RequireQualifiedAccess>]\ntype Page =\n    | Index\n    | Usage\n    | CallApi\n    | Contribution\n    | Acknowledgement with\n    static member parseUrl (url: string list) =\n        match url with\n        | [ \"usage\" ] -> Page.Usage\n        | [ \"call-api\" ] -> Page.CallApi\n        | [ \"contribution\" ] -> Page.Contribution\n        | [ \"acknowledgement\" ] -> Page.Acknowledgement\n        | [ \"/\" ] | _ -> Page.Index\n\n    static member parsePage (page: Page) =\n        match page with\n        | Index -> Url \"/\", \"Installation\", Pages.Installation.View ()\n        | Usage -> Url \"usage\", \"Basic usage\", Pages.Usage.View ()\n        | CallApi -> Url \"call-api\", \"Call an API\", Pages.CallApi.View ()\n        | Contribution -> Url \"contribution\", \"Contribution\", Pages.Contribution.View ()\n        | Acknowledgement -> Url \"acknowledgement\", \"Acknowledgement\", Pages.Acknowledgement.View ()\n\ntype Model = { CurrentUrl : string list; CurrentPage : Page; UserAccessToken : string }\n\ntype Msg = UrlChanged of string list | SetAccessToken of string\n\nlet init () : Model =\n    { CurrentUrl = Router.currentUrl()\n      CurrentPage = Router.currentUrl() |> Page.parseUrl\n      UserAccessToken = \"\" }\n\nlet update (msg: Msg) (model: Model) : Model =\n    match msg with\n    | UrlChanged url -> { model with CurrentUrl = url; CurrentPage = Page.parseUrl url }\n    | SetAccessToken md -> { model with UserAccessToken = md }\n\nopen Fable.Core\nopen Fable.Auth0.React\nopen Fable.SimpleHttp\nopen Feliz\nopen Feliz.DaisyUI\nopen Feliz.DaisyUI.Operators\n\nlet auth0App (children: seq<ReactElement>) =\n    let opts =\n        unbox<Auth0ProviderOptions>\n            {| domain = \"dev-nik3xlx8.us.auth0.com\"\n               clientId = \"sGGwICcD2Cnp3DX1A0kacQmcsY0Ri7nu\"\n               redirectUri = Browser.Dom.window.location.href\n               audience = \"https://dev-nik3xlx8.us.auth0.com/api/v2/\"\n               scope = \"read:current_user update:current_user_metadata\"\n               useRefreshTokens = true |}\n    Auth0Provider opts children\n\n[<ReactComponent>]\nlet LoginButton () =\n    let ctxAuth0 = useAuth0 ()\n    let handleLoginWithRedirect _ =\n        let opts = unbox<RedirectLoginOptions> null\n        ctxAuth0.loginWithRedirect opts\n        |> Async.AwaitPromise\n        |> Async.StartImmediate\n\n    match ctxAuth0.isLoading, ctxAuth0.isAuthenticated with\n    | false, false ->\n        Daisy.tooltip [\n            tooltip.text \"Click to login\"\n            prop.children [\n                Daisy.button.a [\n                    button.primary\n                    button.outline\n                    ++ prop.className \"mx-3\"\n                    prop.onClick handleLoginWithRedirect\n                    prop.children [\n                        Html.p [\n                            prop.style [ style.paddingRight (length.em 0.5) ]\n                            prop.text \"Try Auth0\" ]\n                        Html.i [ prop.className \"fas fa-sign-in-alt\" ]\n                    ]\n                ]\n            ]\n        ]\n    | _ ->\n        Html.none\n\n[<ReactComponent>]\nlet Profile (props: {| SetAccessToken: string -> unit |}) =\n    let ctxAuth0 = useAuth0 ()\n    let username, picture =\n        match ctxAuth0.user with\n        | Some (u: User) ->\n            sprintf \"%A\" u.name,\n            sprintf \"%A\" u.picture\n        | None -> \"\", \"\"\n    let handleLogoutWithRedirect _ =\n        let returnTo = Browser.Dom.window.location.href\n        let opts = unbox<LogoutOptions> {| returnTo = returnTo |}\n        ctxAuth0.logout opts\n\n    React.useEffect (fun () ->\n        let opts =\n            unbox<GetTokenSilentlyOptions>\n                {| audience = \"https://dev-nik3xlx8.us.auth0.com/api/v2/\"\n                   scope = \"read:current_user\" |}\n        try\n            async {\n                let! accessToken =\n                    ctxAuth0.getAccessTokenSilently.Invoke opts\n                    |> Async.AwaitPromise\n\n                props.SetAccessToken accessToken\n            }\n            |> Async.StartImmediate\n\n        with ex ->\n            // @TODO: error handling\n            JS.console.log(ex.Message)\n    , [| |])\n\n    match ctxAuth0.isLoading, ctxAuth0.isAuthenticated with\n    | true, _ ->\n        Daisy.card [\n            Daisy.cardBody [\n                Shared.Spinner ()\n            ]\n        ]\n    | _, true ->\n        Daisy.card [\n            card.bordered\n            card.compact\n            color.bgPrimaryContent\n            ++ prop.className \"m-5\"\n            prop.children [\n                Daisy.cardBody [\n                    Daisy.cardTitle [\n                        prop.className \"mx-3\"\n                        prop.style [\n                            style.display.flex\n                            style.justifyContent.spaceAround\n                            style.alignContent.center\n                        ]\n                        prop.children [\n                            Daisy.avatar [\n                                Html.div [\n                                    prop.className \"rounded-btn w-14 h-14\"\n                                    prop.children [\n                                        Html.img [ prop.src picture ]\n                                    ]\n                                ]\n                            ]\n                            Html.div [\n                                prop.style [\n                                    style.margin length.auto\n                                    style.paddingBottom (length.em 0.25)\n                                ]\n                                prop.text username\n                            ]\n                        ]\n                    ]\n                    Daisy.cardActions [\n                        Daisy.button.label [\n                            prop.htmlFor \"modal-user-access-token\"\n                            button.primary\n                            prop.text \"Get token\"\n                        ]\n                        Daisy.button.button [\n                            button.primary\n                            button.outline\n                            prop.onClick handleLogoutWithRedirect\n                            prop.children [\n                                Html.p [\n                                    prop.className \"mr-3\"\n                                    prop.text \"Logout\"\n                                ]\n                                Html.i [ prop.className \"fas fa-sign-out-alt\" ]\n                            ]\n                        ]\n                    ]\n                ]\n            ]\n        ]\n    | false, false ->\n        Html.none\n\nlet private menuPages (title: string) pages model dispatch =\n    Daisy.menu [\n        menu.compact\n        prop.className \"flex flex-col p-3 pt-0\"\n        prop.children [\n            Daisy.menuTitle title\n            for page in pages do\n                let url, title, _ = Page.parsePage page\n                Html.li [\n                    Html.a [\n                        if page = model.CurrentPage then menuItem.active\n                        prop.text title\n                        prop.href (Router.format(url.UrlSegment))\n                    ]\n                ]\n        ]\n    ]\n\nlet private leftSide (model: Model) (dispatch: Msg -> unit) =\n    let pagesDocs =\n        [ Page.Index\n          Page.Usage\n          Page.CallApi ]\n    let pagesAbout =\n        [ Page.Contribution\n          Page.Acknowledgement ]\n\n    Daisy.drawerSide [\n        Daisy.drawerOverlay [ prop.htmlFor \"main-menu\" ]\n        Html.aside [\n            prop.className \"flex flex-col border-r w-80 bg-base-100 text-base-content\"\n            prop.style [\n                style.height (length.vh 100)\n                style.justifyContent.spaceBetween\n            ]\n            prop.children [\n                Html.div [\n                    Html.div [\n                        prop.className \"font-title px-5 py-5\"\n                        prop.children [\n                            Shared.Html.h1 \"Fable.Auth0.React\"\n                            Html.div [\n                                prop.className \"py-1\"\n                                prop.children [\n                                    Html.a [\n                                        prop.href \"https://www.nuget.org/packages/Fable.Auth0.React/\"\n                                        prop.target \"_blank\"\n                                        prop.children [\n                                            Html.img [ prop.src \"https://img.shields.io/nuget/v/Fable.Auth0.React?style=for-the-badge&?logo=nuget\" ]\n                                        ]\n                                    ]\n                                ]\n                            ]\n                            Html.div [\n                                prop.className \"py-2\"\n                                prop.children [\n                                    Html.p [\n                                        Html.span \"Fable library for \"\n                                        Daisy.link [\n                                            link.hover\n                                            link.accent\n                                            prop.href \"https://github.com/auth0/auth0-react\"\n                                            prop.target \"_blank\"\n                                            prop.children [ Html.span \"@auth0/auth0-react\" ]\n                                        ]\n                                        Html.span \", the Auth0 SDK for React Single Page Applications (SPA).\"\n                                    ]\n                                ]\n                            ]\n                            Html.div [\n                                prop.className \"py-2\"\n                                prop.style [ style.display.flex; style.alignContent.center ]\n                                prop.children [\n                                    Daisy.button.a [\n                                        button.secondary\n                                        prop.href \"https://github.com/chengh42/Fable.Auth0.React\"\n                                        prop.target \"_blank\"\n                                        prop.children [\n                                            Html.i [ prop.className \"fab fa-github px-1\" ]\n                                            Html.i [ prop.className \"fas fa-code px-1\" ]\n                                        ]\n                                    ]\n                                    LoginButton ()\n                                ]\n                            ]\n                        ]\n                    ]\n                    menuPages \"Docs\" pagesDocs model dispatch\n                    menuPages \"About\" pagesAbout model dispatch\n                ]\n                Profile ({| SetAccessToken = SetAccessToken >> dispatch |})\n            ]\n        ]\n    ]\n\nlet rightSide (model: Model) (dispatch: Msg -> unit) =\n    let url, title, content = model.CurrentPage |> Page.parsePage\n    Daisy.drawerContent [\n        Html.div [\n            prop.className \"px-5 py-5\"\n            prop.children [\n                Html.h2 [\n                    color.textPrimary\n                    ++ prop.className \"mb-6 text-4xl font-bold\"\n                    prop.text title\n                ]\n                content\n            ]\n        ]\n    ]\n\nlet private pageLayout (model: Model) (dispatch: Msg -> unit) =\n    Html.div [\n        prop.className \"bg-base-100 text-base-content h-screen\"\n        theme.cupcake\n        prop.children [\n            Daisy.drawer [\n                drawer.mobile\n                prop.children [\n                    Daisy.drawerToggle [ prop.id \"main-menu\" ]\n                    rightSide model dispatch\n                    leftSide model dispatch\n                    Daisy.modalToggle [ prop.id \"modal-user-access-token\" ]\n                    Daisy.modal [\n                        prop.children [\n                            Daisy.modalBox [\n                                match model.UserAccessToken with\n                                | \"\" -> Shared.Spinner ()\n                                | token ->\n                                    Html.div [\n                                        Shared.Html.p \"The retrieved user token to be used for calling secured API:\"\n                                        Daisy.alert [\n                                            alert.info\n                                            prop.children [\n                                                Html.span [\n                                                    prop.style [\n                                                        style.overflowX.scroll\n                                                        style.maxHeight (length.em 10)\n                                                        style.margin (length.em 1)\n                                                        style.paddingBottom (length.em 1)\n                                                    ]\n                                                    prop.text token\n                                                ]\n                                            ]\n                                        ]\n                                    ]\n                                Daisy.modalAction [\n                                    Daisy.button.label [\n                                        prop.htmlFor \"modal-user-access-token\"\n                                        prop.text \"I see\"\n                                        button.primary\n                                    ]\n                                ]\n                            ]\n                        ]\n                    ]\n                ]\n            ]\n        ]\n    ]\n\nlet view (model: Model) (dispatch: Msg -> unit) =\n    auth0App [\n        React.router [\n            router.hashMode\n            router.onUrlChanged (UrlChanged >> dispatch)\n            router.children [ pageLayout model dispatch ]\n        ]\n    ]","module App\n\nopen Elmish\nopen Elmish.React\n\n#if DEBUG\nopen Elmish.Debug\nopen Elmish.HMR\n#endif\n\nProgram.mkSimple Index.init Index.update Index.view\n#if DEBUG\n|> Program.withConsoleTrace\n#endif\n|> Program.withReactSynchronous \"root\"\n#if DEBUG\n|> Program.withDebugger\n#endif\n|> Program.run\n"],"sourceRoot":""}